<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DSL IDE with Language Server</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Monaco', 'Consolas', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 400;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #f44336;
        }

        .status-indicator.connected {
            background: #4caf50;
        }

        .main-container {
            flex: 1;
            display: flex;
            height: calc(100vh - 60px);
            position: relative;
        }

        .sidebar {
            width: 250px;
            min-width: 150px;
            max-width: 500px;
            background: #252526;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }

        .splitter-vertical {
            width: 5px;
            background: #3e3e42;
            cursor: col-resize;
            position: relative;
            user-select: none;
        }

        .splitter-vertical:hover {
            background: #007acc;
        }

        .splitter-vertical.dragging {
            background: #007acc;
        }

        .splitter-horizontal {
            height: 5px;
            background: #3e3e42;
            cursor: row-resize;
            user-select: none;
        }

        .splitter-horizontal:hover {
            background: #007acc;
        }

        .splitter-horizontal.dragging {
            background: #007acc;
        }

        .sidebar h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            color: #969696;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 400px;
            overflow: hidden;
        }

        #monaco-editor {
            flex: 1;
            min-height: 200px;
        }

        .tabs {
            background: #2d2d30;
            display: flex;
            border-bottom: 1px solid #3e3e42;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            background: #2d2d30;
            color: #969696;
            transition: all 0.2s;
        }

        .tab:hover {
            background: #3e3e42;
        }

        .tab.active {
            background: #1e1e1e;
            color: #d4d4d4;
            border-bottom: 2px solid #007acc;
        }

        #monaco-editor {
            flex: 1;
            width: 100%;
        }

        .output-panel {
            height: 200px;
            min-height: 100px;
            background: #1e1e1e;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .output-header {
            background: #2d2d30;
            padding: 8px 15px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .output-tabs {
            display: flex;
            gap: 15px;
        }

        .output-tab {
            cursor: pointer;
            color: #969696;
            font-size: 14px;
            padding: 2px 5px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .output-tab:hover {
            color: #d4d4d4;
        }

        .output-tab.active {
            color: #d4d4d4;
            border-bottom-color: #007acc;
        }

        .output-content {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
        }

        .diagnostics-list {
            list-style: none;
        }

        .diagnostic-item {
            padding: 5px;
            margin-bottom: 5px;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .diagnostic-item:hover {
            background: #2d2d30;
        }

        .diagnostic-item.error {
            border-left-color: #f44336;
            color: #f48771;
        }

        .diagnostic-item.warning {
            border-left-color: #ffeb3b;
            color: #dcdcaa;
        }

        .diagnostic-item.info {
            border-left-color: #2196f3;
            color: #9cdcfe;
        }

        /* AI Agent Chat Styles */
        .agent-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #1e1e1e;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 200px;
        }

        .chat-message {
            padding: 10px 12px;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .chat-message.user {
            align-self: flex-end;
            background: #007acc;
            color: white;
        }

        .chat-message.assistant {
            align-self: flex-start;
            background: #2d2d30;
            color: #cccccc;
            border: 1px solid #3e3e42;
        }

        .chat-message.system {
            align-self: center;
            background: #3e3e42;
            color: #969696;
            font-size: 0.9em;
            max-width: 90%;
        }

        .chat-input-container {
            padding: 12px;
            border-top: 1px solid #3e3e42;
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            color: #cccccc;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        .chat-input:focus {
            outline: none;
            border-color: #007acc;
        }

        .chat-send-btn {
            padding: 8px 16px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-send-btn:hover:not(:disabled) {
            background: #1a86d9;
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .context-indicator {
            padding: 4px 8px;
            background: #3e3e42;
            color: #969696;
            font-size: 11px;
            border-radius: 3px;
            margin-bottom: 8px;
        }

        .message-code {
            background: #1e1e1e;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .btn {
            padding: 5px 15px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #5a5a5a;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #3c3c3c;
        }

        .btn.secondary:hover {
            background: #505050;
        }

        .test-results {
            padding: 10px;
            background: #2d2d30;
            border-radius: 3px;
            margin-top: 10px;
        }

        .test-results.success {
            border-left: 3px solid #4caf50;
        }

        .test-results.error {
            border-left: 3px solid #f44336;
        }

        .attribute-list {
            list-style: none;
        }

        .attribute-item {
            padding: 5px 10px;
            margin-bottom: 3px;
            background: #2d2d30;
            border-radius: 3px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .attribute-item:hover {
            background: #3e3e42;
        }

        .attribute-type {
            color: #4ec9b0;
            font-size: 11px;
            margin-left: 5px;
        }

        .loading {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-radius: 50%;
            border-top: 2px solid #007acc;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">
</head>
<body>
    <div class="header">
        <h1>🚀 DSL IDE - Language Server Enabled</h1>
        <div class="connection-status">
            <span id="connection-text">LSP: Initializing...</span>
            <div id="status-indicator" class="status-indicator"></div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <h2>Data Dictionary</h2>
            <ul id="attribute-list" class="attribute-list">
                <!-- Attributes will be loaded here -->
            </ul>

            <h2 style="margin-top: 20px;">Functions</h2>
            <ul id="function-list" class="attribute-list">
                <!-- Functions will be loaded here -->
            </ul>
        </div>

        <div class="splitter-vertical" id="splitter-vertical"></div>

        <div class="editor-container" id="editor-container">
            <div class="tabs">
                <div class="tab active" data-file="main.dsl">main.dsl</div>
                <div class="tab" data-file="test.dsl">test.dsl</div>
            </div>

            <div class="toolbar">
                <button class="btn" id="run-btn" onclick="runCode()">
                    ▶ Run Code
                </button>
                <button class="btn secondary" id="validate-btn" onclick="validateCode()">
                    ✓ Validate
                </button>
                <button class="btn secondary" id="format-btn" onclick="formatCode()">
                    ⚡ Format
                </button>
                <button class="btn secondary" id="settings-btn" onclick="showSettings()">
                    ⚙ Settings
                </button>
                <button class="btn secondary" id="ai-explain-btn" onclick="explainCode()">
                    🤖 AI Explain
                </button>
                <button class="btn secondary" id="connect-lsp-btn" onclick="connectToLSP()" style="opacity: 0.7;" title="LSP will auto-connect on page load">
                    🔌 LSP Status
                </button>
            </div>

            <div id="monaco-editor"></div>

            <div class="splitter-horizontal" id="splitter-horizontal"></div>

            <div class="output-panel" id="output-panel">
                <div class="output-header">
                    <div class="output-tabs">
                        <div class="output-tab active" data-panel="output">Output</div>
                        <div class="output-tab" data-panel="problems">Problems</div>
                        <div class="output-tab" data-panel="agent">AI Agent 🤖</div>
                    </div>
                    <button class="btn secondary" style="padding: 3px 10px; font-size: 12px;" onclick="clearOutput()">Clear</button>
                </div>
                <div class="output-content" id="output-content">
                    <!-- Output will appear here -->
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    <script type="module">
        let editor;
        let lspConnection = null;
        let diagnosticsMap = new Map();

        // Initialize Monaco Editor
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });

        require(['vs/editor/editor.main'], function() {
            // Register DSL language
            monaco.languages.register({ id: 'dsl' });

            // Define DSL syntax highlighting
            monaco.languages.setMonarchTokensProvider('dsl', {
                keywords: ['IF', 'THEN', 'ELSE', 'AND', 'OR', 'NOT', 'true', 'false', 'null'],
                operators: ['+', '-', '*', '/', '%', '&', '==', '!=', '<', '>', '<=', '>=', '=', 'MATCHES', '~'],
                functions: ['CONCAT', 'SUBSTRING', 'LOOKUP', 'UPPER', 'LOWER', 'LENGTH', 'ROUND', 'ABS',
                           'MAX', 'MIN', 'IS_EMAIL', 'IS_LEI', 'IS_SWIFT', 'IS_PHONE', 'VALIDATE', 'EXTRACT'],

                tokenizer: {
                    root: [
                        [/[a-zA-Z_]\w*/, {
                            cases: {
                                '@keywords': 'keyword',
                                '@functions': 'support.function',
                                '@default': 'identifier'
                            }
                        }],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, { token: 'string.quote', bracket: '@open', next: '@string' }],
                        [/'([^'\\]|\\.)*$/, 'string.invalid'],
                        [/'/, { token: 'string.quote', bracket: '@open', next: '@stringSingle' }],
                        [/\/[^\/]+\//, 'regexp'],
                        [/r"[^"]+\"/, 'regexp'],
                        [/\d+\.?\d*/, 'number'],
                        [/#.*$/, 'comment'],
                        [/[+\-*/%&]/, 'operators'],
                        [/[=<>!]=?/, 'operators'],
                        [/~/, 'operators'],
                        [/MATCHES/, 'operators'],
                    ],

                    string: [
                        [/[^\\"]+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/"/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],

                    stringSingle: [
                        [/[^\\']+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/'/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],
                }
            });

            // Define DSL theme
            monaco.editor.defineTheme('dsl-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'keyword', foreground: 'c586c0' },
                    { token: 'support.function', foreground: 'dcdcaa' },
                    { token: 'string', foreground: 'ce9178' },
                    { token: 'number', foreground: 'b5cea8' },
                    { token: 'comment', foreground: '6a9955' },
                    { token: 'operators', foreground: 'd4d4d4' },
                    { token: 'regexp', foreground: 'd16969' },
                ],
                colors: {
                    'editor.background': '#1e1e1e',
                }
            });

            // Create editor instance
            editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                value: `# DSL IDE - Test your code here
# This editor has full Language Server Protocol support

# Example: KYC Risk Assessment Rule
risk_score = 0

IF Client.risk_rating == "HIGH" THEN
    risk_score = risk_score + 50
ELSE
    risk_score = risk_score + 10

IF Client.pep_status == true THEN
    risk_score = risk_score + 30

IF Client.aum_usd > 10000000 THEN
    risk_category = "PREMIUM"
ELSE
    risk_category = "STANDARD"

# Validation Rules
email_valid = IS_EMAIL(Client.email)
lei_valid = IS_LEI(Client.lei_code)

# Pattern Matching
swift_pattern = Client.swift_code ~ /^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$/

# Final Result
result = CONCAT("Risk Score: ", risk_score, " Category: ", risk_category)`,
                language: 'dsl',
                theme: 'dsl-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                wordWrap: 'on',
                suggestOnTriggerCharacters: true,
                quickSuggestions: true,
                autoClosingBrackets: 'always',
                autoClosingQuotes: 'always',
                formatOnPaste: true,
            });

            // Load sample attributes
            loadDataDictionary();

            // Register hover provider after editor is ready
            setTimeout(() => {
                console.log('Registering hover provider...');
                registerHoverProvider();
            }, 100);

            // Auto-connect to LSP on startup (give editor time to fully initialize)
            // Disabled for now to prevent jitter - user can manually connect
            // setTimeout(() => {
            //     connectToLSP(true);  // true = auto-connect
            // }, 1000);
        });

        // Connect to Language Server
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        let isConnecting = false;
        const MAX_RECONNECT_ATTEMPTS = 3;

        async function connectToLSP(isAutoConnect = false) {
            const button = document.getElementById('connect-lsp-btn');
            const statusIndicator = document.getElementById('status-indicator');
            const connectionText = document.getElementById('connection-text');

            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // If already connected or currently connecting, do nothing
            if ((lspConnection && lspConnection.readyState === WebSocket.OPEN) || isConnecting) {
                return;
            }

            isConnecting = true;

            try {
                button.disabled = true;
                button.innerHTML = '<span class="loading"></span> Connecting...';

                if (!isAutoConnect) {
                    addToOutput('console', '🔄 Connecting to Language Server...');
                    reconnectAttempts = 0;  // Reset attempts for manual connection
                }

                // Connect to WebSocket LSP server
                lspConnection = new WebSocket('ws://localhost:3030');

                lspConnection.onopen = () => {
                    isConnecting = false;  // Reset connecting flag
                    reconnectAttempts = 0;  // Reset on successful connection
                    statusIndicator.classList.add('connected');
                    connectionText.textContent = 'LSP Online';
                    button.innerHTML = '✅ LSP Online';
                    button.disabled = true;
                    button.style.opacity = '0.7';
                    button.title = 'Language Server is connected';

                    if (!isAutoConnect) {
                        addToOutput('console', '✅ Language Server connected successfully');
                    }

                    // Initialize LSP session
                    initializeLSP();
                };

                lspConnection.onerror = (error) => {
                    isConnecting = false;  // Reset connecting flag
                    console.error('WebSocket error:', error);
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = '⚠️ LSP Offline';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    if (isAutoConnect && reconnectAttempts === 0) {
                        // Only show this message once during auto-connect
                        addToOutput('console', '📝 Language Server not available - IDE running in offline mode');
                    }
                };

                lspConnection.onclose = () => {
                    isConnecting = false;  // Reset connecting flag
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = '🔄 Reconnect LSP';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    // Disable auto-reconnect to prevent jitter
                    // Will fix the connection issue first
                    /*
                    if (isAutoConnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const backoffTime = Math.min(5000 * reconnectAttempts, 15000);  // Max 15 seconds
                        reconnectTimeout = setTimeout(() => {
                            console.log(`Auto-reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}...`);
                            connectToLSP(true);
                        }, backoffTime);
                    }
                    */
                };

                lspConnection.onmessage = (event) => {
                    handleLSPMessage(JSON.parse(event.data));
                };

            } catch (error) {
                isConnecting = false;  // Reset connecting flag
                if (!isAutoConnect) {
                    addToOutput('console', `⚠️ Could not connect to LSP: ${error.message}`);
                }
                button.innerHTML = '🔄 Reconnect LSP';
                button.disabled = false;
                button.style.opacity = '1';
            }
        }

        let messageId = 1;

        function initializeLSP() {
            const initRequest = {
                jsonrpc: "2.0",
                id: messageId++,
                method: "initialize",
                params: {
                    processId: null,
                    capabilities: {
                        textDocument: {
                            synchronization: {
                                dynamicRegistration: false,
                                willSave: false,
                                willSaveWaitUntil: false,
                                didSave: true
                            },
                            completion: {
                                dynamicRegistration: false
                            },
                            hover: {
                                dynamicRegistration: false
                            }
                        }
                    },
                    rootUri: null,
                    workspaceFolders: null
                }
            };

            lspConnection.send(JSON.stringify(initRequest));
        }

        function handleLSPMessage(message) {
            if (message.method === 'textDocument/publishDiagnostics') {
                // Handle diagnostics
                const diagnostics = message.params.diagnostics;
                updateDiagnostics(diagnostics);
            } else if (message.result) {
                // Handle responses
                console.log('LSP Response:', message);
                if (message.id === 1) {
                    // Initialization complete
                    addToOutput('console', '✓ LSP initialized successfully');
                    setupLSPFeatures();
                }
            }
        }

        function setupLSPFeatures() {
            // Send initialized notification
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "initialized",
                params: {}
            }));

            // Open current document in LSP
            const documentUri = "file:///main.dsl";
            const documentText = editor.getValue();
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "textDocument/didOpen",
                params: {
                    textDocument: {
                        uri: documentUri,
                        languageId: "dsl",
                        version: 1,
                        text: documentText
                    }
                }
            }));

            // Set up editor change listener with debouncing
            let changeTimeout = null;
            editor.onDidChangeModelContent((e) => {
                // Debounce the change notifications to avoid flooding the LSP
                if (changeTimeout) {
                    clearTimeout(changeTimeout);
                }
                changeTimeout = setTimeout(() => {
                    if (lspConnection && lspConnection.readyState === WebSocket.OPEN) {
                        lspConnection.send(JSON.stringify({
                            jsonrpc: "2.0",
                            method: "textDocument/didChange",
                            params: {
                                textDocument: {
                                    uri: documentUri,
                                    version: Date.now()
                                },
                                contentChanges: [{
                                    text: editor.getValue()
                                }]
                            }
                        }));
                    }
                }, 300);  // Wait 300ms after user stops typing
            });

            addToOutput('console', '✓ LSP features activated');
        }

        function setupMockLSPFeatures() {
            // Add mock diagnostics
            const diagnostics = [
                { line: 5, severity: 'warning', message: 'Consider using constants for risk values' },
                { line: 18, severity: 'info', message: 'Email validation function available' },
            ];

            updateDiagnostics(diagnostics);

            // Set up code completion
            monaco.languages.registerCompletionItemProvider('dsl', {
                provideCompletionItems: (model, position) => {
                    const suggestions = [
                        {
                            label: 'Client.client_id',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.client_id',
                            detail: 'Unique client identifier',
                        },
                        {
                            label: 'Client.risk_rating',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.risk_rating',
                            detail: 'Risk rating level [LOW, MEDIUM, HIGH]',
                        },
                        {
                            label: 'IS_EMAIL',
                            kind: monaco.languages.CompletionItemKind.Function,
                            insertText: 'IS_EMAIL(${1:email})',
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                            detail: 'Validates email format',
                        },
                    ];

                    return { suggestions };
                }
            });
        }

        function registerHoverProvider() {
            console.log('Actually registering hover provider now...');
            // Set up hover provider with enhanced attribute detection
            const disposable = monaco.languages.registerHoverProvider('dsl', {
                provideHover: (model, position) => {
                    console.log('Hover triggered at', position);
                    const line = model.getLineContent(position.lineNumber);
                    const offset = position.column - 1;

                    // Find the full attribute path (e.g., Client.client_id)
                    let start = offset;
                    let end = offset;

                    // Move start backwards to find beginning of identifier
                    while (start > 0 && /[\w.]/.test(line[start - 1])) {
                        start--;
                    }

                    // Move end forwards to find end of identifier
                    while (end < line.length && /[\w.]/.test(line[end])) {
                        end++;
                    }

                    const fullPath = line.substring(start, end);
                    console.log('Full path extracted:', fullPath);

                    // Enhanced hover information with SQL types
                    const hoverInfo = {
                        'IS_EMAIL': '**Function**: Validates email format\n\n**Pattern**: RFC 5322 standard\n**Returns**: Boolean',
                        'IS_LEI': '**Function**: Validates Legal Entity Identifier\n\n**Pattern**: 20 alphanumeric characters\n**Returns**: Boolean',
                        'IS_SWIFT': '**Function**: Validates SWIFT/BIC code\n\n**Pattern**: 8 or 11 characters\n**Returns**: Boolean',
                        'Client': '**Entity**: KYC Client\n\n**Description**: Client information for KYC validation\n**Attributes**: client_id, legal_entity_name, lei_code, email, risk_rating, aum_usd, kyc_status, pep_status',
                        'Client.client_id': '**Attribute**: client_id\n\n**SQL Type**: `VARCHAR(50) PRIMARY KEY`\n**Rust Type**: `String`\n**Format**: `XXX-999`\n**Pattern**: `^[A-Z]{3}-\\d{3,}$`\n**Required**: ✅ Yes',
                        'Client.legal_entity_name': '**Attribute**: legal_entity_name\n\n**SQL Type**: `VARCHAR(255) NOT NULL`\n**Rust Type**: `String`\n**Required**: ✅ Yes',
                        'Client.lei_code': '**Attribute**: lei_code\n\n**SQL Type**: `CHAR(20)`\n**Rust Type**: `String`\n**Format**: `XXXXXXXXXXXXXXXXXXXX`\n**Pattern**: `^[A-Z0-9]{20}$`\n**Required**: ❌ No',
                        'Client.email': '**Attribute**: email\n\n**SQL Type**: `VARCHAR(255) NOT NULL`\n**Rust Type**: `String`\n**Format**: `xxx@xxx.xxx`\n**Validation**: `IS_EMAIL()`\n**Required**: ✅ Yes',
                        'Client.risk_rating': '**Attribute**: risk_rating\n\n**SQL Type**: `ENUM(\'LOW\', \'MEDIUM\', \'HIGH\') NOT NULL`\n**Rust Type**: `RiskLevel`\n**Domain**: RiskLevel\n**Values**: LOW, MEDIUM, HIGH\n**Required**: ✅ Yes',
                        'Client.aum_usd': '**Attribute**: aum_usd\n\n**SQL Type**: `DECIMAL(18,2)`\n**Rust Type**: `rust_decimal::Decimal`\n**Format**: `$999,999,999,999.99`\n**Min Value**: 0\n**Max Value**: 999999999999999.99\n**Required**: ❌ No',
                        'Client.kyc_status': '**Attribute**: kyc_status\n\n**SQL Type**: `ENUM(\'PENDING\', \'APPROVED\', \'REJECTED\') NOT NULL`\n**Rust Type**: `KycStatus`\n**Values**: PENDING, APPROVED, REJECTED\n**Required**: ✅ Yes',
                        'Client.pep_status': '**Attribute**: pep_status\n\n**SQL Type**: `BOOLEAN NOT NULL DEFAULT FALSE`\n**Rust Type**: `bool`\n**Description**: Politically Exposed Person status\n**Required**: ✅ Yes',
                    };

                    if (fullPath && hoverInfo[fullPath]) {
                        console.log('Found hover info for:', fullPath);
                        return {
                            contents: [
                                {
                                    value: hoverInfo[fullPath],
                                    isTrusted: true,
                                    supportHtml: true
                                }
                            ],
                            range: new monaco.Range(
                                position.lineNumber,
                                start + 1,
                                position.lineNumber,
                                end + 1
                            )
                        };
                    }

                    // Try just the word under cursor if full path didn't match
                    const word = model.getWordAtPosition(position);
                    if (word && hoverInfo[word.word]) {
                        return {
                            contents: [
                                {
                                    value: hoverInfo[word.word],
                                    isTrusted: true,
                                    supportHtml: true
                                }
                            ]
                        };
                    }

                    return null;
                }
            });
            console.log('Hover provider registered:', disposable);
        }

        function updateDiagnostics(diagnostics) {
            const problemsList = document.getElementById('output-content');
            const problemsTab = document.querySelector('[data-panel="problems"]');

            if (diagnostics.length > 0) {
                problemsTab.textContent = `Problems (${diagnostics.length})`;
            } else {
                problemsTab.textContent = 'Problems';
            }

            // Store diagnostics
            diagnosticsMap.clear();
            diagnostics.forEach(d => diagnosticsMap.set(d.line, d));

            // Update Monaco markers
            const markers = diagnostics.map(d => ({
                startLineNumber: d.line,
                startColumn: 1,
                endLineNumber: d.line,
                endColumn: 1000,
                message: d.message,
                severity: d.severity === 'error' ? monaco.MarkerSeverity.Error :
                         d.severity === 'warning' ? monaco.MarkerSeverity.Warning :
                         monaco.MarkerSeverity.Info
            }));

            monaco.editor.setModelMarkers(editor.getModel(), 'dsl', markers);
        }

        async function runCode() {
            const code = editor.getValue();
            const button = document.getElementById('run-btn');

            button.disabled = true;
            button.innerHTML = '<span class="loading"></span> Running...';

            try {
                // Check if running in Tauri environment
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    // Call Tauri backend to test the rule
                    const result = await window.__TAURI__.invoke('test_rule', {
                        dslText: code
                    });

                    addToOutput('output', `✓ Execution successful:\n${JSON.stringify(result, null, 2)}`);
                } else {
                    // Fallback for browser-only mode (simulate execution)
                    addToOutput('output', '⚠️ Running in browser mode (no Tauri backend)');

                    // Simple client-side validation/simulation
                    const lines = code.split('\n').filter(l => l.trim());
                    if (lines.length > 0) {
                        addToOutput('output', `✓ Parsed ${lines.length} lines of DSL code`);

                        // Simulate some basic checks
                        const hasIf = code.includes('IF');
                        const hasThen = code.includes('THEN');

                        if (hasIf && hasThen) {
                            addToOutput('output', '✓ Valid IF-THEN structure detected');
                        } else if (hasIf && !hasThen) {
                            addToOutput('output', '⚠️ Warning: IF without THEN');
                        }

                        // Check for common DSL patterns
                        if (code.includes('Client.')) {
                            addToOutput('output', '✓ Client attributes referenced');
                        }
                        if (code.match(/IS_[A-Z]+/)) {
                            addToOutput('output', '✓ Validation functions used');
                        }
                    } else {
                        addToOutput('output', '⚠️ No code to execute');
                    }
                }

            } catch (error) {
                addToOutput('output', `❌ Execution failed:\n${error}`);
            }

            button.disabled = false;
            button.innerHTML = '▶ Run Code';
        }

        async function validateCode() {
            const code = editor.getValue();
            addToOutput('output', '🔍 Validating code...');

            // Simulate validation
            const lines = code.split('\n');
            const diagnostics = [];

            lines.forEach((line, index) => {
                if (line.includes('IF') && !line.includes('THEN')) {
                    diagnostics.push({
                        line: index + 1,
                        severity: 'error',
                        message: 'IF statement missing THEN clause'
                    });
                }
            });

            updateDiagnostics(diagnostics);

            if (diagnostics.length === 0) {
                addToOutput('output', '✓ Validation successful - no issues found');
            } else {
                addToOutput('output', `⚠ Found ${diagnostics.length} issue(s)`);
            }
        }

        function formatCode() {
            // Simple formatting - preserves line structure
            let code = editor.getValue();

            // Process line by line to preserve structure
            const lines = code.split('\n');
            const formattedLines = lines.map(line => {
                // Skip empty lines
                if (line.trim() === '') {
                    return line;
                }

                // Preserve leading whitespace (indentation)
                const leadingWhitespace = line.match(/^(\s*)/)[1];
                let trimmedLine = line.trim();

                // Skip comments (but preserve indentation)
                if (trimmedLine.startsWith('#')) {
                    return line;
                }

                // Add spacing around operators
                let formatted = trimmedLine;

                // Add space around comparison and assignment operators
                formatted = formatted.replace(/([=<>!]+)/g, ' $1 ');
                formatted = formatted.replace(/([+\-*/%])/g, ' $1 ');

                // Add space around logical operators
                formatted = formatted.replace(/\b(AND|OR)\b/g, ' $1 ');

                // Clean up spaces around parentheses and commas
                formatted = formatted.replace(/\s*\(\s*/g, '(');
                formatted = formatted.replace(/\s*\)\s*/g, ')');
                formatted = formatted.replace(/\s*,\s*/g, ', ');

                // Clean up spaces around dots (for property access)
                formatted = formatted.replace(/\s*\.\s*/g, '.');

                // Fix multiple spaces that may have been created
                formatted = formatted.replace(/\s{2,}/g, ' ');

                // Return with original indentation preserved
                return leadingWhitespace + formatted.trim();
            });

            // Rejoin with line breaks preserved
            const formattedCode = formattedLines.join('\n');

            editor.setValue(formattedCode);
            addToOutput('console', '✓ Code formatted');
        }

        async function explainCode() {
            const code = editor.getValue();
            addToOutput('output', '🤖 AI is analyzing your code...');

            // Simulate AI explanation
            setTimeout(() => {
                const explanation = `This DSL code implements a KYC risk assessment system that:
1. Calculates a risk score based on client attributes
2. Validates email and LEI formats
3. Performs pattern matching on SWIFT codes
4. Categorizes clients as PREMIUM or STANDARD based on AUM
5. Returns a formatted result string with the risk assessment`;

                addToOutput('output', `AI Explanation:\n\n${explanation}`);
            }, 1500);
        }

        function loadDataDictionary() {
            const attributes = [
                { name: 'Client.client_id', type: 'String' },
                { name: 'Client.legal_entity_name', type: 'String' },
                { name: 'Client.risk_rating', type: 'Enum' },
                { name: 'Client.aum_usd', type: 'Number' },
                { name: 'Client.pep_status', type: 'Boolean' },
                { name: 'Client.email', type: 'String' },
                { name: 'Client.lei_code', type: 'String' },
            ];

            const functions = [
                { name: 'IS_EMAIL', type: 'Validation' },
                { name: 'IS_LEI', type: 'Validation' },
                { name: 'IS_SWIFT', type: 'Validation' },
                { name: 'CONCAT', type: 'String' },
                { name: 'LOOKUP', type: 'Data' },
            ];

            const attrList = document.getElementById('attribute-list');
            attributes.forEach(attr => {
                const li = document.createElement('li');
                li.className = 'attribute-item';
                li.innerHTML = `${attr.name} <span class="attribute-type">${attr.type}</span>`;
                li.onclick = () => insertText(attr.name);
                attrList.appendChild(li);
            });

            const funcList = document.getElementById('function-list');
            functions.forEach(func => {
                const li = document.createElement('li');
                li.className = 'attribute-item';
                li.innerHTML = `${func.name}() <span class="attribute-type">${func.type}</span>`;
                li.onclick = () => insertText(`${func.name}()`);
                funcList.appendChild(li);
            });
        }

        function insertText(text) {
            const selection = editor.getSelection();
            const id = { major: 1, minor: 1 };
            const op = { identifier: id, range: selection, text: text, forceMoveMarkers: true };
            editor.executeEdits("insert", [op]);
            editor.focus();
        }

        function addToOutput(panel, message) {
            const outputContent = document.getElementById('output-content');
            const timestamp = new Date().toLocaleTimeString();
            outputContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            outputContent.scrollTop = outputContent.scrollHeight;

            // Switch to the appropriate tab
            document.querySelectorAll('.output-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.panel === panel);
            });
        }

        function clearOutput() {
            document.getElementById('output-content').innerHTML = '';
        }

        // Tab switching
        document.querySelectorAll('.output-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.output-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // In production, this would switch between different output panels
                const panel = tab.dataset.panel;
                if (panel === 'problems') {
                    showProblems();
                } else if (panel === 'agent') {
                    showAgentChat();
                } else {
                    showOutput();
                }
            });
        });

        function showProblems() {
            const outputContent = document.getElementById('output-content');
            outputContent.innerHTML = '<ul class="diagnostics-list">';

            diagnosticsMap.forEach((diag, line) => {
                outputContent.innerHTML += `
                    <li class="diagnostic-item ${diag.severity}" onclick="goToLine(${line})">
                        Line ${line}: ${diag.message}
                    </li>
                `;
            });

            outputContent.innerHTML += '</ul>';
        }

        // AI Agent Chat Implementation
        let chatHistory = [];
        let apiKey = localStorage.getItem('openai_api_key') || '';

        function showAgentChat() {
            const outputContent = document.getElementById('output-content');

            // Create the chat interface
            outputContent.innerHTML = `
                <div class="agent-container">
                    <div class="context-indicator">
                        📝 Context: Current DSL rule in editor
                    </div>
                    <div class="chat-messages" id="chat-messages">
                        <div class="chat-message system">
                            Welcome! I'm your AI assistant for DSL development. I can help you:
                            <br>• Explain DSL rules and syntax
                            <br>• Suggest improvements and optimizations
                            <br>• Debug issues in your rules
                            <br>• Provide examples for specific use cases
                            <br><br>I have context about the current rule you're working on and the KYC data dictionary.
                        </div>
                    </div>
                    <div class="chat-input-container">
                        <input type="text"
                               class="chat-input"
                               id="chat-input"
                               placeholder="Ask about your DSL rule or request help..."
                               onkeypress="handleChatKeyPress(event)">
                        <button class="chat-send-btn"
                                id="chat-send"
                                onclick="sendChatMessage()">
                            Send
                        </button>
                    </div>
                </div>
            `;

            // Load chat history if exists
            if (chatHistory.length > 0) {
                const messagesContainer = document.getElementById('chat-messages');
                messagesContainer.innerHTML = '';
                chatHistory.forEach(msg => {
                    addChatMessage(msg.role, msg.content, false);
                });
            }

            // Focus on input
            document.getElementById('chat-input').focus();
        }

        function addChatMessage(role, content, save = true) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;

            // Parse code blocks in assistant messages
            if (role === 'assistant') {
                content = content.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
                    return `<div class="message-code">${escapeHtml(code.trim())}</div>`;
                });
                messageDiv.innerHTML = content.replace(/\n/g, '<br>');
            } else {
                messageDiv.textContent = content;
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Save to history
            if (save) {
                chatHistory.push({ role, content });
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const sendButton = document.getElementById('chat-send');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addChatMessage('user', message);
            input.value = '';
            sendButton.disabled = true;

            // Get current context
            const currentRule = editor.getValue();
            const selectedText = editor.getModel().getValueInRange(editor.getSelection());

            // Build context with RAG from data dictionary
            const context = buildAgentContext(currentRule, selectedText);

            try {
                // For now, use a mock response. In production, this would call OpenAI/Anthropic
                const response = await callAIAgent(message, context);
                addChatMessage('assistant', response);
            } catch (error) {
                addChatMessage('system', `Error: ${error.message}`);
            }

            sendButton.disabled = false;
            input.focus();
        }

        function buildAgentContext(currentRule, selectedText) {
            // Build comprehensive context for the AI
            const context = {
                currentRule: currentRule,
                selectedText: selectedText,
                dataDict: {
                    entities: ['Client'],
                    attributes: [
                        'Client.client_id - VARCHAR(50) PRIMARY KEY - Format: XXX-999',
                        'Client.legal_entity_name - VARCHAR(255) NOT NULL',
                        'Client.lei_code - CHAR(20) - Legal Entity Identifier',
                        'Client.email - VARCHAR(255) NOT NULL - Validated with IS_EMAIL',
                        'Client.risk_rating - ENUM(LOW,MEDIUM,HIGH)',
                        'Client.aum_usd - DECIMAL(18,2) - Format: $999,999,999,999.99',
                        'Client.kyc_status - ENUM(PENDING,APPROVED,REJECTED)',
                        'Client.pep_status - BOOLEAN NOT NULL'
                    ],
                    functions: [
                        'IS_EMAIL(email) - Validates email format',
                        'IS_LEI(lei) - Validates Legal Entity Identifier',
                        'IS_SWIFT(code) - Validates SWIFT/BIC code',
                        'CONCAT(...) - Concatenate values',
                        'SUBSTRING(str, start, end) - Extract substring',
                        'LOOKUP(key, table) - Look up value from table'
                    ],
                    operators: [
                        'Arithmetic: +, -, *, /, %',
                        'Comparison: ==, !=, <, >, <=, >=',
                        'Logical: AND, OR, NOT',
                        'String concat: &',
                        'Regex match: ~'
                    ]
                },
                language: 'DSL for KYC validation and data transformation'
            };

            return context;
        }

        async function callAIAgent(message, context) {
            // Check if API key is configured
            const apiKey = localStorage.getItem('ai_api_key');
            const apiProvider = localStorage.getItem('ai_provider') || 'openai';

            if (!apiKey) {
                // If no API key, use intelligent mock responses
                return getMockResponse(message, context);
            }

            try {
                // Prepare the system prompt with context
                const systemPrompt = `You are an AI assistant specializing in DSL (Domain Specific Language) development for KYC (Know Your Customer) data transformation rules.

Current context:
- User is working on: ${context.currentRule ? context.currentRule.substring(0, 500) + '...' : 'No rule loaded'}
- Available attributes: ${Object.keys(context.attributes).join(', ')}
- Available functions: ${context.functions.join(', ')}
- Available operators: ${context.operators.join(', ')}

Help the user with DSL syntax, debugging, optimization, and best practices. Be concise and code-focused.`;

                if (apiProvider === 'openai') {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: localStorage.getItem('ai_model') || 'gpt-4-turbo-preview',
                            messages: [
                                { role: 'system', content: systemPrompt },
                                { role: 'user', content: message }
                            ],
                            temperature: 0.7,
                            max_tokens: 1000
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.choices[0].message.content;

                } else if (apiProvider === 'anthropic') {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({
                            model: localStorage.getItem('ai_model') || 'claude-3-opus-20240229',
                            max_tokens: 1000,
                            system: systemPrompt,
                            messages: [
                                { role: 'user', content: message }
                            ]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Anthropic API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.content[0].text;
                }

            } catch (error) {
                console.error('AI API call failed:', error);
                // Fall back to mock responses if API fails
                return getMockResponse(message, context) +
                       `\n\n<small>⚠️ API call failed: ${error.message}. Using offline responses.</small>`;
            }
        }

        function getMockResponse(message, context) {
            // Intelligent mock responses for offline mode
            const lowerMessage = message.toLowerCase();

            if (lowerMessage.includes('explain')) {
                return `I can see you're working with a DSL rule. Let me explain what's happening:

Your current rule appears to be checking conditions and setting values based on Client attributes.

The DSL uses:
- **IF/THEN/ELSE** statements for conditional logic
- **Client.attribute** notation to access data fields
- **Operators** like ==, >, < for comparisons
- **Functions** like IS_EMAIL() for validation

Would you like me to explain a specific part of your rule?`;
            }

            if (lowerMessage.includes('fix') || lowerMessage.includes('error')) {
                return `Looking at your rule, here are some common issues to check:

1. **Syntax**: Ensure all IF statements have matching THEN/ELSE/END
2. **Attributes**: Verify attribute names like Client.client_id are spelled correctly
3. **Types**: Check that operations match data types (e.g., numbers for arithmetic)
4. **Quotes**: String values need quotes, numbers don't

<div class="message-code">IF Client.risk_rating == "HIGH" THEN
    enhanced_review = true
END</div>

Need help with a specific error?`;
            }

            if (lowerMessage.includes('example') || lowerMessage.includes('how')) {
                return `Here's an example of a comprehensive KYC risk assessment rule:

<div class="message-code">risk_score = 0

# Check risk rating
IF Client.risk_rating == "HIGH" THEN
    risk_score = risk_score + 50
ELSE IF Client.risk_rating == "MEDIUM" THEN
    risk_score = risk_score + 25
ELSE
    risk_score = risk_score + 10
END

# Check PEP status
IF Client.pep_status == true THEN
    risk_score = risk_score + 30
END

# Check AUM threshold
IF Client.aum_usd > 10000000 THEN
    risk_score = risk_score + 20
END

# Validate email
IF NOT IS_EMAIL(Client.email) THEN
    validation_status = "FAILED"
ELSE
    validation_status = "PASSED"
END

# Set final status
result = CONCAT("Risk Score: ", risk_score, " - Validation: ", validation_status)</div>

This rule combines multiple checks and calculations. Would you like me to explain any part?`;
            }

            if (lowerMessage.includes('optimize') || lowerMessage.includes('improve')) {
                return `Looking at your rule, here are some optimization suggestions:

1. **Combine related conditions** to reduce redundancy
2. **Use constants** for magic numbers
3. **Add validation** before processing
4. **Consider edge cases** like null values

For example, instead of multiple IF statements, you could use:
<div class="message-code">risk_level =
    IF Client.risk_rating == "HIGH" AND Client.pep_status == true THEN "CRITICAL"
    ELSE IF Client.risk_rating == "HIGH" THEN "HIGH"
    ELSE IF Client.risk_rating == "MEDIUM" THEN "MEDIUM"
    ELSE "LOW"</div>

Want me to suggest specific improvements for your rule?`;
            }

            // Default response
            return `I understand you're asking about: "${message}"

Based on your current DSL rule, I can help with:
- Syntax and structure guidance
- Attribute type information and constraints
- Function usage and examples
- Best practices for KYC validation

Could you be more specific about what you'd like help with?

<small>💡 Tip: Configure an API key in settings for AI-powered responses.</small>`;
        }

        window.handleChatKeyPress = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        window.sendChatMessage = sendChatMessage;

        function showOutput() {
            // Output already shows in main output
        }

        window.goToLine = function(line) {
            editor.revealLineInCenter(line);
            editor.setPosition({ lineNumber: line, column: 1 });
            editor.focus();
        };

        // Make functions available globally
        window.runCode = runCode;
        window.validateCode = validateCode;
        window.formatCode = formatCode;
        window.explainCode = explainCode;
        window.connectToLSP = connectToLSP;
        window.clearOutput = clearOutput;
        // Settings Modal Functions
        function showSettings() {
            const existingModal = document.getElementById('settings-modal');
            if (existingModal) {
                existingModal.style.display = 'block';
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'settings-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>AI Assistant Settings</h2>
                        <span class="close" onclick="closeSettings()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="setting-group">
                            <label>AI Provider:</label>
                            <select id="ai-provider" onchange="updateProviderSettings()">
                                <option value="openai">OpenAI (GPT-4)</option>
                                <option value="anthropic">Anthropic (Claude)</option>
                            </select>
                        </div>

                        <div class="setting-group">
                            <label id="api-key-label">OpenAI API Key:</label>
                            <input type="password"
                                   id="api-key-input"
                                   placeholder="sk-..."
                                   value="${localStorage.getItem('ai_api_key') || ''}">
                            <small>Your API key is stored locally and never sent to any server except the AI provider.</small>
                        </div>

                        <div class="setting-group">
                            <label>Model:</label>
                            <select id="ai-model">
                                <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                            </select>
                        </div>

                        <div class="setting-actions">
                            <button class="btn" onclick="saveSettings()">Save Settings</button>
                            <button class="btn secondary" onclick="testAPIKey()">Test Connection</button>
                        </div>

                        <div id="settings-status"></div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Load saved settings
            const savedProvider = localStorage.getItem('ai_provider') || 'openai';
            document.getElementById('ai-provider').value = savedProvider;
            updateProviderSettings();
        }

        function closeSettings() {
            const modal = document.getElementById('settings-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function updateProviderSettings() {
            const provider = document.getElementById('ai-provider').value;
            const label = document.getElementById('api-key-label');
            const input = document.getElementById('api-key-input');
            const modelSelect = document.getElementById('ai-model');

            if (provider === 'anthropic') {
                label.textContent = 'Anthropic API Key:';
                input.placeholder = 'sk-ant-...';
                modelSelect.innerHTML = `
                    <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                    <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
                    <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                `;
            } else {
                label.textContent = 'OpenAI API Key:';
                input.placeholder = 'sk-...';
                modelSelect.innerHTML = `
                    <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                `;
            }
        }

        function saveSettings() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const provider = document.getElementById('ai-provider').value;
            const model = document.getElementById('ai-model').value;

            if (apiKey) {
                localStorage.setItem('ai_api_key', apiKey);
                localStorage.setItem('ai_provider', provider);
                localStorage.setItem('ai_model', model);
                showSettingsStatus('Settings saved successfully!', 'success');
            } else {
                showSettingsStatus('Please enter an API key', 'error');
            }
        }

        async function testAPIKey() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const provider = document.getElementById('ai-provider').value;

            if (!apiKey) {
                showSettingsStatus('Please enter an API key first', 'error');
                return;
            }

            showSettingsStatus('Testing connection...', 'info');

            try {
                // Test the API key with a simple request
                const context = getAgentContext();
                const response = await callAIAgent('Hello, can you confirm you are working?', context);

                if (response && !response.includes('API call failed')) {
                    showSettingsStatus('✓ Connection successful! AI assistant is ready.', 'success');
                } else {
                    showSettingsStatus('Connection failed. Please check your API key.', 'error');
                }
            } catch (error) {
                showSettingsStatus(`Connection failed: ${error.message}`, 'error');
            }
        }

        function showSettingsStatus(message, type) {
            const statusDiv = document.getElementById('settings-status');
            statusDiv.className = `status-message ${type}`;
            statusDiv.textContent = message;
        }

        // Make functions available globally
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.updateProviderSettings = updateProviderSettings;
        window.saveSettings = saveSettings;
        window.testAPIKey = testAPIKey;

        // Resizable Panes Implementation
        function initializeResizablePanes() {
            const sidebar = document.getElementById('sidebar');
            const editorContainer = document.getElementById('editor-container');
            const outputPanel = document.getElementById('output-panel');
            const verticalSplitter = document.getElementById('splitter-vertical');
            const horizontalSplitter = document.getElementById('splitter-horizontal');
            const mainContainer = document.querySelector('.main-container');

            let isResizingVertical = false;
            let isResizingHorizontal = false;

            // Vertical splitter (between sidebar and editor)
            verticalSplitter.addEventListener('mousedown', (e) => {
                isResizingVertical = true;
                verticalSplitter.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            // Horizontal splitter (between editor and output)
            horizontalSplitter.addEventListener('mousedown', (e) => {
                isResizingHorizontal = true;
                horizontalSplitter.classList.add('dragging');
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isResizingVertical) {
                    const containerRect = mainContainer.getBoundingClientRect();
                    const newWidth = e.clientX - containerRect.left;

                    // Enforce min/max constraints
                    if (newWidth >= 150 && newWidth <= 500) {
                        sidebar.style.width = newWidth + 'px';
                        // Save preference
                        localStorage.setItem('sidebar-width', newWidth);
                    }
                }

                if (isResizingHorizontal) {
                    const containerRect = editorContainer.getBoundingClientRect();
                    const editorElement = document.getElementById('monaco-editor');
                    const newHeight = containerRect.bottom - e.clientY;

                    // Enforce min/max constraints for output panel
                    if (newHeight >= 100 && newHeight <= 500) {
                        outputPanel.style.height = newHeight + 'px';
                        // Adjust editor height
                        const availableHeight = containerRect.height - newHeight - 5; // 5px for splitter
                        editorElement.style.height = availableHeight + 'px';

                        // Trigger Monaco resize
                        if (window.editor) {
                            window.editor.layout();
                        }

                        // Save preference
                        localStorage.setItem('output-height', newHeight);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizingVertical) {
                    isResizingVertical = false;
                    verticalSplitter.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }

                if (isResizingHorizontal) {
                    isResizingHorizontal = false;
                    horizontalSplitter.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });

            // Restore saved dimensions
            const savedSidebarWidth = localStorage.getItem('sidebar-width');
            if (savedSidebarWidth) {
                sidebar.style.width = savedSidebarWidth + 'px';
            }

            const savedOutputHeight = localStorage.getItem('output-height');
            if (savedOutputHeight) {
                outputPanel.style.height = savedOutputHeight + 'px';
                const containerRect = editorContainer.getBoundingClientRect();
                const editorElement = document.getElementById('monaco-editor');
                const availableHeight = containerRect.height - parseInt(savedOutputHeight) - 5;
                editorElement.style.height = availableHeight + 'px';
            }

            // Handle window resize
            window.addEventListener('resize', () => {
                if (window.editor) {
                    window.editor.layout();
                }
            });
        }

        // Initialize resizable panes after DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeResizablePanes);
        } else {
            // DOM already loaded
            setTimeout(initializeResizablePanes, 100);
        }
    </script>

    <style>
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #2d2d30;
            margin: 10% auto;
            padding: 0;
            border: 1px solid #444;
            border-radius: 8px;
            width: 500px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #e8e8e8;
        }

        .close {
            color: #999;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
        }

        .close:hover {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            color: #cccccc;
            font-weight: 500;
        }

        .setting-group input[type="password"],
        .setting-group select {
            width: 100%;
            padding: 8px 12px;
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e8e8e8;
            font-size: 14px;
        }

        .setting-group small {
            display: block;
            margin-top: 5px;
            color: #999;
            font-size: 12px;
        }

        .setting-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status-message.success {
            background: #1b5e20;
            color: #a5d6a7;
            border: 1px solid #2e7d32;
        }

        .status-message.error {
            background: #b71c1c;
            color: #ef9a9a;
            border: 1px solid #c62828;
        }

        .status-message.info {
            background: #0d47a1;
            color: #90caf9;
            border: 1px solid #1565c0;
        }
    </style>
</body>
</html>