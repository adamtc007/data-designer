<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DSL IDE with Language Server</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Monaco', 'Consolas', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 400;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #f44336;
        }

        .status-indicator.connected {
            background: #4caf50;
        }

        .main-container {
            flex: 1;
            display: flex;
            height: calc(100vh - 60px);
            position: relative;
        }

        .sidebar {
            width: 250px;
            min-width: 150px;
            max-width: 500px;
            background: #252526;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }

        .splitter-vertical {
            width: 5px;
            background: #3e3e42;
            cursor: col-resize;
            position: relative;
            user-select: none;
        }

        .splitter-vertical:hover {
            background: #007acc;
        }

        .splitter-vertical.dragging {
            background: #007acc;
        }

        .splitter-horizontal {
            height: 5px;
            background: #3e3e42;
            cursor: row-resize;
            user-select: none;
        }

        .splitter-horizontal:hover {
            background: #007acc;
        }

        .splitter-horizontal.dragging {
            background: #007acc;
        }

        .sidebar h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            color: #969696;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 400px;
            overflow: hidden;
        }

        #monaco-editor {
            flex: 1;
            min-height: 200px;
        }

        .tabs {
            background: #2d2d30;
            display: flex;
            border-bottom: 1px solid #3e3e42;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            background: #2d2d30;
            color: #969696;
            transition: all 0.2s;
        }

        .tab:hover {
            background: #3e3e42;
        }

        .tab.active {
            background: #1e1e1e;
            color: #d4d4d4;
            border-bottom: 2px solid #007acc;
        }

        #monaco-editor {
            flex: 1;
            width: 100%;
        }

        .output-panel {
            height: 200px;
            min-height: 100px;
            background: #1e1e1e;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .output-header {
            background: #2d2d30;
            padding: 8px 15px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .output-tabs {
            display: flex;
            gap: 15px;
        }

        .output-tab {
            cursor: pointer;
            color: #969696;
            font-size: 14px;
            padding: 2px 5px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .output-tab:hover {
            color: #d4d4d4;
        }

        .output-tab.active {
            color: #d4d4d4;
            border-bottom-color: #007acc;
        }

        .output-content {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
        }

        .diagnostics-list {
            list-style: none;
        }

        .diagnostic-item {
            padding: 5px;
            margin-bottom: 5px;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .diagnostic-item:hover {
            background: #2d2d30;
        }

        .diagnostic-item.error {
            border-left-color: #f44336;
            color: #f48771;
        }

        .diagnostic-item.warning {
            border-left-color: #ffeb3b;
            color: #dcdcaa;
        }

        .diagnostic-item.info {
            border-left-color: #2196f3;
            color: #9cdcfe;
        }

        /* AI Agent Chat Styles */
        .agent-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #1e1e1e;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 200px;
        }

        .chat-message {
            padding: 10px 12px;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .chat-message.user {
            align-self: flex-end;
            background: #007acc;
            color: white;
        }

        .chat-message.assistant {
            align-self: flex-start;
            background: #2d2d30;
            color: #cccccc;
            border: 1px solid #3e3e42;
        }

        .chat-message.system {
            align-self: center;
            background: #3e3e42;
            color: #969696;
            font-size: 0.9em;
            max-width: 90%;
        }

        .chat-input-container {
            padding: 12px;
            border-top: 1px solid #3e3e42;
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            color: #cccccc;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        .chat-input:focus {
            outline: none;
            border-color: #007acc;
        }

        .chat-send-btn {
            padding: 8px 16px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-send-btn:hover:not(:disabled) {
            background: #1a86d9;
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .context-indicator {
            padding: 4px 8px;
            background: #3e3e42;
            color: #969696;
            font-size: 11px;
            border-radius: 3px;
            margin-bottom: 8px;
        }

        .message-code {
            background: #1e1e1e;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .btn {
            padding: 5px 15px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #5a5a5a;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #3c3c3c;
        }

        .btn.secondary:hover {
            background: #505050;
        }

        .test-results {
            padding: 10px;
            background: #2d2d30;
            border-radius: 3px;
            margin-top: 10px;
        }

        .test-results.success {
            border-left: 3px solid #4caf50;
        }

        .test-results.error {
            border-left: 3px solid #f44336;
        }

        .attribute-list {
            list-style: none;
        }

        .attribute-item {
            padding: 5px 10px;
            margin-bottom: 3px;
            background: #2d2d30;
            border-radius: 3px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .attribute-item:hover {
            background: #3e3e42;
        }

        .attribute-type {
            color: #4ec9b0;
            font-size: 11px;
            margin-left: 5px;
        }

        .loading {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-radius: 50%;
            border-top: 2px solid #007acc;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">
</head>
<body>
    <div class="header">
        <h1>üöÄ DSL IDE - Language Server Enabled</h1>
        <div class="connection-status">
            <span id="connection-text">LSP: Initializing...</span>
            <div id="status-indicator" class="status-indicator"></div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <h2>Data Dictionary</h2>
            <ul id="attribute-list" class="attribute-list">
                <!-- Attributes will be loaded here -->
            </ul>

            <h2 style="margin-top: 20px;">Functions</h2>
            <ul id="function-list" class="attribute-list">
                <!-- Functions will be loaded here -->
            </ul>
        </div>

        <div class="splitter-vertical" id="splitter-vertical"></div>

        <div class="editor-container" id="editor-container">
            <div class="tabs">
                <div class="tab active" data-file="main.dsl">main.dsl</div>
                <div class="tab" data-file="test.dsl">test.dsl</div>
            </div>

            <div class="toolbar">
                <button class="btn" id="run-btn" onclick="runCode()">
                    ‚ñ∂ Run Code
                </button>
                <button class="btn secondary" id="validate-btn" onclick="validateCode()">
                    ‚úì Validate
                </button>
                <button class="btn secondary" id="format-btn" onclick="formatCode()">
                    ‚ö° Format
                </button>
                <button class="btn secondary" id="settings-btn" onclick="showSettings()">
                    ‚öô Settings
                </button>
                <button class="btn secondary" id="ai-explain-btn" onclick="explainCode()">
                    ü§ñ AI Explain
                </button>
                <button class="btn secondary" id="connect-lsp-btn" onclick="connectToLSP()" style="opacity: 0.7;" title="LSP will auto-connect on page load">
                    üîå LSP Status
                </button>
            </div>

            <div id="monaco-editor"></div>

            <div class="splitter-horizontal" id="splitter-horizontal"></div>

            <div class="output-panel" id="output-panel">
                <div class="output-header">
                    <div class="output-tabs">
                        <div class="output-tab active" data-panel="output">Output</div>
                        <div class="output-tab" data-panel="problems">Problems</div>
                        <div class="output-tab" data-panel="agent">AI Agent ü§ñ</div>
                        <div class="output-tab" data-panel="rules">Rules Catalogue üìã</div>
                    </div>
                    <button class="btn secondary" style="padding: 3px 10px; font-size: 12px;" onclick="clearOutput()">Clear</button>
                </div>
                <div class="output-content" id="output-content">
                    <!-- Output will appear here -->
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    <script type="module">
        let editor;
        let lspConnection = null;
        let diagnosticsMap = new Map();

        // Initialize Monaco Editor
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });

        require(['vs/editor/editor.main'], function() {
            // Register DSL language
            monaco.languages.register({ id: 'dsl' });

            // Define DSL syntax highlighting
            monaco.languages.setMonarchTokensProvider('dsl', {
                keywords: ['IF', 'THEN', 'ELSE', 'AND', 'OR', 'NOT', 'true', 'false', 'null'],
                operators: ['+', '-', '*', '/', '%', '&', '==', '!=', '<', '>', '<=', '>=', '=', 'MATCHES', '~'],
                functions: ['CONCAT', 'SUBSTRING', 'LOOKUP', 'UPPER', 'LOWER', 'LENGTH', 'ROUND', 'ABS',
                           'MAX', 'MIN', 'IS_EMAIL', 'IS_LEI', 'IS_SWIFT', 'IS_PHONE', 'VALIDATE', 'EXTRACT'],

                tokenizer: {
                    root: [
                        [/[a-zA-Z_]\w*/, {
                            cases: {
                                '@keywords': 'keyword',
                                '@functions': 'support.function',
                                '@default': 'identifier'
                            }
                        }],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, { token: 'string.quote', bracket: '@open', next: '@string' }],
                        [/'([^'\\]|\\.)*$/, 'string.invalid'],
                        [/'/, { token: 'string.quote', bracket: '@open', next: '@stringSingle' }],
                        [/\/[^\/]+\//, 'regexp'],
                        [/r"[^"]+\"/, 'regexp'],
                        [/\d+\.?\d*/, 'number'],
                        [/#.*$/, 'comment'],
                        [/[+\-*/%&]/, 'operators'],
                        [/[=<>!]=?/, 'operators'],
                        [/~/, 'operators'],
                        [/MATCHES/, 'operators'],
                    ],

                    string: [
                        [/[^\\"]+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/"/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],

                    stringSingle: [
                        [/[^\\']+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/'/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],
                }
            });

            // Define DSL theme
            monaco.editor.defineTheme('dsl-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'keyword', foreground: 'c586c0' },
                    { token: 'support.function', foreground: 'dcdcaa' },
                    { token: 'string', foreground: 'ce9178' },
                    { token: 'number', foreground: 'b5cea8' },
                    { token: 'comment', foreground: '6a9955' },
                    { token: 'operators', foreground: 'd4d4d4' },
                    { token: 'regexp', foreground: 'd16969' },
                ],
                colors: {
                    'editor.background': '#1e1e1e',
                }
            });

            // Create editor instance
            editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                value: `# DSL IDE - Test your code here
# This editor has full Language Server Protocol support

# Example: KYC Risk Assessment Rule
risk_score = 0

IF Client.risk_rating == "HIGH" THEN
    risk_score = risk_score + 50
ELSE
    risk_score = risk_score + 10

IF Client.pep_status == true THEN
    risk_score = risk_score + 30

IF Client.aum_usd > 10000000 THEN
    risk_category = "PREMIUM"
ELSE
    risk_category = "STANDARD"

# Validation Rules
email_valid = IS_EMAIL(Client.email)
lei_valid = IS_LEI(Client.lei_code)

# Pattern Matching
swift_pattern = Client.swift_code ~ /^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$/

# Final Result
result = CONCAT("Risk Score: ", risk_score, " Category: ", risk_category)`,
                language: 'dsl',
                theme: 'dsl-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                wordWrap: 'on',
                suggestOnTriggerCharacters: true,
                quickSuggestions: true,
                autoClosingBrackets: 'always',
                autoClosingQuotes: 'always',
                formatOnPaste: true,
            });

            // Load sample attributes
            loadDataDictionary();

            // Register hover provider after editor is ready
            setTimeout(() => {
                console.log('Registering hover provider...');
                registerHoverProvider();
            }, 100);

            // Auto-connect to LSP on startup (give editor time to fully initialize)
            // Disabled for now to prevent jitter - user can manually connect
            // setTimeout(() => {
            //     connectToLSP(true);  // true = auto-connect
            // }, 1000);
        });

        // Connect to Language Server
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        let isConnecting = false;
        const MAX_RECONNECT_ATTEMPTS = 3;

        async function connectToLSP(isAutoConnect = false) {
            const button = document.getElementById('connect-lsp-btn');
            const statusIndicator = document.getElementById('status-indicator');
            const connectionText = document.getElementById('connection-text');

            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // If already connected or currently connecting, do nothing
            if ((lspConnection && lspConnection.readyState === WebSocket.OPEN) || isConnecting) {
                return;
            }

            isConnecting = true;

            try {
                button.disabled = true;
                button.innerHTML = '<span class="loading"></span> Connecting...';

                if (!isAutoConnect) {
                    addToOutput('console', 'üîÑ Connecting to Language Server...');
                    reconnectAttempts = 0;  // Reset attempts for manual connection
                }

                // Connect to WebSocket LSP server
                lspConnection = new WebSocket('ws://localhost:3030');

                lspConnection.onopen = () => {
                    isConnecting = false;  // Reset connecting flag
                    reconnectAttempts = 0;  // Reset on successful connection
                    statusIndicator.classList.add('connected');
                    connectionText.textContent = 'LSP Online';
                    button.innerHTML = '‚úÖ LSP Online';
                    button.disabled = true;
                    button.style.opacity = '0.7';
                    button.title = 'Language Server is connected';

                    if (!isAutoConnect) {
                        addToOutput('console', '‚úÖ Language Server connected successfully');
                    }

                    // Initialize LSP session
                    initializeLSP();
                };

                lspConnection.onerror = (error) => {
                    isConnecting = false;  // Reset connecting flag
                    console.error('WebSocket error:', error);
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = '‚ö†Ô∏è LSP Offline';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    if (isAutoConnect && reconnectAttempts === 0) {
                        // Only show this message once during auto-connect
                        addToOutput('console', 'üìù Language Server not available - IDE running in offline mode');
                    }
                };

                lspConnection.onclose = () => {
                    isConnecting = false;  // Reset connecting flag
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = 'üîÑ Reconnect LSP';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    // Disable auto-reconnect to prevent jitter
                    // Will fix the connection issue first
                    /*
                    if (isAutoConnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const backoffTime = Math.min(5000 * reconnectAttempts, 15000);  // Max 15 seconds
                        reconnectTimeout = setTimeout(() => {
                            console.log(`Auto-reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}...`);
                            connectToLSP(true);
                        }, backoffTime);
                    }
                    */
                };

                lspConnection.onmessage = (event) => {
                    handleLSPMessage(JSON.parse(event.data));
                };

            } catch (error) {
                isConnecting = false;  // Reset connecting flag
                if (!isAutoConnect) {
                    addToOutput('console', `‚ö†Ô∏è Could not connect to LSP: ${error.message}`);
                }
                button.innerHTML = 'üîÑ Reconnect LSP';
                button.disabled = false;
                button.style.opacity = '1';
            }
        }

        let messageId = 1;

        function initializeLSP() {
            const initRequest = {
                jsonrpc: "2.0",
                id: messageId++,
                method: "initialize",
                params: {
                    processId: null,
                    capabilities: {
                        textDocument: {
                            synchronization: {
                                dynamicRegistration: false,
                                willSave: false,
                                willSaveWaitUntil: false,
                                didSave: true
                            },
                            completion: {
                                dynamicRegistration: false
                            },
                            hover: {
                                dynamicRegistration: false
                            }
                        }
                    },
                    rootUri: null,
                    workspaceFolders: null
                }
            };

            lspConnection.send(JSON.stringify(initRequest));
        }

        function handleLSPMessage(message) {
            if (message.method === 'textDocument/publishDiagnostics') {
                // Handle diagnostics
                const diagnostics = message.params.diagnostics;
                updateDiagnostics(diagnostics);
            } else if (message.result) {
                // Handle responses
                console.log('LSP Response:', message);
                if (message.id === 1) {
                    // Initialization complete
                    addToOutput('console', '‚úì LSP initialized successfully');
                    setupLSPFeatures();
                }
            }
        }

        function setupLSPFeatures() {
            // Send initialized notification
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "initialized",
                params: {}
            }));

            // Open current document in LSP
            const documentUri = "file:///main.dsl";
            const documentText = editor.getValue();
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "textDocument/didOpen",
                params: {
                    textDocument: {
                        uri: documentUri,
                        languageId: "dsl",
                        version: 1,
                        text: documentText
                    }
                }
            }));

            // Set up editor change listener with debouncing
            let changeTimeout = null;
            editor.onDidChangeModelContent((e) => {
                // Debounce the change notifications to avoid flooding the LSP
                if (changeTimeout) {
                    clearTimeout(changeTimeout);
                }
                changeTimeout = setTimeout(() => {
                    if (lspConnection && lspConnection.readyState === WebSocket.OPEN) {
                        lspConnection.send(JSON.stringify({
                            jsonrpc: "2.0",
                            method: "textDocument/didChange",
                            params: {
                                textDocument: {
                                    uri: documentUri,
                                    version: Date.now()
                                },
                                contentChanges: [{
                                    text: editor.getValue()
                                }]
                            }
                        }));
                    }
                }, 300);  // Wait 300ms after user stops typing
            });

            addToOutput('console', '‚úì LSP features activated');
        }

        function setupMockLSPFeatures() {
            // Add mock diagnostics
            const diagnostics = [
                { line: 5, severity: 'warning', message: 'Consider using constants for risk values' },
                { line: 18, severity: 'info', message: 'Email validation function available' },
            ];

            updateDiagnostics(diagnostics);

            // Set up code completion
            monaco.languages.registerCompletionItemProvider('dsl', {
                provideCompletionItems: (model, position) => {
                    const suggestions = [
                        {
                            label: 'Client.client_id',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.client_id',
                            detail: 'Unique client identifier',
                        },
                        {
                            label: 'Client.risk_rating',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.risk_rating',
                            detail: 'Risk rating level [LOW, MEDIUM, HIGH]',
                        },
                        {
                            label: 'IS_EMAIL',
                            kind: monaco.languages.CompletionItemKind.Function,
                            insertText: 'IS_EMAIL(${1:email})',
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                            detail: 'Validates email format',
                        },
                    ];

                    return { suggestions };
                }
            });
        }

        function registerHoverProvider() {
            console.log('Actually registering hover provider now...');
            // Set up hover provider with enhanced attribute detection
            const disposable = monaco.languages.registerHoverProvider('dsl', {
                provideHover: (model, position) => {
                    console.log('Hover triggered at', position);
                    const line = model.getLineContent(position.lineNumber);
                    const offset = position.column - 1;

                    // Find the full attribute path (e.g., Client.client_id)
                    let start = offset;
                    let end = offset;

                    // Move start backwards to find beginning of identifier
                    while (start > 0 && /[\w.]/.test(line[start - 1])) {
                        start--;
                    }

                    // Move end forwards to find end of identifier
                    while (end < line.length && /[\w.]/.test(line[end])) {
                        end++;
                    }

                    const fullPath = line.substring(start, end);
                    console.log('Full path extracted:', fullPath);

                    // Enhanced hover information with SQL types
                    const hoverInfo = {
                        'IS_EMAIL': '**Function**: Validates email format\n\n**Pattern**: RFC 5322 standard\n**Returns**: Boolean',
                        'IS_LEI': '**Function**: Validates Legal Entity Identifier\n\n**Pattern**: 20 alphanumeric characters\n**Returns**: Boolean',
                        'IS_SWIFT': '**Function**: Validates SWIFT/BIC code\n\n**Pattern**: 8 or 11 characters\n**Returns**: Boolean',
                        'Client': '**Entity**: KYC Client\n\n**Description**: Client information for KYC validation\n**Attributes**: client_id, legal_entity_name, lei_code, email, risk_rating, aum_usd, kyc_status, pep_status',
                        'Client.client_id': '**Attribute**: client_id\n\n**SQL Type**: `VARCHAR(50) PRIMARY KEY`\n**Rust Type**: `String`\n**Format**: `XXX-999`\n**Pattern**: `^[A-Z]{3}-\\d{3,}$`\n**Required**: ‚úÖ Yes',
                        'Client.legal_entity_name': '**Attribute**: legal_entity_name\n\n**SQL Type**: `VARCHAR(255) NOT NULL`\n**Rust Type**: `String`\n**Required**: ‚úÖ Yes',
                        'Client.lei_code': '**Attribute**: lei_code\n\n**SQL Type**: `CHAR(20)`\n**Rust Type**: `String`\n**Format**: `XXXXXXXXXXXXXXXXXXXX`\n**Pattern**: `^[A-Z0-9]{20}$`\n**Required**: ‚ùå No',
                        'Client.email': '**Attribute**: email\n\n**SQL Type**: `VARCHAR(255) NOT NULL`\n**Rust Type**: `String`\n**Format**: `xxx@xxx.xxx`\n**Validation**: `IS_EMAIL()`\n**Required**: ‚úÖ Yes',
                        'Client.risk_rating': '**Attribute**: risk_rating\n\n**SQL Type**: `ENUM(\'LOW\', \'MEDIUM\', \'HIGH\') NOT NULL`\n**Rust Type**: `RiskLevel`\n**Domain**: RiskLevel\n**Values**: LOW, MEDIUM, HIGH\n**Required**: ‚úÖ Yes',
                        'Client.aum_usd': '**Attribute**: aum_usd\n\n**SQL Type**: `DECIMAL(18,2)`\n**Rust Type**: `rust_decimal::Decimal`\n**Format**: `$999,999,999,999.99`\n**Min Value**: 0\n**Max Value**: 999999999999999.99\n**Required**: ‚ùå No',
                        'Client.kyc_status': '**Attribute**: kyc_status\n\n**SQL Type**: `ENUM(\'PENDING\', \'APPROVED\', \'REJECTED\') NOT NULL`\n**Rust Type**: `KycStatus`\n**Values**: PENDING, APPROVED, REJECTED\n**Required**: ‚úÖ Yes',
                        'Client.pep_status': '**Attribute**: pep_status\n\n**SQL Type**: `BOOLEAN NOT NULL DEFAULT FALSE`\n**Rust Type**: `bool`\n**Description**: Politically Exposed Person status\n**Required**: ‚úÖ Yes',
                    };

                    if (fullPath && hoverInfo[fullPath]) {
                        console.log('Found hover info for:', fullPath);
                        return {
                            contents: [
                                {
                                    value: hoverInfo[fullPath],
                                    isTrusted: true,
                                    supportHtml: true
                                }
                            ],
                            range: new monaco.Range(
                                position.lineNumber,
                                start + 1,
                                position.lineNumber,
                                end + 1
                            )
                        };
                    }

                    // Try just the word under cursor if full path didn't match
                    const word = model.getWordAtPosition(position);
                    if (word && hoverInfo[word.word]) {
                        return {
                            contents: [
                                {
                                    value: hoverInfo[word.word],
                                    isTrusted: true,
                                    supportHtml: true
                                }
                            ]
                        };
                    }

                    return null;
                }
            });
            console.log('Hover provider registered:', disposable);
        }

        function updateDiagnostics(diagnostics) {
            const problemsList = document.getElementById('output-content');
            const problemsTab = document.querySelector('[data-panel="problems"]');

            if (diagnostics.length > 0) {
                problemsTab.textContent = `Problems (${diagnostics.length})`;
            } else {
                problemsTab.textContent = 'Problems';
            }

            // Store diagnostics
            diagnosticsMap.clear();
            diagnostics.forEach(d => diagnosticsMap.set(d.line, d));

            // Update Monaco markers
            const markers = diagnostics.map(d => ({
                startLineNumber: d.line,
                startColumn: 1,
                endLineNumber: d.line,
                endColumn: 1000,
                message: d.message,
                severity: d.severity === 'error' ? monaco.MarkerSeverity.Error :
                         d.severity === 'warning' ? monaco.MarkerSeverity.Warning :
                         monaco.MarkerSeverity.Info
            }));

            monaco.editor.setModelMarkers(editor.getModel(), 'dsl', markers);
        }

        async function runCode() {
            const code = editor.getValue();
            const button = document.getElementById('run-btn');

            button.disabled = true;
            button.innerHTML = '<span class="loading"></span> Running...';

            try {
                // Check if running in Tauri environment
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    // Call Tauri backend to test the rule
                    const result = await window.__TAURI__.invoke('test_rule', {
                        dslText: code
                    });

                    addToOutput('output', `‚úì Execution successful:\n${JSON.stringify(result, null, 2)}`);
                } else {
                    // Fallback for browser-only mode (simulate execution)
                    addToOutput('output', '‚ö†Ô∏è Running in browser mode (no Tauri backend)');

                    // Simple client-side validation/simulation
                    const lines = code.split('\n').filter(l => l.trim());
                    if (lines.length > 0) {
                        addToOutput('output', `‚úì Parsed ${lines.length} lines of DSL code`);

                        // Simulate some basic checks
                        const hasIf = code.includes('IF');
                        const hasThen = code.includes('THEN');

                        if (hasIf && hasThen) {
                            addToOutput('output', '‚úì Valid IF-THEN structure detected');
                        } else if (hasIf && !hasThen) {
                            addToOutput('output', '‚ö†Ô∏è Warning: IF without THEN');
                        }

                        // Check for common DSL patterns
                        if (code.includes('Client.')) {
                            addToOutput('output', '‚úì Client attributes referenced');
                        }
                        if (code.match(/IS_[A-Z]+/)) {
                            addToOutput('output', '‚úì Validation functions used');
                        }
                    } else {
                        addToOutput('output', '‚ö†Ô∏è No code to execute');
                    }
                }

            } catch (error) {
                addToOutput('output', `‚ùå Execution failed:\n${error}`);
            }

            button.disabled = false;
            button.innerHTML = '‚ñ∂ Run Code';
        }

        async function validateCode() {
            const code = editor.getValue();
            addToOutput('output', 'üîç Validating code...');

            // Simulate validation
            const lines = code.split('\n');
            const diagnostics = [];

            lines.forEach((line, index) => {
                if (line.includes('IF') && !line.includes('THEN')) {
                    diagnostics.push({
                        line: index + 1,
                        severity: 'error',
                        message: 'IF statement missing THEN clause'
                    });
                }
            });

            updateDiagnostics(diagnostics);

            if (diagnostics.length === 0) {
                addToOutput('output', '‚úì Validation successful - no issues found');
            } else {
                addToOutput('output', `‚ö† Found ${diagnostics.length} issue(s)`);
            }
        }

        function formatCode() {
            // Simple formatting - preserves line structure
            let code = editor.getValue();

            // Process line by line to preserve structure
            const lines = code.split('\n');
            const formattedLines = lines.map(line => {
                // Skip empty lines
                if (line.trim() === '') {
                    return line;
                }

                // Preserve leading whitespace (indentation)
                const leadingWhitespace = line.match(/^(\s*)/)[1];
                let trimmedLine = line.trim();

                // Skip comments (but preserve indentation)
                if (trimmedLine.startsWith('#')) {
                    return line;
                }

                // Add spacing around operators
                let formatted = trimmedLine;

                // Add space around comparison and assignment operators
                formatted = formatted.replace(/([=<>!]+)/g, ' $1 ');
                formatted = formatted.replace(/([+\-*/%])/g, ' $1 ');

                // Add space around logical operators
                formatted = formatted.replace(/\b(AND|OR)\b/g, ' $1 ');

                // Clean up spaces around parentheses and commas
                formatted = formatted.replace(/\s*\(\s*/g, '(');
                formatted = formatted.replace(/\s*\)\s*/g, ')');
                formatted = formatted.replace(/\s*,\s*/g, ', ');

                // Clean up spaces around dots (for property access)
                formatted = formatted.replace(/\s*\.\s*/g, '.');

                // Fix multiple spaces that may have been created
                formatted = formatted.replace(/\s{2,}/g, ' ');

                // Return with original indentation preserved
                return leadingWhitespace + formatted.trim();
            });

            // Rejoin with line breaks preserved
            const formattedCode = formattedLines.join('\n');

            editor.setValue(formattedCode);
            addToOutput('console', '‚úì Code formatted');
        }

        async function explainCode() {
            const code = editor.getValue();
            addToOutput('output', 'ü§ñ AI is analyzing your code...');

            // Simulate AI explanation
            setTimeout(() => {
                const explanation = `This DSL code implements a KYC risk assessment system that:
1. Calculates a risk score based on client attributes
2. Validates email and LEI formats
3. Performs pattern matching on SWIFT codes
4. Categorizes clients as PREMIUM or STANDARD based on AUM
5. Returns a formatted result string with the risk assessment`;

                addToOutput('output', `AI Explanation:\n\n${explanation}`);
            }, 1500);
        }

        function loadDataDictionary() {
            const businessAttributes = [
                { name: 'Client.client_id', type: 'String', source: 'client_provided' },
                { name: 'Client.legal_entity_name', type: 'String', source: 'client_provided' },
                { name: 'Client.lei_code', type: 'String', source: 'client_provided' },
                { name: 'Client.email', type: 'String', source: 'client_provided' },
                { name: 'Client.country_code', type: 'String', source: 'client_provided' },
                { name: 'Client.risk_rating', type: 'Enum', source: 'internal_assessment' },
                { name: 'Client.aum_usd', type: 'Number', source: 'client_provided' },
                { name: 'Client.kyc_status', type: 'Enum', source: 'system_managed' },
                { name: 'Client.pep_status', type: 'Boolean', source: 'screening_result' },
            ];

            const derivedAttributes = [
                { name: 'Client.risk_score', type: 'Number', rule: 'RULE_001' },
                { name: 'Client.email_valid', type: 'Boolean', rule: 'RULE_002' },
                { name: 'Client.kyc_completion_percentage', type: 'Number', rule: 'RULE_003' },
                { name: 'Client.enhanced_dd_required', type: 'Boolean', rule: 'RULE_004' },
                { name: 'Client.service_tier', type: 'Enum', rule: 'RULE_005' },
            ];

            const functions = [
                { name: 'IS_EMAIL', type: 'Validation' },
                { name: 'IS_LEI', type: 'Validation' },
                { name: 'IS_SWIFT', type: 'Validation' },
                { name: 'CONCAT', type: 'String' },
                { name: 'SUBSTRING', type: 'String' },
                { name: 'LOOKUP', type: 'Data' },
                { name: 'UPPER', type: 'String' },
                { name: 'LOWER', type: 'String' },
                { name: 'LENGTH', type: 'String' },
                { name: 'ROUND', type: 'Number' },
            ];

            const attrList = document.getElementById('attribute-list');
            attrList.innerHTML = ''; // Clear existing

            // Add Business Attributes section
            const businessHeader = document.createElement('li');
            businessHeader.className = 'attribute-section-header';
            businessHeader.innerHTML = '<strong>üìä Business Data</strong>';
            businessHeader.style.marginBottom = '8px';
            businessHeader.style.color = '#90caf9';
            attrList.appendChild(businessHeader);

            businessAttributes.forEach(attr => {
                const li = document.createElement('li');
                li.className = 'attribute-item business-attribute';
                li.innerHTML = `<span style="color: #90caf9;">‚óè</span> ${attr.name} <span class="attribute-type">${attr.type}</span>`;
                li.title = `Source: ${attr.source}`;
                li.onclick = () => insertText(attr.name);
                attrList.appendChild(li);
            });

            // Add Derived Attributes section
            const derivedHeader = document.createElement('li');
            derivedHeader.className = 'attribute-section-header';
            derivedHeader.innerHTML = '<strong>üîß Derived Data</strong>';
            derivedHeader.style.marginTop = '15px';
            derivedHeader.style.marginBottom = '8px';
            derivedHeader.style.color = '#a5d6a7';
            attrList.appendChild(derivedHeader);

            derivedAttributes.forEach(attr => {
                const li = document.createElement('li');
                li.className = 'attribute-item derived-attribute';
                li.innerHTML = `<span style="color: #a5d6a7;">‚óè</span> ${attr.name} <span class="attribute-type">${attr.type}</span>`;
                li.title = `Generated by: ${attr.rule}`;
                li.onclick = () => insertText(attr.name);
                attrList.appendChild(li);
            });

            const funcList = document.getElementById('function-list');
            funcList.innerHTML = ''; // Clear existing

            functions.forEach(func => {
                const li = document.createElement('li');
                li.className = 'attribute-item';
                li.innerHTML = `${func.name}() <span class="attribute-type">${func.type}</span>`;
                li.onclick = () => insertText(`${func.name}()`);
                funcList.appendChild(li);
            });
        }

        function insertText(text) {
            const selection = editor.getSelection();
            const id = { major: 1, minor: 1 };
            const op = { identifier: id, range: selection, text: text, forceMoveMarkers: true };
            editor.executeEdits("insert", [op]);
            editor.focus();
        }

        function addToOutput(panel, message) {
            const outputContent = document.getElementById('output-content');
            const timestamp = new Date().toLocaleTimeString();
            outputContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            outputContent.scrollTop = outputContent.scrollHeight;

            // Switch to the appropriate tab
            document.querySelectorAll('.output-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.panel === panel);
            });
        }

        function clearOutput() {
            document.getElementById('output-content').innerHTML = '';
        }

        // Tab switching
        document.querySelectorAll('.output-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.output-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Switch between different output panels
                const panel = tab.dataset.panel;
                if (panel === 'problems') {
                    showProblems();
                } else if (panel === 'agent') {
                    showAgentChat();
                } else if (panel === 'rules') {
                    showRulesCatalogue();
                } else {
                    showOutput();
                }
            });
        });

        function showProblems() {
            const outputContent = document.getElementById('output-content');
            outputContent.innerHTML = '<ul class="diagnostics-list">';

            diagnosticsMap.forEach((diag, line) => {
                outputContent.innerHTML += `
                    <li class="diagnostic-item ${diag.severity}" onclick="goToLine(${line})">
                        Line ${line}: ${diag.message}
                    </li>
                `;
            });

            outputContent.innerHTML += '</ul>';
        }

        // AI Agent Chat Implementation
        let chatHistory = [];
        let apiKey = localStorage.getItem('openai_api_key') || '';

        async function showAgentChat() {
            const outputContent = document.getElementById('output-content');

            // Check API key status
            let apiKey = localStorage.getItem('ai_api_key') || sessionStorage.getItem('ai_api_key');
            let apiProvider = localStorage.getItem('ai_provider') || sessionStorage.getItem('ai_provider') || 'anthropic';

            // Try to get from system if not in storage
            if (!apiKey && window.__TAURI__ && window.__TAURI__.invoke) {
                try {
                    const systemKeys = await window.__TAURI__.invoke('get_api_keys');
                    if (systemKeys) {
                        if (systemKeys.anthropic) {
                            apiKey = systemKeys.anthropic;
                            apiProvider = 'anthropic';
                        } else if (systemKeys.openai) {
                            apiKey = systemKeys.openai;
                            apiProvider = 'openai';
                        }
                    }
                } catch (error) {
                    console.log('Could not check system keys');
                }
            }

            // Create the chat interface
            outputContent.innerHTML = `
                <div class="agent-container">
                    <div class="context-indicator">
                        üìù Context: Current DSL rule in editor
                    </div>
                    <div class="chat-messages" id="chat-messages">
                        <div class="chat-message system">
                            Welcome! I'm your DSL Assistant. I can help you with:
                            <br>‚Ä¢ Explaining DSL rules and syntax
                            <br>‚Ä¢ Debugging and fixing errors
                            <br>‚Ä¢ Providing examples and patterns
                            <br>‚Ä¢ Optimizing your rules
                            <br>
                            <br>${apiKey ? '‚úÖ AI Mode Active' : 'ü§ñ Offline Mode - Intelligent fallback active'}
                            <br><small>${apiKey ? 'Using ' + apiProvider.toUpperCase() + ' API' : 'For AI-powered responses, configure an API key in Settings'}</small>
                        </div>
                    </div>
                    <div class="chat-input-container">
                        <input type="text"
                               class="chat-input"
                               id="chat-input"
                               placeholder="Ask about your DSL rule or request help..."
                               onkeypress="handleChatKeyPress(event)">
                        <button class="chat-send-btn"
                                id="chat-send"
                                onclick="sendChatMessage()">
                            Send
                        </button>
                    </div>
                </div>
            `;

            // Load chat history if exists
            if (chatHistory.length > 0) {
                const messagesContainer = document.getElementById('chat-messages');
                messagesContainer.innerHTML = '';
                chatHistory.forEach(msg => {
                    addChatMessage(msg.role, msg.content, false);
                });
            }

            // Focus on input
            document.getElementById('chat-input').focus();
        }

        function addChatMessage(role, content, save = true) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;

            // Parse code blocks in assistant messages
            if (role === 'assistant') {
                content = content.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
                    return `<div class="message-code">${escapeHtml(code.trim())}</div>`;
                });
                messageDiv.innerHTML = content.replace(/\n/g, '<br>');
            } else {
                messageDiv.textContent = content;
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Save to history
            if (save) {
                chatHistory.push({ role, content });
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const sendButton = document.getElementById('chat-send');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addChatMessage('user', message);
            input.value = '';
            sendButton.disabled = true;

            // Get current context
            const currentRule = editor.getValue();
            const selectedText = editor.getModel().getValueInRange(editor.getSelection());

            // Build context with RAG from data dictionary
            const context = buildAgentContext(currentRule, selectedText);

            try {
                // For now, use a mock response. In production, this would call OpenAI/Anthropic
                const response = await callAIAgent(message, context);
                addChatMessage('assistant', response);
            } catch (error) {
                addChatMessage('system', `Error: ${error.message}`);
            }

            sendButton.disabled = false;
            input.focus();
        }

        function buildAgentContext(currentRule, selectedText) {
            // Build comprehensive context for the AI
            const context = {
                currentRule: currentRule,
                selectedText: selectedText,
                dataDict: {
                    entities: ['Client'],
                    attributes: [
                        'Client.client_id - VARCHAR(50) PRIMARY KEY - Format: XXX-999',
                        'Client.legal_entity_name - VARCHAR(255) NOT NULL',
                        'Client.lei_code - CHAR(20) - Legal Entity Identifier',
                        'Client.email - VARCHAR(255) NOT NULL - Validated with IS_EMAIL',
                        'Client.risk_rating - ENUM(LOW,MEDIUM,HIGH)',
                        'Client.aum_usd - DECIMAL(18,2) - Format: $999,999,999,999.99',
                        'Client.kyc_status - ENUM(PENDING,APPROVED,REJECTED)',
                        'Client.pep_status - BOOLEAN NOT NULL'
                    ],
                    functions: [
                        'IS_EMAIL(email) - Validates email format',
                        'IS_LEI(lei) - Validates Legal Entity Identifier',
                        'IS_SWIFT(code) - Validates SWIFT/BIC code',
                        'CONCAT(...) - Concatenate values',
                        'SUBSTRING(str, start, end) - Extract substring',
                        'LOOKUP(key, table) - Look up value from table'
                    ],
                    operators: [
                        'Arithmetic: +, -, *, /, %',
                        'Comparison: ==, !=, <, >, <=, >=',
                        'Logical: AND, OR, NOT',
                        'String concat: &',
                        'Regex match: ~'
                    ]
                },
                language: 'DSL for KYC validation and data transformation'
            };

            return context;
        }

        async function callAIAgent(message, context) {
            // First try to get API keys from system environment via Tauri
            let apiKey = localStorage.getItem('ai_api_key');
            let apiProvider = localStorage.getItem('ai_provider') || 'anthropic';

            // If no localStorage key and running in Tauri, try to get from environment
            if (!apiKey && window.__TAURI__ && window.__TAURI__.invoke) {
                try {
                    const systemKeys = await window.__TAURI__.invoke('get_api_keys');
                    if (systemKeys) {
                        // Prefer Anthropic key if available
                        if (systemKeys.anthropic) {
                            apiKey = systemKeys.anthropic;
                            apiProvider = 'anthropic';
                            // Optionally save to localStorage for this session
                            sessionStorage.setItem('ai_api_key', apiKey);
                            sessionStorage.setItem('ai_provider', apiProvider);
                        } else if (systemKeys.openai) {
                            apiKey = systemKeys.openai;
                            apiProvider = 'openai';
                            sessionStorage.setItem('ai_api_key', apiKey);
                            sessionStorage.setItem('ai_provider', apiProvider);
                        }
                    }
                } catch (error) {
                    console.log('Could not retrieve system API keys:', error);
                }
            }

            // Check sessionStorage as well for temporary keys
            if (!apiKey) {
                apiKey = sessionStorage.getItem('ai_api_key');
                apiProvider = sessionStorage.getItem('ai_provider') || apiProvider;
            }

            if (!apiKey) {
                // If no API key, use intelligent mock responses
                return getMockResponse(message, context);
            }

            try {
                // Prepare the system prompt with context
                const systemPrompt = `You are an AI assistant specializing in DSL (Domain Specific Language) development for KYC (Know Your Customer) data transformation rules.

Current context:
- User is working on: ${context.currentRule ? context.currentRule.substring(0, 500) + '...' : 'No rule loaded'}
- Available attributes: ${Object.keys(context.attributes).join(', ')}
- Available functions: ${context.functions.join(', ')}
- Available operators: ${context.operators.join(', ')}

Help the user with DSL syntax, debugging, optimization, and best practices. Be concise and code-focused.`;

                if (apiProvider === 'openai') {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: localStorage.getItem('ai_model') || 'gpt-4-turbo-preview',
                            messages: [
                                { role: 'system', content: systemPrompt },
                                { role: 'user', content: message }
                            ],
                            temperature: 0.7,
                            max_tokens: 1000
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.choices[0].message.content;

                } else if (apiProvider === 'anthropic') {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({
                            model: localStorage.getItem('ai_model') || 'claude-3-opus-20240229',
                            max_tokens: 1000,
                            system: systemPrompt,
                            messages: [
                                { role: 'user', content: message }
                            ]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Anthropic API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.content[0].text;
                }

            } catch (error) {
                console.error('AI API call failed:', error);
                // Fall back to mock responses if API fails
                return getMockResponse(message, context) +
                       `\n\n<small>‚ö†Ô∏è API call failed: ${error.message}. Using offline responses.</small>`;
            }
        }

        function getMockResponse(message, context) {
            // Enhanced intelligent mock responses for offline/fallback mode
            const lowerMessage = message.toLowerCase();
            const currentRule = context?.currentRule || '';

            // Analyze the current rule for context-aware responses
            const hasIfStatement = currentRule.includes('IF');
            const hasClientAttributes = currentRule.includes('Client.');
            const hasValidation = currentRule.includes('IS_EMAIL') || currentRule.includes('IS_LEI');
            const hasCalculation = currentRule.includes('+') || currentRule.includes('-') || currentRule.includes('*');

            // Question type detection
            if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('hey')) {
                return `Hello! I'm your DSL Assistant running in offline mode. I can help you with:

‚Ä¢ **DSL Syntax** - IF/THEN/ELSE statements, operators, functions
‚Ä¢ **Data Attributes** - Business vs derived attributes, types, constraints
‚Ä¢ **Rule Examples** - KYC validation, risk scoring, data transformation
‚Ä¢ **Debugging** - Common errors and fixes
‚Ä¢ **Best Practices** - Optimization tips and patterns

What would you like help with today?

<small>üí° For AI-powered responses, configure an API key in Settings or set ANTHROPIC_API_KEY in your environment.</small>`;
            }

            if (lowerMessage.includes('what') && lowerMessage.includes('attributes')) {
                const businessAttrs = Object.keys(context.attributes).filter(a =>
                    !['risk_score', 'email_valid', 'kyc_completion_percentage', 'enhanced_dd_required', 'service_tier'].some(d => a.includes(d))
                );
                const derivedAttrs = ['risk_score', 'email_valid', 'kyc_completion_percentage', 'enhanced_dd_required', 'service_tier'];

                return `Here are the available attributes in your data dictionary:

**üìä Business Attributes (Source Data):**
${businessAttrs.map(attr => `‚Ä¢ Client.${attr}`).join('\n')}

**üîß Derived Attributes (Calculated):**
${derivedAttrs.map(attr => `‚Ä¢ Client.${attr} (generated by rules)`).join('\n')}

Business attributes are provided by clients or internal systems. Derived attributes are calculated using DSL rules.`;
            }

            if (lowerMessage.includes('explain') || lowerMessage.includes('what does')) {
                if (currentRule) {
                    // Analyze the current rule
                    let explanation = `Looking at your current rule:\n\n`;

                    if (hasIfStatement) {
                        explanation += `‚Ä¢ **Conditional Logic**: Your rule uses IF/THEN statements to make decisions based on conditions.\n`;
                    }
                    if (hasClientAttributes) {
                        const attrs = currentRule.match(/Client\.\w+/g) || [];
                        explanation += `‚Ä¢ **Attributes Used**: ${[...new Set(attrs)].join(', ')}\n`;
                    }
                    if (hasValidation) {
                        explanation += `‚Ä¢ **Validation**: Your rule validates data formats (email, LEI, etc.)\n`;
                    }
                    if (hasCalculation) {
                        explanation += `‚Ä¢ **Calculations**: Your rule performs arithmetic operations\n`;
                    }

                    explanation += `\n**How it works:**\n`;
                    explanation += `1. The rule evaluates conditions sequentially\n`;
                    explanation += `2. When a condition is true, its corresponding action executes\n`;
                    explanation += `3. Results can be stored in variables for later use\n`;
                    explanation += `4. Functions like IS_EMAIL() validate data formats\n`;

                    return explanation;
                } else {
                    return `The DSL (Domain Specific Language) uses:

‚Ä¢ **IF/THEN/ELSE** - Conditional logic for decision making
‚Ä¢ **Client.attribute** - Access data fields (e.g., Client.email)
‚Ä¢ **Operators** - ==, !=, >, <, >=, <= for comparisons
‚Ä¢ **Functions** - IS_EMAIL(), CONCAT(), LOOKUP() for operations
‚Ä¢ **Variables** - Store intermediate results

Example:
<div class="message-code">IF Client.risk_rating == "HIGH" THEN
    risk_score = 100
ELSE
    risk_score = 50
END</div>`;
                }
            }

            if (lowerMessage.includes('fix') || lowerMessage.includes('error') || lowerMessage.includes('debug')) {
                // Analyze current rule for potential issues
                let debugInfo = `Common issues to check in DSL rules:\n\n`;

                if (currentRule) {
                    const openIfs = (currentRule.match(/IF/g) || []).length;
                    const ends = (currentRule.match(/END/g) || []).length;

                    if (openIfs !== ends) {
                        debugInfo += `‚ö†Ô∏è **Unmatched IF/END**: You have ${openIfs} IF statements but ${ends} END statements\n\n`;
                    }

                    // Check for common syntax issues
                    if (currentRule.includes('=') && !currentRule.includes('==')) {
                        debugInfo += `üí° **Assignment vs Comparison**: Use '=' for assignment, '==' for comparison\n\n`;
                    }

                    if (currentRule.match(/"\w+/g) || currentRule.match(/\w+"/g)) {
                        debugInfo += `‚ö†Ô∏è **Quote Mismatch**: Check that all strings have matching quotes\n\n`;
                    }
                }

                debugInfo += `**Debugging Checklist:**
‚úì All IF statements have matching END
‚úì String values are in quotes: "value"
‚úì Numbers are without quotes: 123
‚úì Attribute names are correct: Client.attribute_name
‚úì Functions have parentheses: IS_EMAIL()
‚úì Operators are correct: == for comparison, = for assignment

<div class="message-code"># Correct syntax example
IF Client.risk_rating == "HIGH" THEN
    enhanced_review = true
    risk_score = 100
END</div>`;

                return debugInfo;
            }

            if (lowerMessage.includes('example') || lowerMessage.includes('how') || lowerMessage.includes('show')) {
                // Provide relevant examples based on context
                if (lowerMessage.includes('risk')) {
                    return `Here's a comprehensive risk scoring example:

<div class="message-code"># Initialize risk score
risk_score = 0

# Base risk from rating
IF Client.risk_rating == "HIGH" THEN
    risk_score = risk_score + 50
ELSE IF Client.risk_rating == "MEDIUM" THEN
    risk_score = risk_score + 25
ELSE
    risk_score = risk_score + 10
END

# PEP adjustment
IF Client.pep_status == true THEN
    risk_score = risk_score + 30
END

# Large AUM adjustment
IF Client.aum_usd > 10000000 THEN
    risk_score = risk_score + 20
END

# Final classification
risk_category = IF risk_score >= 70 THEN "HIGH_RISK"
                ELSE IF risk_score >= 40 THEN "MEDIUM_RISK"
                ELSE "LOW_RISK"</div>`;
                } else if (lowerMessage.includes('valid')) {
                    return `Here are validation examples:

<div class="message-code"># Email validation
email_valid = IS_EMAIL(Client.email)

# LEI code validation
lei_valid = IS_LEI(Client.lei_code)

# Combined validation
all_valid = email_valid AND lei_valid

# Validation with action
IF NOT IS_EMAIL(Client.email) THEN
    validation_status = "INVALID_EMAIL"
    require_manual_review = true
ELSE
    validation_status = "VALID"
END</div>`;
                } else {
                    return `Here are common DSL patterns:

**1. Simple Assignment:**
<div class="message-code">status = "ACTIVE"
score = 100</div>

**2. Conditional Logic:**
<div class="message-code">IF Client.aum_usd > 1000000 THEN
    tier = "GOLD"
ELSE
    tier = "SILVER"
END</div>

**3. String Operations:**
<div class="message-code">full_name = CONCAT(Client.first_name, " ", Client.last_name)
code = SUBSTRING(Client.client_id, 0, 3)</div>

**4. Validation:**
<div class="message-code">valid = IS_EMAIL(Client.email) AND Client.country_code != ""</div>

Which pattern would you like to explore more?`;
                }
            }

            if (lowerMessage.includes('optimize') || lowerMessage.includes('improve') || lowerMessage.includes('better')) {
                return `Here are optimization tips for DSL rules:

**1. Combine Related Conditions:**
Instead of:
<div class="message-code">IF Client.risk_rating == "HIGH" THEN
    flag = true
END
IF Client.pep_status == true THEN
    flag = true
END</div>

Use:
<div class="message-code">flag = Client.risk_rating == "HIGH" OR Client.pep_status == true</div>

**2. Use Early Returns:**
<div class="message-code">IF Client.kyc_status == "REJECTED" THEN
    process_status = "BLOCKED"
    # No need to check further
ELSE
    # Continue with other checks
END</div>

**3. Extract Complex Logic:**
<div class="message-code"># Define reusable conditions
is_high_risk = Client.risk_rating == "HIGH" OR Client.pep_status == true
is_large_client = Client.aum_usd > 10000000

# Use in logic
enhanced_review = is_high_risk AND is_large_client</div>

**4. Add Comments:**
<div class="message-code"># Risk assessment for institutional clients
# High risk triggers enhanced due diligence</div>`;
            }

            if (lowerMessage.includes('test') || lowerMessage.includes('run')) {
                return `To test your DSL rules:

1. **Use the Run Button** (‚ñ∂): Executes your rule with sample data
2. **Check the Output Tab**: Shows execution results and any errors
3. **Review Problems Tab**: Lists syntax errors and warnings

**Sample Test Data Available:**
‚Ä¢ Client.client_id = "CLT-001"
‚Ä¢ Client.risk_rating = "MEDIUM"
‚Ä¢ Client.aum_usd = 5000000
‚Ä¢ Client.email = "client@example.com"
‚Ä¢ Client.pep_status = false

**Testing Tips:**
‚Ä¢ Test edge cases (empty values, extremes)
‚Ä¢ Verify all conditional branches
‚Ä¢ Check calculation accuracy
‚Ä¢ Validate output formats`;
            }

            if (lowerMessage.includes('function') || lowerMessage.includes('what functions')) {
                const functions = context.functions || [];
                return `Available DSL Functions:

${functions.map(fn => `**${fn}()**`).join('\n')}

**Common Functions:**
‚Ä¢ **IS_EMAIL(email)** - Validates email format
‚Ä¢ **IS_LEI(code)** - Validates Legal Entity Identifier
‚Ä¢ **CONCAT(...)** - Concatenates multiple values
‚Ä¢ **SUBSTRING(str, start, end)** - Extracts substring
‚Ä¢ **LOOKUP(key, table)** - Looks up value from table
‚Ä¢ **UPPER/LOWER(str)** - Case conversion
‚Ä¢ **LENGTH(str)** - String length
‚Ä¢ **ROUND(num, decimals)** - Number rounding

Example:
<div class="message-code">email_valid = IS_EMAIL(Client.email)
full_text = CONCAT("Status: ", Client.kyc_status)
country = LOOKUP(Client.country_code, "countries")</div>`;
            }

            // Context-aware default response
            if (currentRule) {
                return `I see you're working on a DSL rule. Based on your code:

${hasIfStatement ? '‚Ä¢ You have conditional logic (IF/THEN statements)\n' : ''}
${hasClientAttributes ? '‚Ä¢ You\'re using Client attributes for data access\n' : ''}
${hasValidation ? '‚Ä¢ You\'re performing data validation\n' : ''}
${hasCalculation ? '‚Ä¢ You\'re doing calculations\n' : ''}

I can help you:
‚Ä¢ Debug any issues
‚Ä¢ Optimize the logic
‚Ä¢ Add validation
‚Ä¢ Provide examples

What specific help do you need?

<small>ü§ñ Offline Assistant Mode - For AI-powered help, add an API key in Settings</small>`;
            }

            // Generic but helpful default
            return `I'm here to help with your DSL development!

**Quick Help Menu:**
‚Ä¢ Type "explain" - Understand DSL syntax
‚Ä¢ Type "example" - See code examples
‚Ä¢ Type "fix" or "error" - Debug issues
‚Ä¢ Type "optimize" - Improve your rules
‚Ä¢ Type "functions" - List available functions
‚Ä¢ Type "attributes" - See data dictionary

**Your Question:** "${message}"

Please be more specific about what you need help with, and I'll provide detailed guidance.

<small>üí° Running in offline mode. For enhanced AI responses, configure an API key in Settings or set ANTHROPIC_API_KEY environment variable.</small>`;
        }

        window.handleChatKeyPress = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        window.sendChatMessage = sendChatMessage;

        function showOutput() {
            // Output already shows in main output
        }

        // Rules Catalogue Implementation
        let rulesCatalogue = null;
        let enhancedDataDictionary = null;

        async function loadRulesCatalogue() {
            try {
                // In production, this would load from server/database
                // For now, using mock data
                rulesCatalogue = {
                    rules: [
                        {
                            ruleId: "RULE_001",
                            ruleName: "Calculate Risk Score",
                            description: "Calculate overall risk score based on client risk rating, PEP status, and AUM",
                            targetAttribute: "Client.risk_score",
                            sourceAttributes: ["Client.risk_rating", "Client.pep_status", "Client.aum_usd"],
                            category: "risk_assessment",
                            status: "active"
                        },
                        {
                            ruleId: "RULE_002",
                            ruleName: "Validate Email Format",
                            description: "Validate client email address format",
                            targetAttribute: "Client.email_valid",
                            sourceAttributes: ["Client.email"],
                            category: "validation",
                            status: "active"
                        },
                        {
                            ruleId: "RULE_003",
                            ruleName: "KYC Completion Status",
                            description: "Determine KYC completion percentage based on required fields",
                            targetAttribute: "Client.kyc_completion_percentage",
                            sourceAttributes: ["Client.client_id", "Client.legal_entity_name", "Client.lei_code", "Client.email", "Client.country_code"],
                            category: "kyc_validation",
                            status: "active"
                        },
                        {
                            ruleId: "RULE_004",
                            ruleName: "Enhanced Due Diligence Flag",
                            description: "Determine if enhanced due diligence is required",
                            targetAttribute: "Client.enhanced_dd_required",
                            sourceAttributes: ["Client.risk_rating", "Client.pep_status", "Client.aum_usd", "Client.country_code"],
                            category: "compliance",
                            status: "active"
                        },
                        {
                            ruleId: "RULE_005",
                            ruleName: "Client Tier Classification",
                            description: "Classify client into service tiers based on AUM",
                            targetAttribute: "Client.service_tier",
                            sourceAttributes: ["Client.aum_usd"],
                            category: "classification",
                            status: "active"
                        }
                    ]
                };
                return true;
            } catch (error) {
                console.error('Failed to load rules catalogue:', error);
                return false;
            }
        }

        function showRulesCatalogue() {
            const outputContent = document.getElementById('output-content');

            if (!rulesCatalogue) {
                loadRulesCatalogue().then(() => showRulesCatalogue());
                outputContent.innerHTML = '<div class="loading">Loading rules catalogue...</div>';
                return;
            }

            outputContent.innerHTML = `
                <div class="rules-catalogue-container">
                    <div class="rules-catalogue-header">
                        <h3>üìã Rules Catalogue</h3>
                        <div class="rules-actions">
                            <button class="btn secondary" onclick="addNewRule()">‚ûï New Rule</button>
                            <button class="btn secondary" onclick="refreshRulesCatalogue()">üîÑ Refresh</button>
                        </div>
                    </div>

                    <div class="rules-filters">
                        <select id="category-filter" onchange="filterRules()">
                            <option value="">All Categories</option>
                            <option value="risk_assessment">Risk Assessment</option>
                            <option value="validation">Data Validation</option>
                            <option value="kyc_validation">KYC Validation</option>
                            <option value="compliance">Compliance</option>
                            <option value="classification">Classification</option>
                        </select>
                        <select id="status-filter" onchange="filterRules()">
                            <option value="">All Status</option>
                            <option value="active">Active</option>
                            <option value="draft">Draft</option>
                            <option value="inactive">Inactive</option>
                        </select>
                        <input type="text" id="rule-search" placeholder="Search rules..." oninput="filterRules()">
                    </div>

                    <div class="rules-list" id="rules-list">
                        ${rulesCatalogue.rules.map(rule => `
                            <div class="rule-card" data-rule-id="${rule.ruleId}">
                                <div class="rule-header">
                                    <span class="rule-id">${rule.ruleId}</span>
                                    <span class="rule-status ${rule.status}">${rule.status.toUpperCase()}</span>
                                </div>
                                <h4 class="rule-name">${rule.ruleName}</h4>
                                <p class="rule-description">${rule.description}</p>

                                <div class="rule-attributes">
                                    <div class="attribute-group">
                                        <label>Target (Output):</label>
                                        <span class="attribute-tag derived">${rule.targetAttribute}</span>
                                    </div>
                                    <div class="attribute-group">
                                        <label>Sources (Inputs):</label>
                                        ${rule.sourceAttributes.map(attr =>
                                            `<span class="attribute-tag business">${attr}</span>`
                                        ).join('')}
                                    </div>
                                </div>

                                <div class="rule-actions">
                                    <button class="btn-small" onclick="editRule('${rule.ruleId}')">‚úèÔ∏è Edit</button>
                                    <button class="btn-small" onclick="viewRule('${rule.ruleId}')">üëÅÔ∏è View</button>
                                    <button class="btn-small" onclick="testRule('${rule.ruleId}')">‚ñ∂Ô∏è Test</button>
                                    <button class="btn-small secondary" onclick="duplicateRule('${rule.ruleId}')">üìã Duplicate</button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function filterRules() {
            const category = document.getElementById('category-filter')?.value;
            const status = document.getElementById('status-filter')?.value;
            const search = document.getElementById('rule-search')?.value?.toLowerCase();

            const ruleCards = document.querySelectorAll('.rule-card');
            ruleCards.forEach(card => {
                const rule = rulesCatalogue.rules.find(r => r.ruleId === card.dataset.ruleId);
                let show = true;

                if (category && rule.category !== category) show = false;
                if (status && rule.status !== status) show = false;
                if (search && !rule.ruleName.toLowerCase().includes(search) &&
                    !rule.description.toLowerCase().includes(search)) show = false;

                card.style.display = show ? 'block' : 'none';
            });
        }

        function addNewRule() {
            // In production, this would open a modal or switch to rule editor
            alert('Rule editor would open here to create a new rule');
        }

        function editRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule && rule.ruleDefinition) {
                // Load rule into editor
                editor.setValue(rule.ruleDefinition);
                // Switch to Output tab
                document.querySelector('[data-panel="output"]').click();
                addToOutput('info', `Loaded rule ${ruleId} into editor`);
            }
        }

        function viewRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule) {
                alert(`Rule: ${rule.ruleName}\n\nDefinition would be displayed here`);
            }
        }

        function testRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule) {
                addToOutput('info', `Testing rule ${ruleId}: ${rule.ruleName}`);
                // In production, would execute the rule with test data
            }
        }

        function duplicateRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule) {
                const newRule = { ...rule, ruleId: `RULE_${Date.now()}`, ruleName: rule.ruleName + ' (Copy)' };
                rulesCatalogue.rules.push(newRule);
                showRulesCatalogue();
                addToOutput('success', `Duplicated rule ${ruleId} as ${newRule.ruleId}`);
            }
        }

        function refreshRulesCatalogue() {
            loadRulesCatalogue().then(() => showRulesCatalogue());
        }

        // Make functions globally available
        window.showRulesCatalogue = showRulesCatalogue;
        window.filterRules = filterRules;
        window.addNewRule = addNewRule;
        window.editRule = editRule;
        window.viewRule = viewRule;
        window.testRule = testRule;
        window.duplicateRule = duplicateRule;
        window.refreshRulesCatalogue = refreshRulesCatalogue;

        window.goToLine = function(line) {
            editor.revealLineInCenter(line);
            editor.setPosition({ lineNumber: line, column: 1 });
            editor.focus();
        };

        // Make functions available globally
        window.runCode = runCode;
        window.validateCode = validateCode;
        window.formatCode = formatCode;
        window.explainCode = explainCode;
        window.connectToLSP = connectToLSP;
        window.clearOutput = clearOutput;
        // Settings Modal Functions
        async function showSettings() {
            const existingModal = document.getElementById('settings-modal');
            if (existingModal) {
                existingModal.style.display = 'block';
                checkSystemKeys();
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'settings-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>AI Assistant Settings</h2>
                        <span class="close" onclick="closeSettings()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="setting-group">
                            <label>AI Provider:</label>
                            <select id="ai-provider" onchange="updateProviderSettings()">
                                <option value="openai">OpenAI (GPT-4)</option>
                                <option value="anthropic">Anthropic (Claude)</option>
                            </select>
                        </div>

                        <div class="setting-group">
                            <label id="api-key-label">OpenAI API Key:</label>
                            <input type="password"
                                   id="api-key-input"
                                   placeholder="sk-... (leave empty to use system key)"
                                   value="${localStorage.getItem('ai_api_key') || ''}">
                            <small>Leave empty to use system environment variables (ANTHROPIC_API_KEY, OPENAI_API_KEY).<br>
                                   Manual entry will override system keys. Keys are stored locally and never sent to any server except the AI provider.</small>
                        </div>

                        <div class="setting-group">
                            <label>Model:</label>
                            <select id="ai-model">
                                <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                            </select>
                        </div>

                        <div class="setting-actions">
                            <button class="btn" onclick="saveSettings()">Save Settings</button>
                            <button class="btn secondary" onclick="testAPIKey()">Test Connection</button>
                        </div>

                        <div id="settings-status"></div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Load saved settings
            const savedProvider = localStorage.getItem('ai_provider') || 'anthropic';
            document.getElementById('ai-provider').value = savedProvider;
            updateProviderSettings();

            // Check for system keys
            checkSystemKeys();
        }

        async function checkSystemKeys() {
            if (!window.__TAURI__ || !window.__TAURI__.invoke) {
                return;
            }

            try {
                const systemKeys = await window.__TAURI__.invoke('get_api_keys');
                const statusDiv = document.getElementById('settings-status');

                if (systemKeys) {
                    let detectedKeys = [];
                    if (systemKeys.anthropic) {
                        detectedKeys.push('ANTHROPIC_API_KEY');
                        // Auto-select Anthropic if system key found
                        if (!localStorage.getItem('ai_api_key')) {
                            document.getElementById('ai-provider').value = 'anthropic';
                            updateProviderSettings();
                        }
                    }
                    if (systemKeys.openai) {
                        detectedKeys.push('OPENAI_API_KEY');
                    }

                    if (detectedKeys.length > 0) {
                        showSettingsStatus(
                            `‚úÖ System API keys detected: ${detectedKeys.join(', ')}. ` +
                            `The AI Agent will use these automatically unless you override with manual settings.`,
                            'success'
                        );
                    }
                }
            } catch (error) {
                console.log('Could not check for system keys:', error);
            }
        }

        function closeSettings() {
            const modal = document.getElementById('settings-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function updateProviderSettings() {
            const provider = document.getElementById('ai-provider').value;
            const label = document.getElementById('api-key-label');
            const input = document.getElementById('api-key-input');
            const modelSelect = document.getElementById('ai-model');

            if (provider === 'anthropic') {
                label.textContent = 'Anthropic API Key:';
                input.placeholder = 'sk-ant-...';
                modelSelect.innerHTML = `
                    <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                    <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
                    <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                `;
            } else {
                label.textContent = 'OpenAI API Key:';
                input.placeholder = 'sk-...';
                modelSelect.innerHTML = `
                    <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                `;
            }
        }

        function saveSettings() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const provider = document.getElementById('ai-provider').value;
            const model = document.getElementById('ai-model').value;

            if (apiKey) {
                localStorage.setItem('ai_api_key', apiKey);
                localStorage.setItem('ai_provider', provider);
                localStorage.setItem('ai_model', model);
                showSettingsStatus('Settings saved successfully!', 'success');
            } else {
                showSettingsStatus('Please enter an API key', 'error');
            }
        }

        async function testAPIKey() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const provider = document.getElementById('ai-provider').value;

            if (!apiKey) {
                showSettingsStatus('Please enter an API key first', 'error');
                return;
            }

            showSettingsStatus('Testing connection...', 'info');

            try {
                // Test the API key with a simple request
                const context = getAgentContext();
                const response = await callAIAgent('Hello, can you confirm you are working?', context);

                if (response && !response.includes('API call failed')) {
                    showSettingsStatus('‚úì Connection successful! AI assistant is ready.', 'success');
                } else {
                    showSettingsStatus('Connection failed. Please check your API key.', 'error');
                }
            } catch (error) {
                showSettingsStatus(`Connection failed: ${error.message}`, 'error');
            }
        }

        function showSettingsStatus(message, type) {
            const statusDiv = document.getElementById('settings-status');
            statusDiv.className = `status-message ${type}`;
            statusDiv.textContent = message;
        }

        // Make functions available globally
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.updateProviderSettings = updateProviderSettings;
        window.saveSettings = saveSettings;
        window.testAPIKey = testAPIKey;

        // Resizable Panes Implementation
        function initializeResizablePanes() {
            const sidebar = document.getElementById('sidebar');
            const editorContainer = document.getElementById('editor-container');
            const outputPanel = document.getElementById('output-panel');
            const verticalSplitter = document.getElementById('splitter-vertical');
            const horizontalSplitter = document.getElementById('splitter-horizontal');
            const mainContainer = document.querySelector('.main-container');

            let isResizingVertical = false;
            let isResizingHorizontal = false;

            // Vertical splitter (between sidebar and editor)
            verticalSplitter.addEventListener('mousedown', (e) => {
                isResizingVertical = true;
                verticalSplitter.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            // Horizontal splitter (between editor and output)
            horizontalSplitter.addEventListener('mousedown', (e) => {
                isResizingHorizontal = true;
                horizontalSplitter.classList.add('dragging');
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isResizingVertical) {
                    const containerRect = mainContainer.getBoundingClientRect();
                    const newWidth = e.clientX - containerRect.left;

                    // Enforce min/max constraints
                    if (newWidth >= 150 && newWidth <= 500) {
                        sidebar.style.width = newWidth + 'px';
                        // Save preference
                        localStorage.setItem('sidebar-width', newWidth);
                    }
                }

                if (isResizingHorizontal) {
                    const containerRect = editorContainer.getBoundingClientRect();
                    const editorElement = document.getElementById('monaco-editor');
                    const newHeight = containerRect.bottom - e.clientY;

                    // Enforce min/max constraints for output panel
                    if (newHeight >= 100 && newHeight <= 500) {
                        outputPanel.style.height = newHeight + 'px';
                        // Adjust editor height
                        const availableHeight = containerRect.height - newHeight - 5; // 5px for splitter
                        editorElement.style.height = availableHeight + 'px';

                        // Trigger Monaco resize
                        if (window.editor) {
                            window.editor.layout();
                        }

                        // Save preference
                        localStorage.setItem('output-height', newHeight);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizingVertical) {
                    isResizingVertical = false;
                    verticalSplitter.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }

                if (isResizingHorizontal) {
                    isResizingHorizontal = false;
                    horizontalSplitter.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });

            // Restore saved dimensions
            const savedSidebarWidth = localStorage.getItem('sidebar-width');
            if (savedSidebarWidth) {
                sidebar.style.width = savedSidebarWidth + 'px';
            }

            const savedOutputHeight = localStorage.getItem('output-height');
            if (savedOutputHeight) {
                outputPanel.style.height = savedOutputHeight + 'px';
                const containerRect = editorContainer.getBoundingClientRect();
                const editorElement = document.getElementById('monaco-editor');
                const availableHeight = containerRect.height - parseInt(savedOutputHeight) - 5;
                editorElement.style.height = availableHeight + 'px';
            }

            // Handle window resize
            window.addEventListener('resize', () => {
                if (window.editor) {
                    window.editor.layout();
                }
            });
        }

        // Initialize resizable panes after DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeResizablePanes);
        } else {
            // DOM already loaded
            setTimeout(initializeResizablePanes, 100);
        }
    </script>

    <style>
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #2d2d30;
            margin: 10% auto;
            padding: 0;
            border: 1px solid #444;
            border-radius: 8px;
            width: 500px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #e8e8e8;
        }

        .close {
            color: #999;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
        }

        .close:hover {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            color: #cccccc;
            font-weight: 500;
        }

        .setting-group input[type="password"],
        .setting-group select {
            width: 100%;
            padding: 8px 12px;
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e8e8e8;
            font-size: 14px;
        }

        .setting-group small {
            display: block;
            margin-top: 5px;
            color: #999;
            font-size: 12px;
        }

        .setting-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status-message.success {
            background: #1b5e20;
            color: #a5d6a7;
            border: 1px solid #2e7d32;
        }

        .status-message.error {
            background: #b71c1c;
            color: #ef9a9a;
            border: 1px solid #c62828;
        }

        .status-message.info {
            background: #0d47a1;
            color: #90caf9;
            border: 1px solid #1565c0;
        }
        /* Rules Catalogue Styles */
        .rules-catalogue-container {
            height: 100%;
            overflow-y: auto;
            padding: 15px;
        }

        .rules-catalogue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .rules-catalogue-header h3 {
            margin: 0;
            color: #e8e8e8;
        }

        .rules-actions {
            display: flex;
            gap: 10px;
        }

        .rules-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .rules-filters select,
        .rules-filters input {
            padding: 6px 10px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            color: #cccccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .rules-filters input {
            flex: 1;
            min-width: 200px;
        }

        .rules-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 15px;
        }

        .rule-card {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            padding: 15px;
            transition: all 0.2s;
        }

        .rule-card:hover {
            border-color: #007acc;
            box-shadow: 0 2px 8px rgba(0, 122, 204, 0.2);
        }

        .rule-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .rule-id {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #969696;
            background: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .rule-status {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
        }

        .rule-status.active {
            background: #1b5e20;
            color: #a5d6a7;
        }

        .rule-status.draft {
            background: #e65100;
            color: #ffcc80;
        }

        .rule-status.inactive {
            background: #424242;
            color: #9e9e9e;
        }

        .rule-name {
            margin: 0 0 8px 0;
            color: #e8e8e8;
            font-size: 16px;
        }

        .rule-description {
            margin: 0 0 15px 0;
            color: #969696;
            font-size: 13px;
            line-height: 1.4;
        }

        .rule-attributes {
            margin-bottom: 15px;
        }

        .attribute-group {
            margin-bottom: 10px;
        }

        .attribute-group label {
            display: block;
            font-size: 11px;
            color: #969696;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .attribute-tag {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .attribute-tag.business {
            background: #1565c0;
            color: #90caf9;
            border: 1px solid #1976d2;
        }

        .attribute-tag.derived {
            background: #2e7d32;
            color: #a5d6a7;
            border: 1px solid #388e3c;
        }

        .rule-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
            background: #3c3c3c;
            color: #cccccc;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-small:hover {
            background: #505050;
            border-color: #007acc;
        }

        .btn-small.secondary {
            background: transparent;
            border-color: #3e3e42;
        }

        .btn-small.secondary:hover {
            background: #3c3c3c;
        }
    </style>
</body>
</html>