<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DSL IDE with Language Server</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Monaco', 'Consolas', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 400;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #f44336;
        }

        .status-indicator.connected {
            background: #4caf50;
        }

        .main-container {
            flex: 1;
            display: flex;
            height: calc(100vh - 60px);
        }

        .sidebar {
            width: 250px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            color: #969696;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .tabs {
            background: #2d2d30;
            display: flex;
            border-bottom: 1px solid #3e3e42;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            background: #2d2d30;
            color: #969696;
            transition: all 0.2s;
        }

        .tab:hover {
            background: #3e3e42;
        }

        .tab.active {
            background: #1e1e1e;
            color: #d4d4d4;
            border-bottom: 2px solid #007acc;
        }

        #monaco-editor {
            flex: 1;
            width: 100%;
        }

        .output-panel {
            height: 200px;
            background: #1e1e1e;
            border-top: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
        }

        .output-header {
            background: #2d2d30;
            padding: 8px 15px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .output-tabs {
            display: flex;
            gap: 15px;
        }

        .output-tab {
            cursor: pointer;
            color: #969696;
            font-size: 14px;
            padding: 2px 5px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .output-tab:hover {
            color: #d4d4d4;
        }

        .output-tab.active {
            color: #d4d4d4;
            border-bottom-color: #007acc;
        }

        .output-content {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
        }

        .diagnostics-list {
            list-style: none;
        }

        .diagnostic-item {
            padding: 5px;
            margin-bottom: 5px;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .diagnostic-item:hover {
            background: #2d2d30;
        }

        .diagnostic-item.error {
            border-left-color: #f44336;
            color: #f48771;
        }

        .diagnostic-item.warning {
            border-left-color: #ffeb3b;
            color: #dcdcaa;
        }

        .diagnostic-item.info {
            border-left-color: #2196f3;
            color: #9cdcfe;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .btn {
            padding: 5px 15px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #5a5a5a;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #3c3c3c;
        }

        .btn.secondary:hover {
            background: #505050;
        }

        .test-results {
            padding: 10px;
            background: #2d2d30;
            border-radius: 3px;
            margin-top: 10px;
        }

        .test-results.success {
            border-left: 3px solid #4caf50;
        }

        .test-results.error {
            border-left: 3px solid #f44336;
        }

        .attribute-list {
            list-style: none;
        }

        .attribute-item {
            padding: 5px 10px;
            margin-bottom: 3px;
            background: #2d2d30;
            border-radius: 3px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .attribute-item:hover {
            background: #3e3e42;
        }

        .attribute-type {
            color: #4ec9b0;
            font-size: 11px;
            margin-left: 5px;
        }

        .loading {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-radius: 50%;
            border-top: 2px solid #007acc;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">
</head>
<body>
    <div class="header">
        <h1>ðŸš€ DSL IDE - Language Server Enabled</h1>
        <div class="connection-status">
            <span id="connection-text">LSP: Initializing...</span>
            <div id="status-indicator" class="status-indicator"></div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h2>Data Dictionary</h2>
            <ul id="attribute-list" class="attribute-list">
                <!-- Attributes will be loaded here -->
            </ul>

            <h2 style="margin-top: 20px;">Functions</h2>
            <ul id="function-list" class="attribute-list">
                <!-- Functions will be loaded here -->
            </ul>
        </div>

        <div class="editor-container">
            <div class="tabs">
                <div class="tab active" data-file="main.dsl">main.dsl</div>
                <div class="tab" data-file="test.dsl">test.dsl</div>
            </div>

            <div class="toolbar">
                <button class="btn" id="run-btn" onclick="runCode()">
                    â–¶ Run Code
                </button>
                <button class="btn secondary" id="validate-btn" onclick="validateCode()">
                    âœ“ Validate
                </button>
                <button class="btn secondary" id="format-btn" onclick="formatCode()">
                    âš¡ Format
                </button>
                <button class="btn secondary" id="ai-explain-btn" onclick="explainCode()">
                    ðŸ¤– AI Explain
                </button>
                <button class="btn secondary" id="connect-lsp-btn" onclick="connectToLSP()" style="opacity: 0.7;" title="LSP will auto-connect on page load">
                    ðŸ”Œ LSP Status
                </button>
            </div>

            <div id="monaco-editor"></div>

            <div class="output-panel">
                <div class="output-header">
                    <div class="output-tabs">
                        <div class="output-tab active" data-panel="output">Output</div>
                        <div class="output-tab" data-panel="problems">Problems</div>
                        <div class="output-tab" data-panel="console">Console</div>
                    </div>
                    <button class="btn secondary" style="padding: 3px 10px; font-size: 12px;" onclick="clearOutput()">Clear</button>
                </div>
                <div class="output-content" id="output-content">
                    <!-- Output will appear here -->
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    <script type="module">
        let editor;
        let lspConnection = null;
        let diagnosticsMap = new Map();

        // Initialize Monaco Editor
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });

        require(['vs/editor/editor.main'], function() {
            // Register DSL language
            monaco.languages.register({ id: 'dsl' });

            // Define DSL syntax highlighting
            monaco.languages.setMonarchTokensProvider('dsl', {
                keywords: ['IF', 'THEN', 'ELSE', 'AND', 'OR', 'NOT', 'true', 'false', 'null'],
                operators: ['+', '-', '*', '/', '%', '&', '==', '!=', '<', '>', '<=', '>=', '=', 'MATCHES', '~'],
                functions: ['CONCAT', 'SUBSTRING', 'LOOKUP', 'UPPER', 'LOWER', 'LENGTH', 'ROUND', 'ABS',
                           'MAX', 'MIN', 'IS_EMAIL', 'IS_LEI', 'IS_SWIFT', 'IS_PHONE', 'VALIDATE', 'EXTRACT'],

                tokenizer: {
                    root: [
                        [/[a-zA-Z_]\w*/, {
                            cases: {
                                '@keywords': 'keyword',
                                '@functions': 'support.function',
                                '@default': 'identifier'
                            }
                        }],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, { token: 'string.quote', bracket: '@open', next: '@string' }],
                        [/'([^'\\]|\\.)*$/, 'string.invalid'],
                        [/'/, { token: 'string.quote', bracket: '@open', next: '@stringSingle' }],
                        [/\/[^\/]+\//, 'regexp'],
                        [/r"[^"]+\"/, 'regexp'],
                        [/\d+\.?\d*/, 'number'],
                        [/#.*$/, 'comment'],
                        [/[+\-*/%&]/, 'operators'],
                        [/[=<>!]=?/, 'operators'],
                        [/~/, 'operators'],
                        [/MATCHES/, 'operators'],
                    ],

                    string: [
                        [/[^\\"]+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/"/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],

                    stringSingle: [
                        [/[^\\']+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/'/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],
                }
            });

            // Define DSL theme
            monaco.editor.defineTheme('dsl-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'keyword', foreground: 'c586c0' },
                    { token: 'support.function', foreground: 'dcdcaa' },
                    { token: 'string', foreground: 'ce9178' },
                    { token: 'number', foreground: 'b5cea8' },
                    { token: 'comment', foreground: '6a9955' },
                    { token: 'operators', foreground: 'd4d4d4' },
                    { token: 'regexp', foreground: 'd16969' },
                ],
                colors: {
                    'editor.background': '#1e1e1e',
                }
            });

            // Create editor instance
            editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                value: `# DSL IDE - Test your code here
# This editor has full Language Server Protocol support

# Example: KYC Risk Assessment Rule
risk_score = 0

IF Client.risk_rating == "HIGH" THEN
    risk_score = risk_score + 50
ELSE
    risk_score = risk_score + 10

IF Client.pep_status == true THEN
    risk_score = risk_score + 30

IF Client.aum_usd > 10000000 THEN
    risk_category = "PREMIUM"
ELSE
    risk_category = "STANDARD"

# Validation Rules
email_valid = IS_EMAIL(Client.email)
lei_valid = IS_LEI(Client.lei_code)

# Pattern Matching
swift_pattern = Client.swift_code ~ /^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$/

# Final Result
result = CONCAT("Risk Score: ", risk_score, " Category: ", risk_category)`,
                language: 'dsl',
                theme: 'dsl-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                wordWrap: 'on',
                suggestOnTriggerCharacters: true,
                quickSuggestions: true,
                autoClosingBrackets: 'always',
                autoClosingQuotes: 'always',
                formatOnPaste: true,
            });

            // Load sample attributes
            loadDataDictionary();

            // Auto-connect to LSP on startup (give editor time to fully initialize)
            setTimeout(() => {
                connectToLSP(true);  // true = auto-connect
            }, 1000);
        });

        // Connect to Language Server
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        let isConnecting = false;
        const MAX_RECONNECT_ATTEMPTS = 3;

        async function connectToLSP(isAutoConnect = false) {
            const button = document.getElementById('connect-lsp-btn');
            const statusIndicator = document.getElementById('status-indicator');
            const connectionText = document.getElementById('connection-text');

            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // If already connected or currently connecting, do nothing
            if ((lspConnection && lspConnection.readyState === WebSocket.OPEN) || isConnecting) {
                return;
            }

            isConnecting = true;

            try {
                button.disabled = true;
                button.innerHTML = '<span class="loading"></span> Connecting...';

                if (!isAutoConnect) {
                    addToOutput('console', 'ðŸ”„ Connecting to Language Server...');
                    reconnectAttempts = 0;  // Reset attempts for manual connection
                }

                // Connect to WebSocket LSP server
                lspConnection = new WebSocket('ws://localhost:3030');

                lspConnection.onopen = () => {
                    isConnecting = false;  // Reset connecting flag
                    reconnectAttempts = 0;  // Reset on successful connection
                    statusIndicator.classList.add('connected');
                    connectionText.textContent = 'LSP Online';
                    button.innerHTML = 'âœ… LSP Online';
                    button.disabled = true;
                    button.style.opacity = '0.7';
                    button.title = 'Language Server is connected';

                    if (!isAutoConnect) {
                        addToOutput('console', 'âœ… Language Server connected successfully');
                    }

                    // Initialize LSP session
                    initializeLSP();
                };

                lspConnection.onerror = (error) => {
                    isConnecting = false;  // Reset connecting flag
                    console.error('WebSocket error:', error);
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = 'âš ï¸ LSP Offline';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    if (isAutoConnect && reconnectAttempts === 0) {
                        // Only show this message once during auto-connect
                        addToOutput('console', 'ðŸ“ Language Server not available - IDE running in offline mode');
                    }
                };

                lspConnection.onclose = () => {
                    isConnecting = false;  // Reset connecting flag
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = 'ðŸ”„ Reconnect LSP';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    // Only auto-reconnect if we haven't exceeded attempts
                    if (isAutoConnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const backoffTime = Math.min(5000 * reconnectAttempts, 15000);  // Max 15 seconds
                        reconnectTimeout = setTimeout(() => {
                            console.log(`Auto-reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}...`);
                            connectToLSP(true);
                        }, backoffTime);
                    }
                };

                lspConnection.onmessage = (event) => {
                    handleLSPMessage(JSON.parse(event.data));
                };

            } catch (error) {
                isConnecting = false;  // Reset connecting flag
                if (!isAutoConnect) {
                    addToOutput('console', `âš ï¸ Could not connect to LSP: ${error.message}`);
                }
                button.innerHTML = 'ðŸ”„ Reconnect LSP';
                button.disabled = false;
                button.style.opacity = '1';
            }
        }

        let messageId = 1;

        function initializeLSP() {
            const initRequest = {
                jsonrpc: "2.0",
                id: messageId++,
                method: "initialize",
                params: {
                    processId: null,
                    capabilities: {
                        textDocument: {
                            synchronization: {
                                dynamicRegistration: false,
                                willSave: false,
                                willSaveWaitUntil: false,
                                didSave: true
                            },
                            completion: {
                                dynamicRegistration: false
                            },
                            hover: {
                                dynamicRegistration: false
                            }
                        }
                    },
                    rootUri: null,
                    workspaceFolders: null
                }
            };

            lspConnection.send(JSON.stringify(initRequest));
        }

        function handleLSPMessage(message) {
            if (message.method === 'textDocument/publishDiagnostics') {
                // Handle diagnostics
                const diagnostics = message.params.diagnostics;
                updateDiagnostics(diagnostics);
            } else if (message.result) {
                // Handle responses
                console.log('LSP Response:', message);
                if (message.id === 1) {
                    // Initialization complete
                    addToOutput('console', 'âœ“ LSP initialized successfully');
                    setupLSPFeatures();
                }
            }
        }

        function setupLSPFeatures() {
            // Send initialized notification
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "initialized",
                params: {}
            }));

            // Open current document in LSP
            const documentUri = "file:///main.dsl";
            const documentText = editor.getValue();
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "textDocument/didOpen",
                params: {
                    textDocument: {
                        uri: documentUri,
                        languageId: "dsl",
                        version: 1,
                        text: documentText
                    }
                }
            }));

            // Set up editor change listener with debouncing
            let changeTimeout = null;
            editor.onDidChangeModelContent((e) => {
                // Debounce the change notifications to avoid flooding the LSP
                if (changeTimeout) {
                    clearTimeout(changeTimeout);
                }
                changeTimeout = setTimeout(() => {
                    if (lspConnection && lspConnection.readyState === WebSocket.OPEN) {
                        lspConnection.send(JSON.stringify({
                            jsonrpc: "2.0",
                            method: "textDocument/didChange",
                            params: {
                                textDocument: {
                                    uri: documentUri,
                                    version: Date.now()
                                },
                                contentChanges: [{
                                    text: editor.getValue()
                                }]
                            }
                        }));
                    }
                }, 300);  // Wait 300ms after user stops typing
            });

            addToOutput('console', 'âœ“ LSP features activated');
        }

        function setupMockLSPFeatures() {
            // Add mock diagnostics
            const diagnostics = [
                { line: 5, severity: 'warning', message: 'Consider using constants for risk values' },
                { line: 18, severity: 'info', message: 'Email validation function available' },
            ];

            updateDiagnostics(diagnostics);

            // Set up code completion
            monaco.languages.registerCompletionItemProvider('dsl', {
                provideCompletionItems: (model, position) => {
                    const suggestions = [
                        {
                            label: 'Client.client_id',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.client_id',
                            detail: 'Unique client identifier',
                        },
                        {
                            label: 'Client.risk_rating',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.risk_rating',
                            detail: 'Risk rating level [LOW, MEDIUM, HIGH]',
                        },
                        {
                            label: 'IS_EMAIL',
                            kind: monaco.languages.CompletionItemKind.Function,
                            insertText: 'IS_EMAIL(${1:email})',
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                            detail: 'Validates email format',
                        },
                    ];

                    return { suggestions };
                }
            });

            // Set up hover provider
            monaco.languages.registerHoverProvider('dsl', {
                provideHover: (model, position) => {
                    const word = model.getWordAtPosition(position);
                    if (!word) return null;

                    const hoverInfo = {
                        'IS_EMAIL': 'Validates email format using RFC 5322 standard',
                        'IS_LEI': 'Validates Legal Entity Identifier (20 characters)',
                        'Client': 'KYC Client entity with validation attributes',
                    };

                    if (hoverInfo[word.word]) {
                        return {
                            contents: [
                                { value: `**${word.word}**` },
                                { value: hoverInfo[word.word] }
                            ]
                        };
                    }

                    return null;
                }
            });
        }

        function updateDiagnostics(diagnostics) {
            const problemsList = document.getElementById('output-content');
            const problemsTab = document.querySelector('[data-panel="problems"]');

            if (diagnostics.length > 0) {
                problemsTab.textContent = `Problems (${diagnostics.length})`;
            } else {
                problemsTab.textContent = 'Problems';
            }

            // Store diagnostics
            diagnosticsMap.clear();
            diagnostics.forEach(d => diagnosticsMap.set(d.line, d));

            // Update Monaco markers
            const markers = diagnostics.map(d => ({
                startLineNumber: d.line,
                startColumn: 1,
                endLineNumber: d.line,
                endColumn: 1000,
                message: d.message,
                severity: d.severity === 'error' ? monaco.MarkerSeverity.Error :
                         d.severity === 'warning' ? monaco.MarkerSeverity.Warning :
                         monaco.MarkerSeverity.Info
            }));

            monaco.editor.setModelMarkers(editor.getModel(), 'dsl', markers);
        }

        async function runCode() {
            const code = editor.getValue();
            const button = document.getElementById('run-btn');

            button.disabled = true;
            button.innerHTML = '<span class="loading"></span> Running...';

            try {
                // Check if running in Tauri environment
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    // Call Tauri backend to test the rule
                    const result = await window.__TAURI__.invoke('test_rule', {
                        dslText: code
                    });

                    addToOutput('output', `âœ“ Execution successful:\n${JSON.stringify(result, null, 2)}`);
                } else {
                    // Fallback for browser-only mode (simulate execution)
                    addToOutput('output', 'âš ï¸ Running in browser mode (no Tauri backend)');

                    // Simple client-side validation/simulation
                    const lines = code.split('\n').filter(l => l.trim());
                    if (lines.length > 0) {
                        addToOutput('output', `âœ“ Parsed ${lines.length} lines of DSL code`);

                        // Simulate some basic checks
                        const hasIf = code.includes('IF');
                        const hasThen = code.includes('THEN');

                        if (hasIf && hasThen) {
                            addToOutput('output', 'âœ“ Valid IF-THEN structure detected');
                        } else if (hasIf && !hasThen) {
                            addToOutput('output', 'âš ï¸ Warning: IF without THEN');
                        }

                        // Check for common DSL patterns
                        if (code.includes('Client.')) {
                            addToOutput('output', 'âœ“ Client attributes referenced');
                        }
                        if (code.match(/IS_[A-Z]+/)) {
                            addToOutput('output', 'âœ“ Validation functions used');
                        }
                    } else {
                        addToOutput('output', 'âš ï¸ No code to execute');
                    }
                }

            } catch (error) {
                addToOutput('output', `âŒ Execution failed:\n${error}`);
            }

            button.disabled = false;
            button.innerHTML = 'â–¶ Run Code';
        }

        async function validateCode() {
            const code = editor.getValue();
            addToOutput('output', 'ðŸ” Validating code...');

            // Simulate validation
            const lines = code.split('\n');
            const diagnostics = [];

            lines.forEach((line, index) => {
                if (line.includes('IF') && !line.includes('THEN')) {
                    diagnostics.push({
                        line: index + 1,
                        severity: 'error',
                        message: 'IF statement missing THEN clause'
                    });
                }
            });

            updateDiagnostics(diagnostics);

            if (diagnostics.length === 0) {
                addToOutput('output', 'âœ“ Validation successful - no issues found');
            } else {
                addToOutput('output', `âš  Found ${diagnostics.length} issue(s)`);
            }
        }

        function formatCode() {
            // Simple formatting - preserves line structure
            let code = editor.getValue();

            // Process line by line to preserve structure
            const lines = code.split('\n');
            const formattedLines = lines.map(line => {
                // Skip empty lines
                if (line.trim() === '') {
                    return line;
                }

                // Preserve leading whitespace (indentation)
                const leadingWhitespace = line.match(/^(\s*)/)[1];
                let trimmedLine = line.trim();

                // Skip comments (but preserve indentation)
                if (trimmedLine.startsWith('#')) {
                    return line;
                }

                // Add spacing around operators
                let formatted = trimmedLine;

                // Add space around comparison and assignment operators
                formatted = formatted.replace(/([=<>!]+)/g, ' $1 ');
                formatted = formatted.replace(/([+\-*/%])/g, ' $1 ');

                // Add space around logical operators
                formatted = formatted.replace(/\b(AND|OR)\b/g, ' $1 ');

                // Clean up spaces around parentheses and commas
                formatted = formatted.replace(/\s*\(\s*/g, '(');
                formatted = formatted.replace(/\s*\)\s*/g, ')');
                formatted = formatted.replace(/\s*,\s*/g, ', ');

                // Clean up spaces around dots (for property access)
                formatted = formatted.replace(/\s*\.\s*/g, '.');

                // Fix multiple spaces that may have been created
                formatted = formatted.replace(/\s{2,}/g, ' ');

                // Return with original indentation preserved
                return leadingWhitespace + formatted.trim();
            });

            // Rejoin with line breaks preserved
            const formattedCode = formattedLines.join('\n');

            editor.setValue(formattedCode);
            addToOutput('console', 'âœ“ Code formatted');
        }

        async function explainCode() {
            const code = editor.getValue();
            addToOutput('output', 'ðŸ¤– AI is analyzing your code...');

            // Simulate AI explanation
            setTimeout(() => {
                const explanation = `This DSL code implements a KYC risk assessment system that:
1. Calculates a risk score based on client attributes
2. Validates email and LEI formats
3. Performs pattern matching on SWIFT codes
4. Categorizes clients as PREMIUM or STANDARD based on AUM
5. Returns a formatted result string with the risk assessment`;

                addToOutput('output', `AI Explanation:\n\n${explanation}`);
            }, 1500);
        }

        function loadDataDictionary() {
            const attributes = [
                { name: 'Client.client_id', type: 'String' },
                { name: 'Client.legal_entity_name', type: 'String' },
                { name: 'Client.risk_rating', type: 'Enum' },
                { name: 'Client.aum_usd', type: 'Number' },
                { name: 'Client.pep_status', type: 'Boolean' },
                { name: 'Client.email', type: 'String' },
                { name: 'Client.lei_code', type: 'String' },
            ];

            const functions = [
                { name: 'IS_EMAIL', type: 'Validation' },
                { name: 'IS_LEI', type: 'Validation' },
                { name: 'IS_SWIFT', type: 'Validation' },
                { name: 'CONCAT', type: 'String' },
                { name: 'LOOKUP', type: 'Data' },
            ];

            const attrList = document.getElementById('attribute-list');
            attributes.forEach(attr => {
                const li = document.createElement('li');
                li.className = 'attribute-item';
                li.innerHTML = `${attr.name} <span class="attribute-type">${attr.type}</span>`;
                li.onclick = () => insertText(attr.name);
                attrList.appendChild(li);
            });

            const funcList = document.getElementById('function-list');
            functions.forEach(func => {
                const li = document.createElement('li');
                li.className = 'attribute-item';
                li.innerHTML = `${func.name}() <span class="attribute-type">${func.type}</span>`;
                li.onclick = () => insertText(`${func.name}()`);
                funcList.appendChild(li);
            });
        }

        function insertText(text) {
            const selection = editor.getSelection();
            const id = { major: 1, minor: 1 };
            const op = { identifier: id, range: selection, text: text, forceMoveMarkers: true };
            editor.executeEdits("insert", [op]);
            editor.focus();
        }

        function addToOutput(panel, message) {
            const outputContent = document.getElementById('output-content');
            const timestamp = new Date().toLocaleTimeString();
            outputContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            outputContent.scrollTop = outputContent.scrollHeight;

            // Switch to the appropriate tab
            document.querySelectorAll('.output-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.panel === panel);
            });
        }

        function clearOutput() {
            document.getElementById('output-content').innerHTML = '';
        }

        // Tab switching
        document.querySelectorAll('.output-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.output-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // In production, this would switch between different output panels
                const panel = tab.dataset.panel;
                if (panel === 'problems') {
                    showProblems();
                } else if (panel === 'console') {
                    showConsole();
                } else {
                    showOutput();
                }
            });
        });

        function showProblems() {
            const outputContent = document.getElementById('output-content');
            outputContent.innerHTML = '<ul class="diagnostics-list">';

            diagnosticsMap.forEach((diag, line) => {
                outputContent.innerHTML += `
                    <li class="diagnostic-item ${diag.severity}" onclick="goToLine(${line})">
                        Line ${line}: ${diag.message}
                    </li>
                `;
            });

            outputContent.innerHTML += '</ul>';
        }

        function showConsole() {
            // Console already shows in main output
        }

        function showOutput() {
            // Output already shows in main output
        }

        window.goToLine = function(line) {
            editor.revealLineInCenter(line);
            editor.setPosition({ lineNumber: line, column: 1 });
            editor.focus();
        };

        // Make functions available globally
        window.runCode = runCode;
        window.validateCode = validateCode;
        window.formatCode = formatCode;
        window.explainCode = explainCode;
        window.connectToLSP = connectToLSP;
        window.clearOutput = clearOutput;
    </script>
</body>
</html>