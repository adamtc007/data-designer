<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DSL IDE with Language Server</title>
    <script type="module">
        // Import Tauri API
        import { invoke } from '@tauri-apps/api/core';
        // Make it globally available
        window.__TAURI_INVOKE__ = invoke;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Monaco', 'Consolas', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 400;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #f44336;
        }

        .status-indicator.connected {
            background: #4caf50;
        }

        .main-container {
            flex: 1;
            display: flex;
            height: calc(100vh - 60px);
            position: relative;
        }

        .sidebar {
            width: 250px;
            min-width: 150px;
            max-width: 500px;
            background: #252526;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }

        .splitter-vertical {
            width: 5px;
            background: #3e3e42;
            cursor: col-resize;
            position: relative;
            user-select: none;
        }

        .splitter-vertical:hover {
            background: #007acc;
        }

        .splitter-vertical.dragging {
            background: #007acc;
        }

        .splitter-horizontal {
            height: 5px;
            background: #3e3e42;
            cursor: row-resize;
            user-select: none;
        }

        .splitter-horizontal:hover {
            background: #007acc;
        }

        .splitter-horizontal.dragging {
            background: #007acc;
        }

        .sidebar h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            color: #969696;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 400px;
            overflow: hidden;
        }

        #monaco-editor {
            flex: 1;
            min-height: 200px;
        }

        .tabs {
            background: #2d2d30;
            display: flex;
            border-bottom: 1px solid #3e3e42;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            background: #2d2d30;
            color: #969696;
            transition: all 0.2s;
        }

        .tab:hover {
            background: #3e3e42;
        }

        .tab.active {
            background: #1e1e1e;
            color: #d4d4d4;
            border-bottom: 2px solid #007acc;
        }

        #monaco-editor {
            flex: 1;
            width: 100%;
        }

        .output-panel {
            height: 200px;
            min-height: 100px;
            background: #1e1e1e;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .output-header {
            background: #2d2d30;
            padding: 8px 15px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .output-tabs {
            display: flex;
            gap: 15px;
        }

        .output-tab {
            cursor: pointer;
            color: #969696;
            font-size: 14px;
            padding: 2px 5px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .output-tab:hover {
            color: #d4d4d4;
        }

        .output-tab.active {
            color: #d4d4d4;
            border-bottom-color: #007acc;
        }

        .output-content {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
        }

        .diagnostics-list {
            list-style: none;
        }

        .diagnostic-item {
            padding: 5px;
            margin-bottom: 5px;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .diagnostic-item:hover {
            background: #2d2d30;
        }

        .diagnostic-item.error {
            border-left-color: #f44336;
            color: #f48771;
        }

        .diagnostic-item.warning {
            border-left-color: #ffeb3b;
            color: #dcdcaa;
        }

        .diagnostic-item.info {
            border-left-color: #2196f3;
            color: #9cdcfe;
        }

        /* AI Agent Chat Styles */
        .agent-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #1e1e1e;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 200px;
        }

        .chat-message {
            padding: 10px 12px;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .chat-message.user {
            align-self: flex-end;
            background: #007acc;
            color: white;
        }

        .chat-message.assistant {
            align-self: flex-start;
            background: #2d2d30;
            color: #cccccc;
            border: 1px solid #3e3e42;
        }

        .chat-message.system {
            align-self: center;
            background: #3e3e42;
            color: #969696;
            font-size: 0.9em;
            max-width: 90%;
        }

        .chat-input-container {
            padding: 12px;
            border-top: 1px solid #3e3e42;
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            color: #cccccc;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        .chat-input:focus {
            outline: none;
            border-color: #007acc;
        }

        .chat-send-btn {
            padding: 8px 16px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-send-btn:hover:not(:disabled) {
            background: #1a86d9;
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .context-indicator {
            padding: 4px 8px;
            background: #3e3e42;
            color: #969696;
            font-size: 11px;
            border-radius: 3px;
            margin-bottom: 8px;
        }

        .message-code {
            background: #1e1e1e;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .btn {
            padding: 5px 15px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #5a5a5a;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #3c3c3c;
        }

        .btn.secondary:hover {
            background: #505050;
        }

        .test-results {
            padding: 10px;
            background: #2d2d30;
            border-radius: 3px;
            margin-top: 10px;
        }

        .test-results.success {
            border-left: 3px solid #4caf50;
        }

        .test-results.error {
            border-left: 3px solid #f44336;
        }

        .attribute-list {
            list-style: none;
        }

        .attribute-item {
            padding: 5px 10px;
            margin-bottom: 3px;
            background: #2d2d30;
            border-radius: 3px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .attribute-item:hover {
            background: #3e3e42;
        }

        .attribute-type {
            color: #4ec9b0;
            font-size: 11px;
            margin-left: 5px;
        }

        .loading {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f3f3f3;
            border-radius: 50%;
            border-top: 2px solid #007acc;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">
</head>
<body>
    <div class="header">
        <h1>🚀 DSL IDE - Language Server Enabled</h1>
        <div class="connection-status">
            <span id="connection-text" style="white-space: nowrap;">LSP Offline</span>
            <div id="status-indicator" class="status-indicator"></div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h2>Data Dictionary</h2>
                <button class="btn" style="padding: 4px 8px; font-size: 12px;" onclick="showCreateAttributeDialog()">
                    + New
                </button>
            </div>
            <ul id="attribute-list" class="attribute-list">
                <!-- Attributes will be loaded here -->
            </ul>

            <h2 style="margin-top: 20px;">Functions</h2>
            <ul id="function-list" class="attribute-list">
                <!-- Functions will be loaded here -->
            </ul>
        </div>

        <div class="splitter-vertical" id="splitter-vertical"></div>

        <div class="editor-container" id="editor-container">
            <div class="tabs" id="editor-tabs">
                <div class="tab active" data-file="no-rule" id="main-tab">No Rule Selected</div>
            </div>

            <div class="toolbar">
                <button class="btn" id="run-btn" onclick="runCode()">
                    ▶ Run Code
                </button>
                <button class="btn secondary" id="validate-btn" onclick="validateCode()">
                    ✓ Validate
                </button>
                <button class="btn secondary" id="format-btn" onclick="formatCode()">
                    ⚡ Format
                </button>
                <button class="btn secondary" id="settings-btn" onclick="showSettings()">
                    ⚙ Settings
                </button>
                <button class="btn secondary" id="ai-explain-btn" onclick="explainCode()">
                    🤖 AI Explain
                </button>
                <button class="btn secondary" id="find-similar-btn" onclick="findSimilarRules()">
                    🔍 Find Similar
                </button>
                <button class="btn secondary" id="show-ast-btn" onclick="showAST()">
                    🌳 Show AST
                </button>
                <button class="btn secondary" id="schema-viewer-btn" onclick="openSchemaViewer()">
                    🗄️ Schema View
                </button>
                <button class="btn secondary" id="connect-lsp-btn" onclick="connectToLSP()" style="opacity: 0.7;" title="LSP will auto-connect on page load">
                    🔌 LSP Status
                </button>
            </div>

            <div id="monaco-editor"></div>

            <div class="splitter-horizontal" id="splitter-horizontal"></div>

            <div class="output-panel" id="output-panel">
                <div class="output-header">
                    <div class="output-tabs">
                        <div class="output-tab active" data-panel="output">Output</div>
                        <div class="output-tab" data-panel="problems">Problems</div>
                        <div class="output-tab" data-panel="agent">AI Agent 🤖</div>
                        <div class="output-tab" data-panel="rules">Rules Catalogue 📋</div>
                        <div class="output-tab" data-panel="ast">AST View 🌳</div>
                    </div>
                    <button class="btn secondary" style="padding: 3px 10px; font-size: 12px;" onclick="clearOutput()">Clear</button>
                </div>
                <div class="output-content" id="output-content">
                    <!-- Output will appear here -->
                </div>

                <!-- AST Panel -->
                <div class="output-panel-content" id="ast-panel" style="display: none;">
                    <div style="padding: 20px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <button class="btn secondary" onclick="refreshAST()">🔄 Refresh</button>
                            <button class="btn secondary" onclick="exportAST('json')">📋 Export JSON</button>
                            <button class="btn secondary" onclick="exportAST('dot')">📊 Export DOT</button>
                            <button class="btn secondary" onclick="copyAST('text')">📝 Copy Tree</button>
                        </div>

                        <div class="ast-tabs" style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 1px solid #3e3e42;">
                            <button class="ast-view-tab active" data-view="tree" onclick="switchASTView('tree')">Tree View</button>
                            <button class="ast-view-tab" data-view="json" onclick="switchASTView('json')">JSON</button>
                            <button class="ast-view-tab" data-view="dot" onclick="switchASTView('dot')">DOT Graph</button>
                        </div>

                        <div id="ast-tree-view" class="ast-view">
                            <pre id="ast-tree-content" style="color: #d4d4d4; font-family: 'Consolas', 'Monaco', monospace;"></pre>
                        </div>

                        <div id="ast-json-view" class="ast-view" style="display: none;">
                            <pre id="ast-json-content" style="color: #d4d4d4; font-family: 'Consolas', 'Monaco', monospace;"></pre>
                        </div>

                        <div id="ast-dot-view" class="ast-view" style="display: none;">
                            <pre id="ast-dot-content" style="color: #d4d4d4; font-family: 'Consolas', 'Monaco', monospace;"></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    <!-- Data Dictionary Integration -->
    <script src="data-dictionary.js"></script>
    <script type="module">
        let editor;
        let lspConnection = null;
        let diagnosticsMap = new Map();

        // Initialize Monaco Editor
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });

        require(['vs/editor/editor.main'], function() {
            // Register DSL language
            monaco.languages.register({ id: 'dsl' });

            // Define DSL syntax highlighting
            monaco.languages.setMonarchTokensProvider('dsl', {
                keywords: ['IF', 'THEN', 'ELSE', 'AND', 'OR', 'NOT', 'true', 'false', 'null'],
                operators: ['+', '-', '*', '/', '%', '&', '==', '!=', '<', '>', '<=', '>=', '=', 'MATCHES', '~'],
                functions: ['CONCAT', 'SUBSTRING', 'LOOKUP', 'UPPER', 'LOWER', 'LENGTH', 'ROUND', 'ABS',
                           'MAX', 'MIN', 'IS_EMAIL', 'IS_LEI', 'IS_SWIFT', 'IS_PHONE', 'VALIDATE', 'EXTRACT'],

                tokenizer: {
                    root: [
                        [/[a-zA-Z_]\w*/, {
                            cases: {
                                '@keywords': 'keyword',
                                '@functions': 'support.function',
                                '@default': 'identifier'
                            }
                        }],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, { token: 'string.quote', bracket: '@open', next: '@string' }],
                        [/'([^'\\]|\\.)*$/, 'string.invalid'],
                        [/'/, { token: 'string.quote', bracket: '@open', next: '@stringSingle' }],
                        [/\/[^\/]+\//, 'regexp'],
                        [/r"[^"]+\"/, 'regexp'],
                        [/\d+\.?\d*/, 'number'],
                        [/#.*$/, 'comment'],
                        [/[+\-*/%&]/, 'operators'],
                        [/[=<>!]=?/, 'operators'],
                        [/~/, 'operators'],
                        [/MATCHES/, 'operators'],
                    ],

                    string: [
                        [/[^\\"]+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/"/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],

                    stringSingle: [
                        [/[^\\']+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/'/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],
                }
            });

            // Define DSL theme
            monaco.editor.defineTheme('dsl-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'keyword', foreground: 'c586c0' },
                    { token: 'support.function', foreground: 'dcdcaa' },
                    { token: 'string', foreground: 'ce9178' },
                    { token: 'number', foreground: 'b5cea8' },
                    { token: 'comment', foreground: '6a9955' },
                    { token: 'operators', foreground: 'd4d4d4' },
                    { token: 'regexp', foreground: 'd16969' },
                ],
                colors: {
                    'editor.background': '#1e1e1e',
                }
            });

            // Create editor instance and expose globally
            editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                value: `// No rule selected
//
// Click "+ New" next to Data Dictionary to create a new derived attribute
// Or select an existing rule from the sidebar
//
// Once you create or select a rule:
// - The rule name will appear in the tab above
// - Test data will load in the panel below
// - You can start writing your business logic

IF Client.pep_status == true THEN
    risk_score = risk_score + 30

IF Client.aum_usd > 10000000 THEN
    risk_category = "PREMIUM"
ELSE
    risk_category = "STANDARD"

# Validation Rules
email_valid = IS_EMAIL(Client.email)
lei_valid = IS_LEI(Client.lei_code)

# Pattern Matching
swift_pattern = Client.swift_code ~ /^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$/

# Final Result
result = CONCAT("Risk Score: ", risk_score, " Category: ", risk_category)`,
                language: 'dsl',
                theme: 'dsl-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                wordWrap: 'on',
                suggestOnTriggerCharacters: true,
                quickSuggestions: true,
                autoClosingBrackets: 'always',
                autoClosingQuotes: 'always',
                formatOnPaste: true,
            });

            // Expose editor globally for easier access
            window.editor = editor;

            // Load sample attributes
            loadDataDictionary();

            // Register hover provider after editor is ready
            setTimeout(() => {
                console.log('Registering hover provider...');
                registerHoverProvider();
            }, 100);

            // Initialize LSP status display
            console.log('Initializing LSP status display...');
            const statusIndicator = document.getElementById('status-indicator');
            const connectionText = document.getElementById('connection-text');
            console.log('Connection text element:', connectionText);
            console.log('Current text:', connectionText ? connectionText.textContent : 'Element not found');
            if (statusIndicator) statusIndicator.classList.remove('connected');
            if (connectionText) {
                connectionText.textContent = 'LSP Offline';
                console.log('Set connection text to: LSP Offline');

                // Check if something overwrites it
                setTimeout(() => {
                    console.log('After 1 second, connection text is:', connectionText.textContent);
                    console.log('Element innerHTML:', connectionText.innerHTML);
                    console.log('Element innerText:', connectionText.innerText);
                    console.log('Computed style display:', window.getComputedStyle(connectionText).display);
                    console.log('Computed style visibility:', window.getComputedStyle(connectionText).visibility);
                    console.log('Computed style width:', window.getComputedStyle(connectionText).width);
                    console.log('Parent element:', connectionText.parentElement);
                    console.log('Parent innerHTML:', connectionText.parentElement.innerHTML);

                    // Check if there are other elements with similar text
                    const allElements = document.body.querySelectorAll('*');
                    allElements.forEach(el => {
                        if (el.textContent && el.textContent.includes('connection') && !el.textContent.includes('LSP')) {
                            console.warn('Found element with "connection":', el, 'Text:', el.textContent.substring(0, 50));
                        }
                    });

                    if (connectionText.textContent !== 'LSP Offline' && connectionText.textContent !== 'LSP Online') {
                        console.warn('Something changed the text to:', connectionText.textContent);
                        // Force it back
                        connectionText.textContent = 'LSP Offline';
                    }
                }, 1000);
            } else {
                console.error('Could not find connection-text element!');
            }

            // Auto-connect to LSP on startup (give editor time to fully initialize)
            // Disabled for now to prevent jitter - user can manually connect
            // setTimeout(() => {
            //     connectToLSP(true);  // true = auto-connect
            // }, 1000);
        });

        // Connect to Language Server
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        let isConnecting = false;
        const MAX_RECONNECT_ATTEMPTS = 3;

        async function connectToLSP(isAutoConnect = false) {
            console.log('connectToLSP called, isAutoConnect:', isAutoConnect);
            const button = document.getElementById('connect-lsp-btn');
            const statusIndicator = document.getElementById('status-indicator');
            const connectionText = document.getElementById('connection-text');
            console.log('Found elements:', {button, statusIndicator, connectionText});

            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // If already connected or currently connecting, do nothing
            if ((lspConnection && lspConnection.readyState === WebSocket.OPEN) || isConnecting) {
                return;
            }

            isConnecting = true;

            try {
                button.disabled = true;
                button.innerHTML = '<span class="loading"></span> Connecting...';

                if (!isAutoConnect) {
                    addToOutput('console', '🔄 Connecting to Language Server...');
                    reconnectAttempts = 0;  // Reset attempts for manual connection
                }

                // Connect to WebSocket LSP server
                lspConnection = new WebSocket('ws://localhost:3030');
                console.log('WebSocket created, readyState:', lspConnection.readyState);

                lspConnection.onopen = () => {
                    console.log('*** WEBSOCKET ONOPEN CALLED ***');
                    console.log('WebSocket connected!');
                    isConnecting = false;  // Reset connecting flag
                    reconnectAttempts = 0;  // Reset on successful connection

                    // Double-check we have the right elements
                    const statusCheck = document.getElementById('status-indicator');
                    const textCheck = document.getElementById('connection-text');
                    console.log('Element check - statusIndicator:', statusCheck);
                    console.log('Element check - connectionText:', textCheck);
                    console.log('Are they the same?', statusIndicator === statusCheck, connectionText === textCheck);

                    console.log('Updating UI - before:', connectionText.textContent);
                    console.log('Direct check before:', document.getElementById('connection-text').textContent);

                    statusIndicator.classList.add('connected');
                    connectionText.textContent = 'LSP Online';

                    console.log('Updating UI - after:', connectionText.textContent);
                    console.log('Direct check after:', document.getElementById('connection-text').textContent);

                    // Force a style update
                    connectionText.style.color = '#4caf50';

                    // Check if it stays after a delay
                    setTimeout(() => {
                        // Check for duplicate IDs
                        const allConnectionTexts = document.querySelectorAll('#connection-text');
                        console.log('Number of elements with id="connection-text":', allConnectionTexts.length);
                        allConnectionTexts.forEach((elem, index) => {
                            console.log(`Element ${index}:`, elem, 'Text:', elem.textContent, 'Parent:', elem.parentElement);
                        });

                        console.log('After 100ms, text is:', connectionText.textContent);
                        console.log('After 100ms, color is:', connectionText.style.color);
                        console.log('After 100ms, element still exists?', document.getElementById('connection-text'));

                        // Force it again just to be sure
                        const elem = document.getElementById('connection-text');
                        if (elem && elem.textContent !== 'LSP Online') {
                            console.warn('Text was changed! Setting it back...');
                            elem.textContent = 'LSP Online';
                            elem.style.color = '#4caf50';

                            // Check again after setting
                            setTimeout(() => {
                                console.log('After forcing update, text is now:', elem.textContent);
                                if (elem.textContent !== 'LSP Online') {
                                    console.error('Something is actively reverting the text!');
                                }
                            }, 10);
                        }
                    }, 100);

                    button.innerHTML = '✅ LSP Online';
                    button.disabled = true;
                    button.style.opacity = '0.7';
                    button.title = 'Language Server is connected';

                    if (!isAutoConnect) {
                        addToOutput('console', '✅ Language Server connected successfully');
                    }

                    // Initialize LSP session
                    initializeLSP();
                };

                lspConnection.onerror = (error) => {
                    isConnecting = false;  // Reset connecting flag
                    console.error('WebSocket error:', error);
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = '⚠️ LSP Offline';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    if (isAutoConnect && reconnectAttempts === 0) {
                        // Only show this message once during auto-connect
                        addToOutput('console', '📝 Language Server not available - IDE running in offline mode');
                    }
                };

                lspConnection.onclose = () => {
                    isConnecting = false;  // Reset connecting flag
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'LSP Offline';
                    button.innerHTML = '🔄 Reconnect LSP';
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.title = 'Click to reconnect to Language Server';

                    // Disable auto-reconnect to prevent jitter
                    // Will fix the connection issue first
                    /*
                    if (isAutoConnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const backoffTime = Math.min(5000 * reconnectAttempts, 15000);  // Max 15 seconds
                        reconnectTimeout = setTimeout(() => {
                            console.log(`Auto-reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}...`);
                            connectToLSP(true);
                        }, backoffTime);
                    }
                    */
                };

                lspConnection.onmessage = (event) => {
                    console.log('Raw LSP message received:', event.data);
                    try {
                        let messageData = event.data;

                        // Check if it's already JSON or needs parsing
                        if (typeof messageData === 'string') {
                            // If it starts with Content-Length, extract the JSON part
                            if (messageData.startsWith('Content-Length:')) {
                                const parts = messageData.split('\r\n\r\n');
                                if (parts.length > 1) {
                                    messageData = parts[1]; // Get the JSON part after the headers
                                    console.log('Extracted JSON from LSP message:', messageData);
                                } else {
                                    console.log('Could not extract JSON from LSP protocol message');
                                    return;
                                }
                            }

                            const parsed = JSON.parse(messageData);

                            // Check for JSON-RPC errors
                            if (parsed.error) {
                                console.error('LSP Error:', parsed.error);
                                if (parsed.error.code === -32700) {
                                    console.error('Parse error - the LSP server could not parse our message');
                                    // Despite the error, the connection is established
                                    console.log('Note: Connection is still active despite parse error');
                                }
                                return;
                            }

                            handleLSPMessage(parsed);
                        } else {
                            handleLSPMessage(messageData);
                        }
                    } catch (error) {
                        console.error('Failed to parse LSP message:', error, 'Data:', event.data);
                    }
                };

            } catch (error) {
                isConnecting = false;  // Reset connecting flag
                if (!isAutoConnect) {
                    addToOutput('console', `⚠️ Could not connect to LSP: ${error.message}`);
                }
                button.innerHTML = '🔄 Reconnect LSP';
                button.disabled = false;
                button.style.opacity = '1';
            }
        }

        let messageId = 1;

        function initializeLSP() {
            console.log('Sending LSP initialize request');
            const initRequest = {
                jsonrpc: "2.0",
                id: messageId++,
                method: "initialize",
                params: {
                    processId: null,
                    capabilities: {
                        textDocument: {
                            synchronization: {
                                dynamicRegistration: false,
                                willSave: false,
                                willSaveWaitUntil: false,
                                didSave: true
                            },
                            completion: {
                                dynamicRegistration: false
                            },
                            hover: {
                                dynamicRegistration: false
                            }
                        }
                    },
                    rootUri: null,
                    workspaceFolders: null
                }
            };

            const message = JSON.stringify(initRequest);
            console.log('Sending message:', message);

            try {
                lspConnection.send(message);
            } catch (error) {
                console.error('Failed to send initialize request:', error);
            }
        }

        function handleLSPMessage(message) {
            if (message.method === 'textDocument/publishDiagnostics') {
                // Handle diagnostics
                const diagnostics = message.params.diagnostics;
                updateDiagnostics(diagnostics);
            } else if (message.result) {
                // Handle responses
                console.log('LSP Response:', message);
                if (message.id === 1) {
                    // Initialization complete
                    addToOutput('console', '✓ LSP initialized successfully');
                    setupLSPFeatures();
                }
            }
        }

        function setupLSPFeatures() {
            // Send initialized notification
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "initialized",
                params: {}
            }));

            // Open current document in LSP
            const documentUri = "file:///main.dsl";
            const documentText = editor.getValue();
            lspConnection.send(JSON.stringify({
                jsonrpc: "2.0",
                method: "textDocument/didOpen",
                params: {
                    textDocument: {
                        uri: documentUri,
                        languageId: "dsl",
                        version: 1,
                        text: documentText
                    }
                }
            }));

            // Set up editor change listener with debouncing
            let changeTimeout = null;
            editor.onDidChangeModelContent((e) => {
                // Save current rule content if we're editing a derived attribute
                if (window.currentAttributeName && window.currentEditMode === 'derived_attribute') {
                    if (!window.attributeRules) window.attributeRules = {};
                    window.attributeRules[window.currentAttributeName] = editor.getValue();
                }

                // Debounce the change notifications to avoid flooding the LSP
                if (changeTimeout) {
                    clearTimeout(changeTimeout);
                }
                changeTimeout = setTimeout(() => {
                    if (lspConnection && lspConnection.readyState === WebSocket.OPEN) {
                        lspConnection.send(JSON.stringify({
                            jsonrpc: "2.0",
                            method: "textDocument/didChange",
                            params: {
                                textDocument: {
                                    uri: documentUri,
                                    version: Date.now()
                                },
                                contentChanges: [{
                                    text: editor.getValue()
                                }]
                            }
                        }));
                    }
                }, 300);  // Wait 300ms after user stops typing
            });

            addToOutput('console', '✓ LSP features activated');
        }

        function setupMockLSPFeatures() {
            // Add mock diagnostics
            const diagnostics = [
                { line: 5, severity: 'warning', message: 'Consider using constants for risk values' },
                { line: 18, severity: 'info', message: 'Email validation function available' },
            ];

            updateDiagnostics(diagnostics);

            // Set up code completion
            monaco.languages.registerCompletionItemProvider('dsl', {
                provideCompletionItems: (model, position) => {
                    const suggestions = [
                        {
                            label: 'Client.client_id',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.client_id',
                            detail: 'Unique client identifier',
                        },
                        {
                            label: 'Client.risk_rating',
                            kind: monaco.languages.CompletionItemKind.Field,
                            insertText: 'Client.risk_rating',
                            detail: 'Risk rating level [LOW, MEDIUM, HIGH]',
                        },
                        {
                            label: 'IS_EMAIL',
                            kind: monaco.languages.CompletionItemKind.Function,
                            insertText: 'IS_EMAIL(${1:email})',
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                            detail: 'Validates email format',
                        },
                    ];

                    return { suggestions };
                }
            });
        }

        function registerHoverProvider() {
            console.log('Actually registering hover provider now...');
            // Set up hover provider with enhanced attribute detection
            const disposable = monaco.languages.registerHoverProvider('dsl', {
                provideHover: (model, position) => {
                    console.log('Hover triggered at', position);
                    const line = model.getLineContent(position.lineNumber);
                    const offset = position.column - 1;

                    // Find the full attribute path (e.g., Client.client_id)
                    let start = offset;
                    let end = offset;

                    // Move start backwards to find beginning of identifier
                    while (start > 0 && /[\w.]/.test(line[start - 1])) {
                        start--;
                    }

                    // Move end forwards to find end of identifier
                    while (end < line.length && /[\w.]/.test(line[end])) {
                        end++;
                    }

                    const fullPath = line.substring(start, end);
                    console.log('Full path extracted:', fullPath);

                    // Enhanced hover information with SQL types
                    const hoverInfo = {
                        'IS_EMAIL': '**Function**: Validates email format\n\n**Pattern**: RFC 5322 standard\n**Returns**: Boolean',
                        'IS_LEI': '**Function**: Validates Legal Entity Identifier\n\n**Pattern**: 20 alphanumeric characters\n**Returns**: Boolean',
                        'IS_SWIFT': '**Function**: Validates SWIFT/BIC code\n\n**Pattern**: 8 or 11 characters\n**Returns**: Boolean',
                        'Client': '**Entity**: KYC Client\n\n**Description**: Client information for KYC validation\n**Attributes**: client_id, legal_entity_name, lei_code, email, risk_rating, aum_usd, kyc_status, pep_status',
                        'Client.client_id': '**Attribute**: client_id\n\n**SQL Type**: `VARCHAR(50) PRIMARY KEY`\n**Rust Type**: `String`\n**Format**: `XXX-999`\n**Pattern**: `^[A-Z]{3}-\\d{3,}$`\n**Required**: ✅ Yes',
                        'Client.legal_entity_name': '**Attribute**: legal_entity_name\n\n**SQL Type**: `VARCHAR(255) NOT NULL`\n**Rust Type**: `String`\n**Required**: ✅ Yes',
                        'Client.lei_code': '**Attribute**: lei_code\n\n**SQL Type**: `CHAR(20)`\n**Rust Type**: `String`\n**Format**: `XXXXXXXXXXXXXXXXXXXX`\n**Pattern**: `^[A-Z0-9]{20}$`\n**Required**: ❌ No',
                        'Client.email': '**Attribute**: email\n\n**SQL Type**: `VARCHAR(255) NOT NULL`\n**Rust Type**: `String`\n**Format**: `xxx@xxx.xxx`\n**Validation**: `IS_EMAIL()`\n**Required**: ✅ Yes',
                        'Client.risk_rating': '**Attribute**: risk_rating\n\n**SQL Type**: `ENUM(\'LOW\', \'MEDIUM\', \'HIGH\') NOT NULL`\n**Rust Type**: `RiskLevel`\n**Domain**: RiskLevel\n**Values**: LOW, MEDIUM, HIGH\n**Required**: ✅ Yes',
                        'Client.aum_usd': '**Attribute**: aum_usd\n\n**SQL Type**: `DECIMAL(18,2)`\n**Rust Type**: `rust_decimal::Decimal`\n**Format**: `$999,999,999,999.99`\n**Min Value**: 0\n**Max Value**: 999999999999999.99\n**Required**: ❌ No',
                        'Client.kyc_status': '**Attribute**: kyc_status\n\n**SQL Type**: `ENUM(\'PENDING\', \'APPROVED\', \'REJECTED\') NOT NULL`\n**Rust Type**: `KycStatus`\n**Values**: PENDING, APPROVED, REJECTED\n**Required**: ✅ Yes',
                        'Client.pep_status': '**Attribute**: pep_status\n\n**SQL Type**: `BOOLEAN NOT NULL DEFAULT FALSE`\n**Rust Type**: `bool`\n**Description**: Politically Exposed Person status\n**Required**: ✅ Yes',
                    };

                    if (fullPath && hoverInfo[fullPath]) {
                        console.log('Found hover info for:', fullPath);
                        return {
                            contents: [
                                {
                                    value: hoverInfo[fullPath],
                                    isTrusted: true,
                                    supportHtml: true
                                }
                            ],
                            range: new monaco.Range(
                                position.lineNumber,
                                start + 1,
                                position.lineNumber,
                                end + 1
                            )
                        };
                    }

                    // Try just the word under cursor if full path didn't match
                    const word = model.getWordAtPosition(position);
                    if (word && hoverInfo[word.word]) {
                        return {
                            contents: [
                                {
                                    value: hoverInfo[word.word],
                                    isTrusted: true,
                                    supportHtml: true
                                }
                            ]
                        };
                    }

                    return null;
                }
            });
            console.log('Hover provider registered:', disposable);
        }

        function updateDiagnostics(diagnostics) {
            const problemsList = document.getElementById('output-content');
            const problemsTab = document.querySelector('[data-panel="problems"]');

            if (diagnostics.length > 0) {
                problemsTab.textContent = `Problems (${diagnostics.length})`;
            } else {
                problemsTab.textContent = 'Problems';
            }

            // Store diagnostics
            diagnosticsMap.clear();
            diagnostics.forEach(d => diagnosticsMap.set(d.line, d));

            // Update Monaco markers
            const markers = diagnostics.map(d => ({
                startLineNumber: d.line,
                startColumn: 1,
                endLineNumber: d.line,
                endColumn: 1000,
                message: d.message,
                severity: d.severity === 'error' ? monaco.MarkerSeverity.Error :
                         d.severity === 'warning' ? monaco.MarkerSeverity.Warning :
                         monaco.MarkerSeverity.Info
            }));

            monaco.editor.setModelMarkers(editor.getModel(), 'dsl', markers);
        }

        async function runCode() {
            const code = editor.getValue();
            const button = document.getElementById('run-btn');

            button.disabled = true;
            button.innerHTML = '<span class="loading"></span> Running...';

            // Show which rule is being tested if we have context
            if (window.currentRuleContext) {
                addToOutput('console', `▶ Testing rule: ${window.currentRuleContext.ruleName}`);
            }

            try {
                // Check if running in Tauri environment
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    // Prepare the test context with the loaded dependencies
                    const testData = window.ruleTestContext || {};

                    // Call Tauri backend to test the rule with context
                    const result = await window.__TAURI__.invoke('test_rule', {
                        dslText: code,
                        context: testData  // Pass the business attributes as context
                    });

                    addToOutput('output', `✓ Execution successful:\n${JSON.stringify(result, null, 2)}`);

                    // If we have a rule context, show what value was computed
                    if (window.currentRuleContext && result[window.currentRuleContext.ruleName]) {
                        addToOutput('output', `\n${window.currentRuleContext.ruleName} = ${result[window.currentRuleContext.ruleName]}`);
                    }
                } else {
                    // Fallback for browser-only mode (simulate execution)
                    addToOutput('output', '⚠️ Running in browser mode (no Tauri backend)');

                    // Show the test context being used
                    if (window.ruleTestContext) {
                        addToOutput('output', '\n📊 Test Context:');
                        Object.entries(window.ruleTestContext).forEach(([key, value]) => {
                            addToOutput('output', `  ${key} = ${JSON.stringify(value)}`);
                        });
                    }

                    // Simple client-side validation/simulation
                    const lines = code.split('\n').filter(l => l.trim());
                    if (lines.length > 0) {
                        addToOutput('output', `✓ Parsed ${lines.length} lines of DSL code`);

                        // Simulate some basic checks
                        const hasIf = code.includes('IF');
                        const hasThen = code.includes('THEN');

                        if (hasIf && hasThen) {
                            addToOutput('output', '✓ Valid IF-THEN structure detected');
                        } else if (hasIf && !hasThen) {
                            addToOutput('output', '⚠️ Warning: IF without THEN');
                        }

                        // Check for common DSL patterns
                        if (code.includes('Client.')) {
                            addToOutput('output', '✓ Client attributes referenced');
                        }
                        if (code.match(/IS_[A-Z]+/)) {
                            addToOutput('output', '✓ Validation functions used');
                        }
                    } else {
                        addToOutput('output', '⚠️ No code to execute');
                    }
                }

            } catch (error) {
                addToOutput('output', `❌ Execution failed:\n${error}`);
            }

            button.disabled = false;
            button.innerHTML = '▶ Run Code';
        }

        async function validateCode() {
            const code = editor.getValue();
            addToOutput('output', '🔍 Validating code...');

            // Simulate validation
            const lines = code.split('\n');
            const diagnostics = [];

            lines.forEach((line, index) => {
                if (line.includes('IF') && !line.includes('THEN')) {
                    diagnostics.push({
                        line: index + 1,
                        severity: 'error',
                        message: 'IF statement missing THEN clause'
                    });
                }
            });

            updateDiagnostics(diagnostics);

            if (diagnostics.length === 0) {
                addToOutput('output', '✓ Validation successful - no issues found');
            } else {
                addToOutput('output', `⚠ Found ${diagnostics.length} issue(s)`);
            }
        }

        function formatCode() {
            // Simple formatting - preserves line structure
            let code = editor.getValue();

            // Process line by line to preserve structure
            const lines = code.split('\n');
            const formattedLines = lines.map(line => {
                // Skip empty lines
                if (line.trim() === '') {
                    return line;
                }

                // Preserve leading whitespace (indentation)
                const leadingWhitespace = line.match(/^(\s*)/)[1];
                let trimmedLine = line.trim();

                // Skip comments (but preserve indentation)
                if (trimmedLine.startsWith('#')) {
                    return line;
                }

                // Add spacing around operators
                let formatted = trimmedLine;

                // Add space around comparison and assignment operators
                formatted = formatted.replace(/([=<>!]+)/g, ' $1 ');
                formatted = formatted.replace(/([+\-*/%])/g, ' $1 ');

                // Add space around logical operators
                formatted = formatted.replace(/\b(AND|OR)\b/g, ' $1 ');

                // Clean up spaces around parentheses and commas
                formatted = formatted.replace(/\s*\(\s*/g, '(');
                formatted = formatted.replace(/\s*\)\s*/g, ')');
                formatted = formatted.replace(/\s*,\s*/g, ', ');

                // Clean up spaces around dots (for property access)
                formatted = formatted.replace(/\s*\.\s*/g, '.');

                // Fix multiple spaces that may have been created
                formatted = formatted.replace(/\s{2,}/g, ' ');

                // Return with original indentation preserved
                return leadingWhitespace + formatted.trim();
            });

            // Rejoin with line breaks preserved
            const formattedCode = formattedLines.join('\n');

            editor.setValue(formattedCode);
            addToOutput('console', '✓ Code formatted');
        }

        async function explainCode() {
            const code = editor.getValue();
            addToOutput('output', '🤖 AI is analyzing your code...');

            // Simulate AI explanation
            setTimeout(() => {
                const explanation = `This DSL code implements a KYC risk assessment system that:
1. Calculates a risk score based on client attributes
2. Validates email and LEI formats
3. Performs pattern matching on SWIFT codes
4. Categorizes clients as PREMIUM or STANDARD based on AUM
5. Returns a formatted result string with the risk assessment`;

                addToOutput('output', `AI Explanation:\n\n${explanation}`);
            }, 1500);
        }

        function loadDataDictionary() {
            const businessAttributes = [
                { name: 'Client.client_id', type: 'String', source: 'client_provided' },
                { name: 'Client.legal_entity_name', type: 'String', source: 'client_provided' },
                { name: 'Client.lei_code', type: 'String', source: 'client_provided' },
                { name: 'Client.email', type: 'String', source: 'client_provided' },
                { name: 'Client.country_code', type: 'String', source: 'client_provided' },
                { name: 'Client.risk_rating', type: 'Enum', source: 'internal_assessment' },
                { name: 'Client.aum_usd', type: 'Number', source: 'client_provided' },
                { name: 'Client.kyc_status', type: 'Enum', source: 'system_managed' },
                { name: 'Client.pep_status', type: 'Boolean', source: 'screening_result' },
            ];

            const derivedAttributes = [
                { name: 'Client.risk_score', type: 'Number', rule: 'RULE_001' },
                { name: 'Client.email_valid', type: 'Boolean', rule: 'RULE_002' },
                { name: 'Client.kyc_completion_percentage', type: 'Number', rule: 'RULE_003' },
                { name: 'Client.enhanced_dd_required', type: 'Boolean', rule: 'RULE_004' },
                { name: 'Client.service_tier', type: 'Enum', rule: 'RULE_005' },
            ];

            const functions = [
                { name: 'IS_EMAIL', type: 'Validation' },
                { name: 'IS_LEI', type: 'Validation' },
                { name: 'IS_SWIFT', type: 'Validation' },
                { name: 'CONCAT', type: 'String' },
                { name: 'SUBSTRING', type: 'String' },
                { name: 'LOOKUP', type: 'Data' },
                { name: 'UPPER', type: 'String' },
                { name: 'LOWER', type: 'String' },
                { name: 'LENGTH', type: 'String' },
                { name: 'ROUND', type: 'Number' },
            ];

            const attrList = document.getElementById('attribute-list');
            attrList.innerHTML = ''; // Clear existing

            // Add Business Attributes section
            const businessHeader = document.createElement('li');
            businessHeader.className = 'attribute-section-header';
            businessHeader.innerHTML = '<strong>📊 Business Data</strong>';
            businessHeader.style.marginBottom = '8px';
            businessHeader.style.color = '#90caf9';
            attrList.appendChild(businessHeader);

            businessAttributes.forEach(attr => {
                const li = document.createElement('li');
                li.className = 'attribute-item business-attribute';
                li.innerHTML = `<span style="color: #90caf9;">●</span> ${attr.name} <span class="attribute-type">${attr.type}</span>`;
                li.title = `Source: ${attr.source}`;
                li.onclick = () => insertText(attr.name);
                attrList.appendChild(li);
            });

            // Add Derived Attributes section
            const derivedHeader = document.createElement('li');
            derivedHeader.className = 'attribute-section-header';
            derivedHeader.innerHTML = '<strong>🔧 Derived Data</strong>';
            derivedHeader.style.marginTop = '15px';
            derivedHeader.style.marginBottom = '8px';
            derivedHeader.style.color = '#a5d6a7';
            attrList.appendChild(derivedHeader);

            derivedAttributes.forEach(attr => {
                const li = document.createElement('li');
                li.className = 'attribute-item derived-attribute';
                li.innerHTML = `<span style="color: #a5d6a7;">●</span> ${attr.name} <span class="attribute-type">${attr.type}</span>`;
                li.title = `Generated by: ${attr.rule}`;
                li.onclick = () => insertText(attr.name);
                attrList.appendChild(li);
            });

            const funcList = document.getElementById('function-list');
            funcList.innerHTML = ''; // Clear existing

            functions.forEach(func => {
                const li = document.createElement('li');
                li.className = 'attribute-item';
                li.innerHTML = `${func.name}() <span class="attribute-type">${func.type}</span>`;
                li.onclick = () => insertText(`${func.name}()`);
                funcList.appendChild(li);
            });
        }

        function insertText(text) {
            const selection = editor.getSelection();
            const id = { major: 1, minor: 1 };
            const op = { identifier: id, range: selection, text: text, forceMoveMarkers: true };
            editor.executeEdits("insert", [op]);
            editor.focus();
        }

        function addToOutput(panel, message) {
            const outputContent = document.getElementById('output-content');
            const timestamp = new Date().toLocaleTimeString();
            outputContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            outputContent.scrollTop = outputContent.scrollHeight;

            // Switch to the appropriate tab
            document.querySelectorAll('.output-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.panel === panel);
            });
        }

        function clearOutput() {
            document.getElementById('output-content').innerHTML = '';
        }

        // Tab switching
        document.querySelectorAll('.output-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.output-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Switch between different output panels
                const panel = tab.dataset.panel;
                if (panel === 'problems') {
                    showProblems();
                } else if (panel === 'agent') {
                    showAgentChat();
                } else if (panel === 'rules') {
                    showRulesCatalogue();
                } else {
                    showOutput();
                }
            });
        });

        function showProblems() {
            const outputContent = document.getElementById('output-content');
            outputContent.innerHTML = '<ul class="diagnostics-list">';

            diagnosticsMap.forEach((diag, line) => {
                outputContent.innerHTML += `
                    <li class="diagnostic-item ${diag.severity}" onclick="goToLine(${line})">
                        Line ${line}: ${diag.message}
                    </li>
                `;
            });

            outputContent.innerHTML += '</ul>';
        }

        // AI Agent Chat Implementation
        let chatHistory = [];
        let apiKey = localStorage.getItem('openai_api_key') || '';

        async function showAgentChat() {
            const outputContent = document.getElementById('output-content');

            // Check API key status
            let apiKey = localStorage.getItem('ai_api_key') || sessionStorage.getItem('ai_api_key');
            let apiProvider = localStorage.getItem('ai_provider') || sessionStorage.getItem('ai_provider') || 'anthropic';

            // Try to get from system if not in storage
            if (!apiKey && window.__TAURI__ && window.__TAURI__.invoke) {
                try {
                    const systemKeys = await window.__TAURI__.invoke('get_api_keys');
                    if (systemKeys) {
                        if (systemKeys.anthropic) {
                            apiKey = systemKeys.anthropic;
                            apiProvider = 'anthropic';
                        } else if (systemKeys.openai) {
                            apiKey = systemKeys.openai;
                            apiProvider = 'openai';
                        }
                    }
                } catch (error) {
                    console.log('Could not check system keys');
                }
            }

            // Create the chat interface
            outputContent.innerHTML = `
                <div class="agent-container">
                    <div class="context-indicator">
                        📝 Context: Current DSL rule in editor
                    </div>
                    <div class="chat-messages" id="chat-messages">
                        <div class="chat-message system">
                            Welcome! I'm your DSL Assistant. I can help you with:
                            <br>• Explaining DSL rules and syntax
                            <br>• Debugging and fixing errors
                            <br>• Providing examples and patterns
                            <br>• Optimizing your rules
                            <br>
                            <br>${apiKey ? '✅ AI Mode Active' : '🤖 Offline Mode - Intelligent fallback active'}
                            <br><small>${apiKey ? 'Using ' + apiProvider.toUpperCase() + ' API' : 'For AI-powered responses, configure an API key in Settings'}</small>
                        </div>
                    </div>
                    <div class="chat-input-container">
                        <input type="text"
                               class="chat-input"
                               id="chat-input"
                               placeholder="Ask about your DSL rule or request help..."
                               onkeypress="handleChatKeyPress(event)">
                        <button class="chat-send-btn"
                                id="chat-send"
                                onclick="sendChatMessage()">
                            Send
                        </button>
                    </div>
                </div>
            `;

            // Load chat history if exists
            if (chatHistory.length > 0) {
                const messagesContainer = document.getElementById('chat-messages');
                messagesContainer.innerHTML = '';
                chatHistory.forEach(msg => {
                    addChatMessage(msg.role, msg.content, false);
                });
            }

            // Focus on input
            document.getElementById('chat-input').focus();
        }

        function addChatMessage(role, content, save = true) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;

            // Parse code blocks in assistant messages
            if (role === 'assistant') {
                content = content.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
                    return `<div class="message-code">${escapeHtml(code.trim())}</div>`;
                });
                messageDiv.innerHTML = content.replace(/\n/g, '<br>');
            } else {
                messageDiv.textContent = content;
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Save to history
            if (save) {
                chatHistory.push({ role, content });
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const sendButton = document.getElementById('chat-send');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addChatMessage('user', message);
            input.value = '';
            sendButton.disabled = true;

            // Get current context
            const currentRule = editor.getValue();
            const selectedText = editor.getModel().getValueInRange(editor.getSelection());

            // Build context with RAG from data dictionary
            const context = buildAgentContext(currentRule, selectedText);

            try {
                // For now, use a mock response. In production, this would call OpenAI/Anthropic
                const response = await callAIAgent(message, context);
                addChatMessage('assistant', response);
            } catch (error) {
                addChatMessage('system', `Error: ${error.message}`);
            }

            sendButton.disabled = false;
            input.focus();
        }

        function buildAgentContext(currentRule, selectedText) {
            // Build comprehensive context for the AI
            const context = {
                currentRule: currentRule,
                selectedText: selectedText,
                dataDict: {
                    entities: ['Client'],
                    attributes: [
                        'Client.client_id - VARCHAR(50) PRIMARY KEY - Format: XXX-999',
                        'Client.legal_entity_name - VARCHAR(255) NOT NULL',
                        'Client.lei_code - CHAR(20) - Legal Entity Identifier',
                        'Client.email - VARCHAR(255) NOT NULL - Validated with IS_EMAIL',
                        'Client.risk_rating - ENUM(LOW,MEDIUM,HIGH)',
                        'Client.aum_usd - DECIMAL(18,2) - Format: $999,999,999,999.99',
                        'Client.kyc_status - ENUM(PENDING,APPROVED,REJECTED)',
                        'Client.pep_status - BOOLEAN NOT NULL'
                    ],
                    functions: [
                        'IS_EMAIL(email) - Validates email format',
                        'IS_LEI(lei) - Validates Legal Entity Identifier',
                        'IS_SWIFT(code) - Validates SWIFT/BIC code',
                        'CONCAT(...) - Concatenate values',
                        'SUBSTRING(str, start, end) - Extract substring',
                        'LOOKUP(key, table) - Look up value from table'
                    ],
                    operators: [
                        'Arithmetic: +, -, *, /, %',
                        'Comparison: ==, !=, <, >, <=, >=',
                        'Logical: AND, OR, NOT',
                        'String concat: &',
                        'Regex match: ~'
                    ]
                },
                language: 'DSL for KYC validation and data transformation'
            };

            return context;
        }

        async function callAIAgent(message, context) {
            // First try to get API keys from system environment via Tauri
            let apiKey = localStorage.getItem('ai_api_key');
            let apiProvider = localStorage.getItem('ai_provider') || 'anthropic';

            // If no localStorage key and running in Tauri, try to get from environment
            if (!apiKey && window.__TAURI__ && window.__TAURI__.invoke) {
                try {
                    const systemKeys = await window.__TAURI__.invoke('get_api_keys');
                    if (systemKeys) {
                        // Prefer Anthropic key if available
                        if (systemKeys.anthropic) {
                            apiKey = systemKeys.anthropic;
                            apiProvider = 'anthropic';
                            // Optionally save to localStorage for this session
                            sessionStorage.setItem('ai_api_key', apiKey);
                            sessionStorage.setItem('ai_provider', apiProvider);
                        } else if (systemKeys.openai) {
                            apiKey = systemKeys.openai;
                            apiProvider = 'openai';
                            sessionStorage.setItem('ai_api_key', apiKey);
                            sessionStorage.setItem('ai_provider', apiProvider);
                        }
                    }
                } catch (error) {
                    console.log('Could not retrieve system API keys:', error);
                }
            }

            // Check sessionStorage as well for temporary keys
            if (!apiKey) {
                apiKey = sessionStorage.getItem('ai_api_key');
                apiProvider = sessionStorage.getItem('ai_provider') || apiProvider;
            }

            if (!apiKey) {
                // If no API key, use intelligent mock responses
                return getMockResponse(message, context);
            }

            try {
                // Prepare the system prompt with context
                const systemPrompt = `You are an AI assistant specializing in DSL (Domain Specific Language) development for KYC (Know Your Customer) data transformation rules.

Current context:
- User is working on: ${context.currentRule ? context.currentRule.substring(0, 500) + '...' : 'No rule loaded'}
- Available attributes: ${Object.keys(context.attributes).join(', ')}
- Available functions: ${context.functions.join(', ')}
- Available operators: ${context.operators.join(', ')}

Help the user with DSL syntax, debugging, optimization, and best practices. Be concise and code-focused.`;

                if (apiProvider === 'openai') {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: localStorage.getItem('ai_model') || 'gpt-4-turbo-preview',
                            messages: [
                                { role: 'system', content: systemPrompt },
                                { role: 'user', content: message }
                            ],
                            temperature: 0.7,
                            max_tokens: 1000
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.choices[0].message.content;

                } else if (apiProvider === 'anthropic') {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({
                            model: localStorage.getItem('ai_model') || 'claude-3-opus-20240229',
                            max_tokens: 1000,
                            system: systemPrompt,
                            messages: [
                                { role: 'user', content: message }
                            ]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Anthropic API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.content[0].text;
                }

            } catch (error) {
                console.error('AI API call failed:', error);
                // Fall back to mock responses if API fails
                return getMockResponse(message, context) +
                       `\n\n<small>⚠️ API call failed: ${error.message}. Using offline responses.</small>`;
            }
        }

        function getMockResponse(message, context) {
            // Enhanced intelligent mock responses for offline/fallback mode
            const lowerMessage = message.toLowerCase();
            const currentRule = context?.currentRule || '';

            // Analyze the current rule for context-aware responses
            const hasIfStatement = currentRule.includes('IF');
            const hasClientAttributes = currentRule.includes('Client.');
            const hasValidation = currentRule.includes('IS_EMAIL') || currentRule.includes('IS_LEI');
            const hasCalculation = currentRule.includes('+') || currentRule.includes('-') || currentRule.includes('*');

            // Question type detection
            if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('hey')) {
                return `Hello! I'm your DSL Assistant running in offline mode. I can help you with:

• **DSL Syntax** - IF/THEN/ELSE statements, operators, functions
• **Data Attributes** - Business vs derived attributes, types, constraints
• **Rule Examples** - KYC validation, risk scoring, data transformation
• **Debugging** - Common errors and fixes
• **Best Practices** - Optimization tips and patterns

What would you like help with today?

<small>💡 For AI-powered responses, configure an API key in Settings or set ANTHROPIC_API_KEY in your environment.</small>`;
            }

            if (lowerMessage.includes('what') && lowerMessage.includes('attributes')) {
                const businessAttrs = Object.keys(context.attributes).filter(a =>
                    !['risk_score', 'email_valid', 'kyc_completion_percentage', 'enhanced_dd_required', 'service_tier'].some(d => a.includes(d))
                );
                const derivedAttrs = ['risk_score', 'email_valid', 'kyc_completion_percentage', 'enhanced_dd_required', 'service_tier'];

                return `Here are the available attributes in your data dictionary:

**📊 Business Attributes (Source Data):**
${businessAttrs.map(attr => `• Client.${attr}`).join('\n')}

**🔧 Derived Attributes (Calculated):**
${derivedAttrs.map(attr => `• Client.${attr} (generated by rules)`).join('\n')}

Business attributes are provided by clients or internal systems. Derived attributes are calculated using DSL rules.`;
            }

            if (lowerMessage.includes('explain') || lowerMessage.includes('what does')) {
                if (currentRule) {
                    // Analyze the current rule
                    let explanation = `Looking at your current rule:\n\n`;

                    if (hasIfStatement) {
                        explanation += `• **Conditional Logic**: Your rule uses IF/THEN statements to make decisions based on conditions.\n`;
                    }
                    if (hasClientAttributes) {
                        const attrs = currentRule.match(/Client\.\w+/g) || [];
                        explanation += `• **Attributes Used**: ${[...new Set(attrs)].join(', ')}\n`;
                    }
                    if (hasValidation) {
                        explanation += `• **Validation**: Your rule validates data formats (email, LEI, etc.)\n`;
                    }
                    if (hasCalculation) {
                        explanation += `• **Calculations**: Your rule performs arithmetic operations\n`;
                    }

                    explanation += `\n**How it works:**\n`;
                    explanation += `1. The rule evaluates conditions sequentially\n`;
                    explanation += `2. When a condition is true, its corresponding action executes\n`;
                    explanation += `3. Results can be stored in variables for later use\n`;
                    explanation += `4. Functions like IS_EMAIL() validate data formats\n`;

                    return explanation;
                } else {
                    return `The DSL (Domain Specific Language) uses:

• **IF/THEN/ELSE** - Conditional logic for decision making
• **Client.attribute** - Access data fields (e.g., Client.email)
• **Operators** - ==, !=, >, <, >=, <= for comparisons
• **Functions** - IS_EMAIL(), CONCAT(), LOOKUP() for operations
• **Variables** - Store intermediate results

Example:
<div class="message-code">IF Client.risk_rating == "HIGH" THEN
    risk_score = 100
ELSE
    risk_score = 50
END</div>`;
                }
            }

            if (lowerMessage.includes('fix') || lowerMessage.includes('error') || lowerMessage.includes('debug')) {
                // Analyze current rule for potential issues
                let debugInfo = `Common issues to check in DSL rules:\n\n`;

                if (currentRule) {
                    const openIfs = (currentRule.match(/IF/g) || []).length;
                    const ends = (currentRule.match(/END/g) || []).length;

                    if (openIfs !== ends) {
                        debugInfo += `⚠️ **Unmatched IF/END**: You have ${openIfs} IF statements but ${ends} END statements\n\n`;
                    }

                    // Check for common syntax issues
                    if (currentRule.includes('=') && !currentRule.includes('==')) {
                        debugInfo += `💡 **Assignment vs Comparison**: Use '=' for assignment, '==' for comparison\n\n`;
                    }

                    if (currentRule.match(/"\w+/g) || currentRule.match(/\w+"/g)) {
                        debugInfo += `⚠️ **Quote Mismatch**: Check that all strings have matching quotes\n\n`;
                    }
                }

                debugInfo += `**Debugging Checklist:**
✓ All IF statements have matching END
✓ String values are in quotes: "value"
✓ Numbers are without quotes: 123
✓ Attribute names are correct: Client.attribute_name
✓ Functions have parentheses: IS_EMAIL()
✓ Operators are correct: == for comparison, = for assignment

<div class="message-code"># Correct syntax example
IF Client.risk_rating == "HIGH" THEN
    enhanced_review = true
    risk_score = 100
END</div>`;

                return debugInfo;
            }

            if (lowerMessage.includes('example') || lowerMessage.includes('how') || lowerMessage.includes('show')) {
                // Provide relevant examples based on context
                if (lowerMessage.includes('risk')) {
                    return `Here's a comprehensive risk scoring example:

<div class="message-code"># Initialize risk score
risk_score = 0

# Base risk from rating
IF Client.risk_rating == "HIGH" THEN
    risk_score = risk_score + 50
ELSE IF Client.risk_rating == "MEDIUM" THEN
    risk_score = risk_score + 25
ELSE
    risk_score = risk_score + 10
END

# PEP adjustment
IF Client.pep_status == true THEN
    risk_score = risk_score + 30
END

# Large AUM adjustment
IF Client.aum_usd > 10000000 THEN
    risk_score = risk_score + 20
END

# Final classification
risk_category = IF risk_score >= 70 THEN "HIGH_RISK"
                ELSE IF risk_score >= 40 THEN "MEDIUM_RISK"
                ELSE "LOW_RISK"</div>`;
                } else if (lowerMessage.includes('valid')) {
                    return `Here are validation examples:

<div class="message-code"># Email validation
email_valid = IS_EMAIL(Client.email)

# LEI code validation
lei_valid = IS_LEI(Client.lei_code)

# Combined validation
all_valid = email_valid AND lei_valid

# Validation with action
IF NOT IS_EMAIL(Client.email) THEN
    validation_status = "INVALID_EMAIL"
    require_manual_review = true
ELSE
    validation_status = "VALID"
END</div>`;
                } else {
                    return `Here are common DSL patterns:

**1. Simple Assignment:**
<div class="message-code">status = "ACTIVE"
score = 100</div>

**2. Conditional Logic:**
<div class="message-code">IF Client.aum_usd > 1000000 THEN
    tier = "GOLD"
ELSE
    tier = "SILVER"
END</div>

**3. String Operations:**
<div class="message-code">full_name = CONCAT(Client.first_name, " ", Client.last_name)
code = SUBSTRING(Client.client_id, 0, 3)</div>

**4. Validation:**
<div class="message-code">valid = IS_EMAIL(Client.email) AND Client.country_code != ""</div>

Which pattern would you like to explore more?`;
                }
            }

            if (lowerMessage.includes('optimize') || lowerMessage.includes('improve') || lowerMessage.includes('better')) {
                return `Here are optimization tips for DSL rules:

**1. Combine Related Conditions:**
Instead of:
<div class="message-code">IF Client.risk_rating == "HIGH" THEN
    flag = true
END
IF Client.pep_status == true THEN
    flag = true
END</div>

Use:
<div class="message-code">flag = Client.risk_rating == "HIGH" OR Client.pep_status == true</div>

**2. Use Early Returns:**
<div class="message-code">IF Client.kyc_status == "REJECTED" THEN
    process_status = "BLOCKED"
    # No need to check further
ELSE
    # Continue with other checks
END</div>

**3. Extract Complex Logic:**
<div class="message-code"># Define reusable conditions
is_high_risk = Client.risk_rating == "HIGH" OR Client.pep_status == true
is_large_client = Client.aum_usd > 10000000

# Use in logic
enhanced_review = is_high_risk AND is_large_client</div>

**4. Add Comments:**
<div class="message-code"># Risk assessment for institutional clients
# High risk triggers enhanced due diligence</div>`;
            }

            if (lowerMessage.includes('test') || lowerMessage.includes('run')) {
                return `To test your DSL rules:

1. **Use the Run Button** (▶): Executes your rule with sample data
2. **Check the Output Tab**: Shows execution results and any errors
3. **Review Problems Tab**: Lists syntax errors and warnings

**Sample Test Data Available:**
• Client.client_id = "CLT-001"
• Client.risk_rating = "MEDIUM"
• Client.aum_usd = 5000000
• Client.email = "client@example.com"
• Client.pep_status = false

**Testing Tips:**
• Test edge cases (empty values, extremes)
• Verify all conditional branches
• Check calculation accuracy
• Validate output formats`;
            }

            if (lowerMessage.includes('function') || lowerMessage.includes('what functions')) {
                const functions = context.functions || [];
                return `Available DSL Functions:

${functions.map(fn => `**${fn}()**`).join('\n')}

**Common Functions:**
• **IS_EMAIL(email)** - Validates email format
• **IS_LEI(code)** - Validates Legal Entity Identifier
• **CONCAT(...)** - Concatenates multiple values
• **SUBSTRING(str, start, end)** - Extracts substring
• **LOOKUP(key, table)** - Looks up value from table
• **UPPER/LOWER(str)** - Case conversion
• **LENGTH(str)** - String length
• **ROUND(num, decimals)** - Number rounding

Example:
<div class="message-code">email_valid = IS_EMAIL(Client.email)
full_text = CONCAT("Status: ", Client.kyc_status)
country = LOOKUP(Client.country_code, "countries")</div>`;
            }

            // Context-aware default response
            if (currentRule) {
                return `I see you're working on a DSL rule. Based on your code:

${hasIfStatement ? '• You have conditional logic (IF/THEN statements)\n' : ''}
${hasClientAttributes ? '• You\'re using Client attributes for data access\n' : ''}
${hasValidation ? '• You\'re performing data validation\n' : ''}
${hasCalculation ? '• You\'re doing calculations\n' : ''}

I can help you:
• Debug any issues
• Optimize the logic
• Add validation
• Provide examples

What specific help do you need?

<small>🤖 Offline Assistant Mode - For AI-powered help, add an API key in Settings</small>`;
            }

            // Generic but helpful default
            return `I'm here to help with your DSL development!

**Quick Help Menu:**
• Type "explain" - Understand DSL syntax
• Type "example" - See code examples
• Type "fix" or "error" - Debug issues
• Type "optimize" - Improve your rules
• Type "functions" - List available functions
• Type "attributes" - See data dictionary

**Your Question:** "${message}"

Please be more specific about what you need help with, and I'll provide detailed guidance.

<small>💡 Running in offline mode. For enhanced AI responses, configure an API key in Settings or set ANTHROPIC_API_KEY environment variable.</small>`;
        }

        window.handleChatKeyPress = function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        window.sendChatMessage = sendChatMessage;

        function showOutput() {
            // Output already shows in main output
        }

        // Rules Catalogue Implementation
        let rulesCatalogue = null;
        let enhancedDataDictionary = null;

        async function loadRulesCatalogue() {
            try {
                // Load rules from PostgreSQL database
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    try {
                        const dbRules = await window.__TAURI__.invoke('db_get_all_rules');

                        // Transform database rules to match UI format
                        rulesCatalogue = {
                            rules: dbRules.map(rule => ({
                                ruleId: rule.rule_id,
                                ruleName: rule.rule_name,
                                description: rule.description || '',
                                targetAttribute: rule.target_attribute_id || '',
                                sourceAttributes: [],  // Would need to join with dependencies table
                                category: rule.category_id || 'uncategorized',
                                status: rule.status || 'draft',
                                dslText: rule.rule_definition || '',
                                createdAt: rule.created_at,
                                updatedAt: rule.updated_at
                            }))
                        };

                        // Generate embeddings for rules without them
                        await window.__TAURI__.invoke('db_generate_all_embeddings');

                        console.log('Loaded rules from database:', rulesCatalogue.rules.length);
                        return true;
                    } catch (dbError) {
                        console.error('Database error, falling back to mock data:', dbError);
                        // Fall back to mock data if database fails
                        return loadMockRules();
                    }
                } else {
                    // Use mock data if not in Tauri environment
                    return loadMockRules();
                }
            } catch (error) {
                console.error('Failed to load rules catalogue:', error);
                return false;
            }
        }

        function loadMockRules() {
            rulesCatalogue = {
                rules: [
                    {
                        ruleId: "RULE_001",
                        ruleName: "Calculate Risk Score",
                        description: "Calculate overall risk score based on client risk rating, PEP status, and AUM",
                        targetAttribute: "Client.risk_score",
                        sourceAttributes: ["Client.risk_rating", "Client.pep_status", "Client.aum_usd"],
                        category: "risk_assessment",
                        status: "active",
                        dslText: 'risk_score = (risk_rating * 2 + pep_status * 3) / aum_usd'
                    },
                    {
                        ruleId: "RULE_002",
                        ruleName: "Validate Email Format",
                        description: "Validate client email address format",
                        targetAttribute: "Client.email_valid",
                        sourceAttributes: ["Client.email"],
                        category: "validation",
                        status: "active",
                        dslText: 'email_valid = email MATCHES "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"'
                    },
                    {
                        ruleId: "RULE_003",
                        ruleName: "KYC Completion Status",
                        description: "Determine KYC completion percentage based on required fields",
                        targetAttribute: "Client.kyc_completion_percentage",
                        sourceAttributes: ["Client.client_id", "Client.legal_entity_name", "Client.lei_code", "Client.email", "Client.country_code"],
                        category: "kyc_validation",
                        status: "active",
                        dslText: 'kyc_percentage = (HAS(client_id) + HAS(legal_entity_name) + HAS(lei_code) + HAS(email) + HAS(country_code)) * 20'
                    },
                    {
                        ruleId: "RULE_004",
                        ruleName: "Enhanced Due Diligence Flag",
                        description: "Determine if enhanced due diligence is required",
                        targetAttribute: "Client.enhanced_dd_required",
                        sourceAttributes: ["Client.risk_rating", "Client.pep_status", "Client.aum_usd", "Client.country_code"],
                        category: "compliance",
                        status: "active",
                        dslText: 'enhanced_dd = risk_rating > 7 OR pep_status = true OR aum_usd > 10000000'
                    },
                    {
                        ruleId: "RULE_005",
                        ruleName: "Client Tier Classification",
                        description: "Classify client into service tiers based on AUM",
                        targetAttribute: "Client.service_tier",
                        sourceAttributes: ["Client.aum_usd"],
                        category: "classification",
                        status: "active",
                        dslText: 'WHEN aum_usd > 10000000 THEN service_tier = "Platinum" WHEN aum_usd > 1000000 THEN service_tier = "Gold" ELSE service_tier = "Silver"'
                    }
                ]
            };
            return true;
        }

        function showRulesCatalogue() {
            const outputContent = document.getElementById('output-content');

            if (!rulesCatalogue) {
                loadRulesCatalogue().then(() => showRulesCatalogue());
                outputContent.innerHTML = '<div class="loading">Loading rules catalogue...</div>';
                return;
            }

            outputContent.innerHTML = `
                <div class="rules-catalogue-container">
                    <div class="rules-catalogue-header">
                        <h3>📋 Rules Catalogue</h3>
                        <div class="rules-actions">
                            <button class="btn secondary" onclick="addNewRule()">➕ New Rule</button>
                            <button class="btn secondary" onclick="refreshRulesCatalogue()">🔄 Refresh</button>
                        </div>
                    </div>

                    <div class="rules-filters">
                        <select id="category-filter" onchange="filterRules()">
                            <option value="">All Categories</option>
                            <option value="risk_assessment">Risk Assessment</option>
                            <option value="validation">Data Validation</option>
                            <option value="kyc_validation">KYC Validation</option>
                            <option value="compliance">Compliance</option>
                            <option value="classification">Classification</option>
                        </select>
                        <select id="status-filter" onchange="filterRules()">
                            <option value="">All Status</option>
                            <option value="active">Active</option>
                            <option value="draft">Draft</option>
                            <option value="inactive">Inactive</option>
                        </select>
                        <input type="text" id="rule-search" placeholder="Search rules..." oninput="filterRules()">
                    </div>

                    <div class="rules-list" id="rules-list">
                        ${rulesCatalogue.rules.map(rule => `
                            <div class="rule-card" data-rule-id="${rule.ruleId}">
                                <div class="rule-header">
                                    <span class="rule-id">${rule.ruleId}</span>
                                    <span class="rule-status ${rule.status}">${rule.status.toUpperCase()}</span>
                                </div>
                                <h4 class="rule-name">${rule.ruleName}</h4>
                                <p class="rule-description">${rule.description}</p>

                                <div class="rule-attributes">
                                    <div class="attribute-group">
                                        <label>Target (Output):</label>
                                        <span class="attribute-tag derived">${rule.targetAttribute}</span>
                                    </div>
                                    <div class="attribute-group">
                                        <label>Sources (Inputs):</label>
                                        ${rule.sourceAttributes.map(attr =>
                                            `<span class="attribute-tag business">${attr}</span>`
                                        ).join('')}
                                    </div>
                                </div>

                                <div class="rule-actions">
                                    <button class="btn-small" onclick="editRule('${rule.ruleId}')">✏️ Edit</button>
                                    <button class="btn-small" onclick="viewRule('${rule.ruleId}')">👁️ View</button>
                                    <button class="btn-small" onclick="testRule('${rule.ruleId}')">▶️ Test</button>
                                    <button class="btn-small secondary" onclick="duplicateRule('${rule.ruleId}')">📋 Duplicate</button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function filterRules() {
            const category = document.getElementById('category-filter')?.value;
            const status = document.getElementById('status-filter')?.value;
            const search = document.getElementById('rule-search')?.value?.toLowerCase();

            const ruleCards = document.querySelectorAll('.rule-card');
            ruleCards.forEach(card => {
                const rule = rulesCatalogue.rules.find(r => r.ruleId === card.dataset.ruleId);
                let show = true;

                if (category && rule.category !== category) show = false;
                if (status && rule.status !== status) show = false;
                if (search && !rule.ruleName.toLowerCase().includes(search) &&
                    !rule.description.toLowerCase().includes(search)) show = false;

                card.style.display = show ? 'block' : 'none';
            });
        }

        function addNewRule() {
            // In production, this would open a modal or switch to rule editor
            alert('Rule editor would open here to create a new rule');
        }

        function editRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule) {
                // Load rule into editor
                editor.setValue(rule.dslText || '');
                // Store current rule ID for saving
                editor.currentRuleId = ruleId;
                // Switch to Output tab
                document.querySelector('[data-panel="output"]').click();
                addToOutput('info', `Loaded rule ${ruleId} into editor`);
            }
        }

        async function saveCurrentRule() {
            const dslText = editor.getValue();
            const ruleId = editor.currentRuleId;

            if (!ruleId) {
                addToOutput('error', 'No rule selected for saving');
                return;
            }

            try {
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    // Update rule in database
                    await window.__TAURI__.invoke('db_update_rule', {
                        rule_id: ruleId,
                        rule_definition: dslText
                    });

                    // Update embedding for semantic search
                    await window.__TAURI__.invoke('db_update_rule_embedding', {
                        rule_id: ruleId,
                        dsl_text: dslText
                    });

                    addToOutput('success', `Rule ${ruleId} saved successfully`);

                    // Refresh the catalogue
                    await refreshRulesCatalogue();
                } else {
                    addToOutput('info', 'Database not available - rule saved locally');
                }
            } catch (error) {
                addToOutput('error', `Failed to save rule: ${error.message || error}`);
            }
        }

        let currentASTData = null;

        window.showAST = async function() {
            const code = editor.getValue();
            console.log('showAST called with code:', code);

            if (!code.trim()) {
                addToOutput('error', 'Please enter some DSL code to visualize its AST');
                return;
            }

            try {
                const invoke = window.__TAURI_INVOKE__ || (window.__TAURI__ && window.__TAURI__.invoke);

                if (invoke) {
                    console.log('Invoking visualize_ast command...');
                    const astData = await invoke('visualize_ast', {
                        dslText: code
                    });

                    console.log('AST data received:', astData);
                    currentASTData = astData;

                    // Switch to AST tab
                    document.querySelectorAll('.output-tab').forEach(tab => {
                        tab.classList.remove('active');
                    });
                    document.querySelector('.output-tab[data-panel="ast"]').classList.add('active');

                    // Show AST panel, hide others
                    document.getElementById('output-content').style.display = 'none';
                    document.getElementById('ast-panel').style.display = 'block';

                    // Update AST content
                    const treeContent = document.getElementById('ast-tree-content');
                    const jsonContent = document.getElementById('ast-json-content');
                    const dotContent = document.getElementById('ast-dot-content');

                    console.log('Elements found:', { treeContent, jsonContent, dotContent });

                    if (treeContent) treeContent.textContent = astData.text_tree || 'No tree data';
                    if (jsonContent) jsonContent.textContent = astData.json_format || 'No JSON data';
                    if (dotContent) dotContent.textContent = astData.dot_format || 'No DOT data';

                    addToOutput('success', '🌳 AST generated successfully');
                } else {
                    console.error('Tauri API not available');
                    addToOutput('error', 'Tauri API not available - cannot generate AST');
                }
            } catch (error) {
                console.error('Failed to generate AST:', error);
                addToOutput('error', `Failed to generate AST: ${error.message || error}`);
            }
        }

        window.refreshAST = function() {
            window.showAST();
        }

        window.openSchemaViewer = async function() {
            try {
                const invoke = window.__TAURI_INVOKE__ || (window.__TAURI__ && window.__TAURI__.invoke);
                if (!invoke) {
                    addToOutput('error', 'Tauri API not available');
                    return;
                }
                await invoke('open_schema_viewer');
                addToOutput('success', 'Opening Schema Viewer in new window...');
            } catch (error) {
                console.error('Failed to open schema viewer:', error);
                addToOutput('error', `Failed to open schema viewer: ${error}`);
            }
        }

        window.switchASTView = function(view) {
            // Update tab active states
            document.querySelectorAll('.ast-view-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.view === view) {
                    tab.classList.add('active');
                }
            });

            // Show/hide views
            document.getElementById('ast-tree-view').style.display = view === 'tree' ? 'block' : 'none';
            document.getElementById('ast-json-view').style.display = view === 'json' ? 'block' : 'none';
            document.getElementById('ast-dot-view').style.display = view === 'dot' ? 'block' : 'none';
        }

        window.exportAST = function(format) {
            if (!currentASTData) {
                addToOutput('error', 'No AST data to export. Generate AST first.');
                return;
            }

            let content = '';
            let filename = '';
            let mimeType = '';

            switch (format) {
                case 'json':
                    content = currentASTData.json_format;
                    filename = 'ast.json';
                    mimeType = 'application/json';
                    break;
                case 'dot':
                    content = currentASTData.dot_format;
                    filename = 'ast.dot';
                    mimeType = 'text/plain';
                    break;
            }

            // Create download link
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            addToOutput('success', `✅ AST exported as ${filename}`);
        }

        window.copyAST = function(format) {
            if (!currentASTData) {
                addToOutput('error', 'No AST data to copy. Generate AST first.');
                return;
            }

            let content = currentASTData.text_tree;

            navigator.clipboard.writeText(content).then(() => {
                addToOutput('success', '📋 AST tree copied to clipboard');
            }).catch(err => {
                addToOutput('error', `Failed to copy: ${err}`);
            });
        }

        async function findSimilarRules() {
            const dslText = editor.getValue();

            if (!dslText.trim()) {
                addToOutput('error', 'Please enter some DSL code to find similar rules');
                return;
            }

            try {
                addToOutput('info', '🔍 Searching for similar rules...');

                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    const similarRules = await window.__TAURI__.invoke('db_find_similar_rules', {
                        dsl_text: dslText,
                        limit: 5
                    });

                    if (similarRules && similarRules.length > 0) {
                        const outputContent = document.getElementById('output-content');
                        outputContent.innerHTML = `
                            <div class="similar-rules-container">
                                <h3>🔍 Similar Rules Found</h3>
                                <div class="similar-rules-list">
                                    ${similarRules.map(rule => `
                                        <div class="similar-rule-card">
                                            <div class="similarity-score">
                                                ${Math.round((rule.similarity || 0) * 100)}% Similar
                                            </div>
                                            <h4>${rule.name}</h4>
                                            <p>${rule.description || 'No description'}</p>
                                            <pre class="rule-dsl">${rule.dsl_text}</pre>
                                            <div class="rule-actions">
                                                <button class="btn-small" onclick="loadRuleIntoEditor('${rule.id}', \`${rule.dsl_text.replace(/`/g, '\\`')}\`)">
                                                    📋 Load in Editor
                                                </button>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    } else {
                        addToOutput('info', 'No similar rules found in the database');
                    }
                } else {
                    // Mock similar rules for demo
                    const mockSimilarRules = [
                        {
                            id: 'RULE_001',
                            name: 'Calculate Risk Score',
                            description: 'Calculate overall risk score',
                            dsl_text: 'risk_score = (risk_rating * 2 + pep_status * 3) / aum_usd',
                            similarity: 0.85
                        },
                        {
                            id: 'RULE_004',
                            name: 'Enhanced Due Diligence',
                            description: 'Determine if EDD required',
                            dsl_text: 'enhanced_dd = risk_rating > 7 OR pep_status = true',
                            similarity: 0.72
                        }
                    ];

                    const outputContent = document.getElementById('output-content');
                    outputContent.innerHTML = `
                        <div class="similar-rules-container">
                            <h3>🔍 Similar Rules (Mock Data)</h3>
                            <div class="similar-rules-list">
                                ${mockSimilarRules.map(rule => `
                                    <div class="similar-rule-card">
                                        <div class="similarity-score">
                                            ${Math.round(rule.similarity * 100)}% Similar
                                        </div>
                                        <h4>${rule.name}</h4>
                                        <p>${rule.description}</p>
                                        <pre class="rule-dsl">${rule.dsl_text}</pre>
                                        <div class="rule-actions">
                                            <button class="btn-small" onclick="loadRuleIntoEditor('${rule.id}', \`${rule.dsl_text}\`)">
                                                📋 Load in Editor
                                            </button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                addToOutput('error', `Failed to find similar rules: ${error.message || error}`);
            }
        }

        function loadRuleIntoEditor(ruleId, dslText) {
            editor.setValue(dslText);
            editor.currentRuleId = ruleId;
            addToOutput('info', `Loaded rule ${ruleId} into editor`);
        }

        function viewRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule) {
                alert(`Rule: ${rule.ruleName}\n\nDefinition would be displayed here`);
            }
        }

        function testRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule) {
                addToOutput('info', `Testing rule ${ruleId}: ${rule.ruleName}`);
                // In production, would execute the rule with test data
            }
        }

        function duplicateRule(ruleId) {
            const rule = rulesCatalogue.rules.find(r => r.ruleId === ruleId);
            if (rule) {
                const newRule = { ...rule, ruleId: `RULE_${Date.now()}`, ruleName: rule.ruleName + ' (Copy)' };
                rulesCatalogue.rules.push(newRule);
                showRulesCatalogue();
                addToOutput('success', `Duplicated rule ${ruleId} as ${newRule.ruleId}`);
            }
        }

        async function refreshRulesCatalogue() {
            await loadRulesCatalogue();
            showRulesCatalogue();
        }

        // Make functions globally available
        window.showRulesCatalogue = showRulesCatalogue;
        window.filterRules = filterRules;
        window.addNewRule = addNewRule;
        window.editRule = editRule;
        window.viewRule = viewRule;
        window.testRule = testRule;
        window.duplicateRule = duplicateRule;
        window.refreshRulesCatalogue = refreshRulesCatalogue;

        window.goToLine = function(line) {
            editor.revealLineInCenter(line);
            editor.setPosition({ lineNumber: line, column: 1 });
            editor.focus();
        };

        // Make functions available globally
        window.runCode = runCode;
        window.validateCode = validateCode;
        window.formatCode = formatCode;
        window.explainCode = explainCode;
        window.connectToLSP = connectToLSP;
        window.clearOutput = clearOutput;
        // Settings Modal Functions
        async function showSettings() {
            const existingModal = document.getElementById('settings-modal');
            if (existingModal) {
                existingModal.style.display = 'block';
                checkSystemKeys();
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'settings-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>AI Assistant Settings</h2>
                        <span class="close" onclick="closeSettings()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="setting-group">
                            <label>AI Provider:</label>
                            <select id="ai-provider" onchange="updateProviderSettings()">
                                <option value="openai">OpenAI (GPT-4)</option>
                                <option value="anthropic">Anthropic (Claude)</option>
                            </select>
                        </div>

                        <div class="setting-group">
                            <label id="api-key-label">OpenAI API Key:</label>
                            <input type="password"
                                   id="api-key-input"
                                   placeholder="sk-... (leave empty to use system key)"
                                   value="${localStorage.getItem('ai_api_key') || ''}">
                            <small>Leave empty to use system environment variables (ANTHROPIC_API_KEY, OPENAI_API_KEY).<br>
                                   Manual entry will override system keys. Keys are stored locally and never sent to any server except the AI provider.</small>
                        </div>

                        <div class="setting-group">
                            <label>Model:</label>
                            <select id="ai-model">
                                <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                            </select>
                        </div>

                        <div class="setting-actions">
                            <button class="btn" onclick="saveSettings()">Save Settings</button>
                            <button class="btn secondary" onclick="testAPIKey()">Test Connection</button>
                        </div>

                        <div id="settings-status"></div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Load saved settings
            const savedProvider = localStorage.getItem('ai_provider') || 'anthropic';
            document.getElementById('ai-provider').value = savedProvider;
            updateProviderSettings();

            // Check for system keys
            checkSystemKeys();
        }

        async function checkSystemKeys() {
            if (!window.__TAURI__ || !window.__TAURI__.invoke) {
                return;
            }

            try {
                const systemKeys = await window.__TAURI__.invoke('get_api_keys');
                const statusDiv = document.getElementById('settings-status');

                if (systemKeys) {
                    let detectedKeys = [];
                    if (systemKeys.anthropic) {
                        detectedKeys.push('ANTHROPIC_API_KEY');
                        // Auto-select Anthropic if system key found
                        if (!localStorage.getItem('ai_api_key')) {
                            document.getElementById('ai-provider').value = 'anthropic';
                            updateProviderSettings();
                        }
                    }
                    if (systemKeys.openai) {
                        detectedKeys.push('OPENAI_API_KEY');
                    }

                    if (detectedKeys.length > 0) {
                        showSettingsStatus(
                            `✅ System API keys detected: ${detectedKeys.join(', ')}. ` +
                            `The AI Agent will use these automatically unless you override with manual settings.`,
                            'success'
                        );
                    }
                }
            } catch (error) {
                console.log('Could not check for system keys:', error);
            }
        }

        function closeSettings() {
            const modal = document.getElementById('settings-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function updateProviderSettings() {
            const provider = document.getElementById('ai-provider').value;
            const label = document.getElementById('api-key-label');
            const input = document.getElementById('api-key-input');
            const modelSelect = document.getElementById('ai-model');

            if (provider === 'anthropic') {
                label.textContent = 'Anthropic API Key:';
                input.placeholder = 'sk-ant-...';
                modelSelect.innerHTML = `
                    <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                    <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
                    <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                `;
            } else {
                label.textContent = 'OpenAI API Key:';
                input.placeholder = 'sk-...';
                modelSelect.innerHTML = `
                    <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                `;
            }
        }

        function saveSettings() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const provider = document.getElementById('ai-provider').value;
            const model = document.getElementById('ai-model').value;

            if (apiKey) {
                localStorage.setItem('ai_api_key', apiKey);
                localStorage.setItem('ai_provider', provider);
                localStorage.setItem('ai_model', model);
                showSettingsStatus('Settings saved successfully!', 'success');
            } else {
                showSettingsStatus('Please enter an API key', 'error');
            }
        }

        async function testAPIKey() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const provider = document.getElementById('ai-provider').value;

            if (!apiKey) {
                showSettingsStatus('Please enter an API key first', 'error');
                return;
            }

            showSettingsStatus('Testing connection...', 'info');

            try {
                // Test the API key with a simple request
                const context = getAgentContext();
                const response = await callAIAgent('Hello, can you confirm you are working?', context);

                if (response && !response.includes('API call failed')) {
                    showSettingsStatus('✓ Connection successful! AI assistant is ready.', 'success');
                } else {
                    showSettingsStatus('Connection failed. Please check your API key.', 'error');
                }
            } catch (error) {
                showSettingsStatus(`Connection failed: ${error.message}`, 'error');
            }
        }

        function showSettingsStatus(message, type) {
            const statusDiv = document.getElementById('settings-status');
            statusDiv.className = `status-message ${type}`;
            statusDiv.textContent = message;
        }

        // Create New Derived Attribute Functions
        function showCreateAttributeDialog() {
            const existingModal = document.getElementById('create-attribute-modal');
            if (existingModal) {
                existingModal.style.display = 'block';
                return;
            }

            // Get list of business attributes
            const businessAttrs = getBusinessAttributes();

            const modal = document.createElement('div');
            modal.id = 'create-attribute-modal';
            modal.className = 'modal';
            modal.style.display = 'block';

            modal.innerHTML = `
                <div class="modal-overlay" onclick="closeCreateAttribute()"></div>
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Create New Derived Attribute</h2>
                        <span class="close" onclick="closeCreateAttribute()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="attr-name">Attribute Name:</label>
                            <input type="text" id="attr-name" placeholder="e.g., risk_score, client_category" />
                        </div>

                        <div class="form-group">
                            <label for="attr-type">Return Type:</label>
                            <select id="attr-type">
                                <option value="string">String</option>
                                <option value="number">Number</option>
                                <option value="boolean">Boolean</option>
                                <option value="list">List</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label>Select Dependencies (Business Attributes):</label>
                            <div style="max-height: 200px; overflow-y: auto; border: 1px solid #444; padding: 10px; background: #2d2d30;">
                                ${businessAttrs.map(attr => `
                                    <label style="display: block; margin: 5px 0; cursor: pointer;">
                                        <input type="checkbox" value="${attr.name}" onchange="updateAttributeDependencies()">
                                        <span style="margin-left: 5px;">${attr.name} (${attr.type})</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Selected Dependencies:</label>
                            <div id="selected-deps" style="padding: 10px; background: #2d2d30; min-height: 30px; border-radius: 4px;">
                                <em style="color: #888;">None selected</em>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="attr-description">Description:</label>
                            <textarea id="attr-description" rows="3" placeholder="Describe what this attribute calculates..."></textarea>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeCreateAttribute()">Cancel</button>
                        <button class="btn btn-primary" onclick="createDerivedAttribute()">Create Attribute</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeCreateAttribute() {
            const modal = document.getElementById('create-attribute-modal');
            if (modal) {
                modal.remove();
            }
        }

        function updateAttributeDependencies() {
            const checkboxes = document.querySelectorAll('#create-attribute-modal input[type="checkbox"]:checked');
            const selectedDepsDiv = document.getElementById('selected-deps');

            if (checkboxes.length === 0) {
                selectedDepsDiv.innerHTML = '<em style="color: #888;">None selected</em>';
            } else {
                const deps = Array.from(checkboxes).map(cb => cb.value);
                selectedDepsDiv.innerHTML = deps.join(', ');
            }
        }

        function getBusinessAttributes() {
            // Get the current business attributes from the data dictionary
            const attrList = document.querySelectorAll('#attribute-list .attribute-item');
            const attrs = [];

            attrList.forEach(item => {
                const name = item.querySelector('.attr-name')?.textContent;
                const type = item.querySelector('.attr-type')?.textContent;
                if (name && !name.includes('→')) { // Exclude derived attributes
                    attrs.push({ name, type: type || 'String' });
                }
            });

            // If no attributes loaded yet, use defaults
            if (attrs.length === 0) {
                return [
                    { name: 'Client.client_id', type: 'String' },
                    { name: 'Client.age', type: 'Number' },
                    { name: 'Client.income', type: 'Number' },
                    { name: 'Client.country_code', type: 'String' },
                    { name: 'Client.risk_tolerance', type: 'String' },
                    { name: 'Account.account_type', type: 'String' },
                    { name: 'Account.balance', type: 'Number' },
                    { name: 'Account.is_active', type: 'Boolean' },
                    { name: 'Transaction.amount', type: 'Number' },
                    { name: 'Transaction.type', type: 'String' }
                ];
            }

            return attrs;
        }

        function createDerivedAttribute() {
            const name = document.getElementById('attr-name').value.trim();
            const type = document.getElementById('attr-type').value;
            const description = document.getElementById('attr-description').value.trim();
            const checkboxes = document.querySelectorAll('#create-attribute-modal input[type="checkbox"]:checked');
            const dependencies = Array.from(checkboxes).map(cb => cb.value);

            if (!name) {
                alert('Please enter an attribute name');
                return;
            }

            if (dependencies.length === 0) {
                alert('Please select at least one dependency');
                return;
            }

            // Store the current rule context
            window.currentRuleContext = {
                ruleName: name,
                returnType: type,
                description: description,
                dependencies: dependencies
            };

            // Load dependencies into the rules engine context
            loadDependenciesToContext(name, dependencies);

            // Create a rule template using the selected dependencies
            const ruleTemplate = createRuleTemplate(name, type, dependencies);

            // Add to the attribute list in the sidebar
            addDerivedAttributeToSidebar(name, type, dependencies);

            // Update the main tab FIRST to show the current rule
            const mainTab = document.getElementById('main-tab');
            console.log('Looking for main-tab element...');
            console.log('Main tab found:', mainTab);

            if (!mainTab) {
                // If no main tab, try to find it by class
                const tabs = document.querySelectorAll('.tab');
                console.log('Found tabs:', tabs);
                if (tabs.length > 0) {
                    const firstTab = tabs[0];
                    firstTab.id = 'main-tab';
                    console.log('Set ID on first tab');
                }
            }

            // Try again after setting ID
            const updatedMainTab = document.getElementById('main-tab');
            if (updatedMainTab) {
                console.log('Updating tab text from:', updatedMainTab.textContent, 'to:', name);

                // Update tab text and styling
                updatedMainTab.textContent = name;
                updatedMainTab.setAttribute('data-file', `${name}.dsl`);
                updatedMainTab.setAttribute('data-attribute-name', name);
                updatedMainTab.classList.add('active');

                // Visual indicator for derived attribute
                updatedMainTab.style.fontWeight = 'bold';
                updatedMainTab.style.color = '#4ec9b0';
                updatedMainTab.style.borderBottom = '2px solid #4ec9b0';

                console.log('Tab should now show:', updatedMainTab.textContent);

                // Force a repaint
                updatedMainTab.offsetHeight;
            } else {
                console.error('Could not find or create main tab!');
            }

            // Load the rule template into the editor
            console.log('Attempting to load template into editor...');
            console.log('Template content:', ruleTemplate);

            // Check both local and window scope for editor
            const editorInstance = editor || window.editor;

            if (editorInstance) {
                // Store the rule content for this attribute
                if (!window.attributeRules) {
                    window.attributeRules = {};
                }
                window.attributeRules[name] = ruleTemplate;

                console.log('Editor instance found, setting value...');

                // Clear editor first to ensure refresh
                editorInstance.setValue('');

                // Set the new template
                editorInstance.setValue(ruleTemplate);

                // Force editor to refresh and focus
                editorInstance.layout();
                editorInstance.focus();

                // Trigger a change event to ensure Monaco updates
                editorInstance.trigger('createDerivedAttribute', 'editor.action.formatDocument');

                // Store that we're in attribute editing mode
                window.currentEditMode = 'derived_attribute';
                window.currentAttributeName = name;

                console.log('✅ Editor loaded with rule for:', name);
                console.log('✅ Editor current value:', editorInstance.getValue().substring(0, 200));
            } else {
                console.error('❌ Editor not found! Cannot set template.');
                console.error('Local editor:', typeof editor);
                console.error('Window editor:', typeof window.editor);
            }

            // Close the modal
            closeCreateAttribute();

            // Show success message
            addToOutput('console', `✅ Created new derived attribute: ${name}`);
            addToOutput('console', `Dependencies: ${dependencies.join(', ')}`);
            addToOutput('console', `📝 Rule context loaded with ${dependencies.length} business attributes`);
        }

        function loadDependenciesToContext(ruleName, dependencies) {
            // Initialize the test context with the selected dependencies
            const testContext = {};

            // Load sample values for each dependency (for testing)
            dependencies.forEach(dep => {
                // Parse the attribute name to get entity and field
                const parts = dep.split('.');

                // Set sample values based on type inference from name
                if (dep.includes('_id') || dep.includes('client_id')) {
                    testContext[dep] = 'CUST_12345';
                } else if (dep.includes('age')) {
                    testContext[dep] = 35;
                } else if (dep.includes('income') || dep.includes('balance') || dep.includes('amount')) {
                    testContext[dep] = 50000;
                } else if (dep.includes('is_') || dep.includes('has_')) {
                    testContext[dep] = true;
                } else if (dep.includes('type') || dep.includes('category') || dep.includes('status')) {
                    testContext[dep] = 'standard';
                } else if (dep.includes('country')) {
                    testContext[dep] = 'USA';
                } else {
                    testContext[dep] = 'sample_value';
                }
            });

            // Store the context for rule testing
            window.ruleTestContext = testContext;

            // Update the test data display
            updateTestDataDisplay(testContext);

            console.log('Loaded rule context:', {
                ruleName: ruleName,
                dependencies: dependencies,
                testContext: testContext
            });
        }

        function updateTestDataDisplay(context) {
            // Find or create a test data panel
            let testDataPanel = document.getElementById('test-data-panel');

            if (!testDataPanel) {
                // Create test data panel in the output area
                const outputPanel = document.getElementById('output-panel');
                if (outputPanel) {
                    const testDataDiv = document.createElement('div');
                    testDataDiv.id = 'test-data-panel';
                    testDataDiv.style.cssText = 'padding: 10px; border-bottom: 1px solid #444; background: #1e1e1e;';
                    testDataDiv.innerHTML = '<h4 style="margin: 0 0 10px 0; color: #4ec9b0;">Test Data Context:</h4>';
                    outputPanel.insertBefore(testDataDiv, outputPanel.firstChild);
                    testDataPanel = testDataDiv;
                }
            }

            if (testDataPanel) {
                let html = '<h4 style="margin: 0 0 10px 0; color: #4ec9b0;">Test Data Context:</h4>';
                html += '<div style="font-family: monospace; font-size: 12px;">';

                Object.entries(context).forEach(([key, value]) => {
                    const displayValue = typeof value === 'string' ? `"${value}"` : value;
                    html += `<div style="margin: 2px 0;"><span style="color: #9cdcfe;">${key}</span> = <span style="color: #ce9178;">${displayValue}</span></div>`;
                });

                html += '</div>';
                html += '<div style="margin-top: 10px; font-size: 11px; color: #888;">These values will be used when testing your rule</div>';

                testDataPanel.innerHTML = html;
            }
        }

        function createRuleTemplate(name, type, dependencies) {
            // Create a template rule based on type and dependencies
            let template = `// Derived Attribute: ${name}\n`;
            template += `// Type: ${type}\n`;
            template += `// Dependencies: ${dependencies.join(', ')}\n\n`;

            // List available source attributes with their test values
            template += `// Available Source Attributes:\n`;
            dependencies.forEach(dep => {
                const testValue = window.ruleTestContext ? window.ruleTestContext[dep] : '<runtime value>';
                const displayValue = typeof testValue === 'string' ? `"${testValue}"` : testValue;
                template += `// ${dep} = ${displayValue}\n`;
            });
            template += '\n';

            // Start the rule with the attribute name
            template += `// Define your rule:\n`;

            // Create a basic rule structure based on type
            if (type === 'boolean') {
                template += `${name} = ${dependencies[0]} > 100  // Modify this condition\n`;
            } else if (type === 'number') {
                if (dependencies.length > 1) {
                    template += `${name} = ${dependencies[0]} + ${dependencies[1]}  // Modify this calculation\n`;
                } else {
                    template += `${name} = ${dependencies[0]} * 1.1  // Modify this calculation\n`;
                }
            } else if (type === 'string') {
                template += `${name} = IF ${dependencies[0]} > 100 THEN "High" ELSE "Low"  // Modify this logic\n`;
            } else {
                template += `${name} = [${dependencies.join(', ')}]  // Modify this list\n`;
            }

            template += `\n// Available functions:\n`;
            template += `// - CONCAT(str1, str2, ...)  // Concatenate strings\n`;
            template += `// - SUBSTRING(str, start, end)  // Extract substring\n`;
            template += `// - LOOKUP(key, table)  // Look up value in table\n`;
            template += `// - UPPER(str), LOWER(str)  // Change case\n`;
            template += `// - IF condition THEN value ELSE value  // Conditional logic\n`;

            return template;
        }


        function addDerivedAttributeToSidebar(name, type, dependencies) {
            const attrList = document.getElementById('attribute-list');

            // Create new attribute item
            const li = document.createElement('li');
            li.className = 'attribute-item derived';
            li.innerHTML = `
                <span class="attr-name">→ ${name}</span>
                <span class="attr-type">${type}</span>
                <div style="font-size: 11px; color: #888; margin-top: 2px;">
                    Deps: ${dependencies.slice(0, 2).join(', ')}${dependencies.length > 2 ? '...' : ''}
                </div>
            `;

            // Add click handler to load this rule
            li.onclick = () => {
                // Load this attribute's rule into the editor
                if (window.attributeRules && window.attributeRules[name]) {
                    // Update the main tab
                    const mainTab = document.getElementById('main-tab');
                    if (mainTab) {
                        mainTab.innerHTML = '';
                        mainTab.appendChild(document.createTextNode(name));
                        mainTab.setAttribute('data-file', `${name}.dsl`);
                        mainTab.setAttribute('data-attribute-name', name);
                        mainTab.style.fontWeight = 'bold';
                        mainTab.style.color = '#4ec9b0';
                        mainTab.style.borderBottom = '2px solid #4ec9b0';
                    }

                    // Load the rule content
                    if (window.editor) {
                        window.editor.setValue(window.attributeRules[name]);
                    }

                    // Update current context
                    window.currentEditMode = 'derived_attribute';
                    window.currentAttributeName = name;

                    // Reload test context if available
                    if (window.currentRuleContext && window.currentRuleContext.ruleName === name) {
                        loadDependenciesToContext(name, window.currentRuleContext.dependencies);
                    }

                    addToOutput('console', `📝 Loaded rule: ${name}`);
                } else {
                    // No saved rule, just insert the attribute name
                    insertText(name);
                }
            };

            // Add to top of list
            attrList.insertBefore(li, attrList.firstChild);
        }

        // Make functions available globally
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.updateProviderSettings = updateProviderSettings;
        window.saveSettings = saveSettings;
        window.testAPIKey = testAPIKey;
        window.showCreateAttributeDialog = showCreateAttributeDialog;
        window.closeCreateAttribute = closeCreateAttribute;
        window.createDerivedAttribute = createDerivedAttribute;
        window.updateAttributeDependencies = updateAttributeDependencies;

        // Resizable Panes Implementation
        function initializeResizablePanes() {
            const sidebar = document.getElementById('sidebar');
            const editorContainer = document.getElementById('editor-container');
            const outputPanel = document.getElementById('output-panel');
            const verticalSplitter = document.getElementById('splitter-vertical');
            const horizontalSplitter = document.getElementById('splitter-horizontal');
            const mainContainer = document.querySelector('.main-container');

            let isResizingVertical = false;
            let isResizingHorizontal = false;

            // Vertical splitter (between sidebar and editor)
            verticalSplitter.addEventListener('mousedown', (e) => {
                isResizingVertical = true;
                verticalSplitter.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            // Horizontal splitter (between editor and output)
            horizontalSplitter.addEventListener('mousedown', (e) => {
                isResizingHorizontal = true;
                horizontalSplitter.classList.add('dragging');
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isResizingVertical) {
                    const containerRect = mainContainer.getBoundingClientRect();
                    const newWidth = e.clientX - containerRect.left;

                    // Enforce min/max constraints
                    if (newWidth >= 150 && newWidth <= 500) {
                        sidebar.style.width = newWidth + 'px';
                        // Save preference
                        localStorage.setItem('sidebar-width', newWidth);
                    }
                }

                if (isResizingHorizontal) {
                    const containerRect = editorContainer.getBoundingClientRect();
                    const editorElement = document.getElementById('monaco-editor');
                    const newHeight = containerRect.bottom - e.clientY;

                    // Enforce min/max constraints for output panel
                    if (newHeight >= 100 && newHeight <= 500) {
                        outputPanel.style.height = newHeight + 'px';
                        // Adjust editor height
                        const availableHeight = containerRect.height - newHeight - 5; // 5px for splitter
                        editorElement.style.height = availableHeight + 'px';

                        // Trigger Monaco resize
                        if (window.editor) {
                            window.editor.layout();
                        }

                        // Save preference
                        localStorage.setItem('output-height', newHeight);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizingVertical) {
                    isResizingVertical = false;
                    verticalSplitter.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }

                if (isResizingHorizontal) {
                    isResizingHorizontal = false;
                    horizontalSplitter.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });

            // Restore saved dimensions
            const savedSidebarWidth = localStorage.getItem('sidebar-width');
            if (savedSidebarWidth) {
                sidebar.style.width = savedSidebarWidth + 'px';
            }

            const savedOutputHeight = localStorage.getItem('output-height');
            if (savedOutputHeight) {
                outputPanel.style.height = savedOutputHeight + 'px';
                const containerRect = editorContainer.getBoundingClientRect();
                const editorElement = document.getElementById('monaco-editor');
                const availableHeight = containerRect.height - parseInt(savedOutputHeight) - 5;
                editorElement.style.height = availableHeight + 'px';
            }

            // Handle window resize
            window.addEventListener('resize', () => {
                if (window.editor) {
                    window.editor.layout();
                }
            });
        }

        // Initialize resizable panes after DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeResizablePanes);
        } else {
            // DOM already loaded
            setTimeout(initializeResizablePanes, 100);
        }
        // Tab switching for output panels
        document.addEventListener('DOMContentLoaded', () => {
            const outputTabs = document.querySelectorAll('.output-tab');
            outputTabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    const panel = e.target.dataset.panel;

                    // Remove active class from all tabs
                    outputTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');

                    // Hide all panels
                    document.getElementById('output-content').style.display = panel === 'ast' ? 'none' : 'block';
                    const astPanel = document.getElementById('ast-panel');
                    if (astPanel) {
                        astPanel.style.display = panel === 'ast' ? 'block' : 'none';
                    }

                    // Handle specific panels
                    if (panel === 'output' || panel === 'problems' || panel === 'agent' || panel === 'rules') {
                        // These panels use the output-content div
                    }
                });
            });
        });
    </script>

    <style>
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #2d2d30;
            margin: 10% auto;
            padding: 0;
            border: 1px solid #444;
            border-radius: 8px;
            width: 500px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #e8e8e8;
        }

        .close {
            color: #999;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
        }

        .close:hover {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            color: #cccccc;
            font-weight: 500;
        }

        .setting-group input[type="password"],
        .setting-group select {
            width: 100%;
            padding: 8px 12px;
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e8e8e8;
            font-size: 14px;
        }

        .setting-group small {
            display: block;
            margin-top: 5px;
            color: #999;
            font-size: 12px;
        }

        .setting-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status-message.success {
            background: #1b5e20;
            color: #a5d6a7;
            border: 1px solid #2e7d32;
        }

        .status-message.error {
            background: #b71c1c;
            color: #ef9a9a;
            border: 1px solid #c62828;
        }

        .status-message.info {
            background: #0d47a1;
            color: #90caf9;
            border: 1px solid #1565c0;
        }
        /* Rules Catalogue Styles */
        .rules-catalogue-container {
            height: 100%;
            overflow-y: auto;
            padding: 15px;
        }

        /* Similar Rules Styles */
        .similar-rules-container {
            height: 100%;
            overflow-y: auto;
            padding: 15px;
        }

        .similar-rules-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .similar-rule-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            position: relative;
        }

        .similarity-score {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .similar-rule-card h4 {
            margin: 0 0 10px 0;
            color: #e0e0e0;
        }

        .similar-rule-card p {
            margin: 10px 0;
            color: #b0b0b0;
        }

        .rule-dsl {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            color: #4ade80;
            overflow-x: auto;
        }

        .rules-catalogue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .rules-catalogue-header h3 {
            margin: 0;
            color: #e8e8e8;
        }

        .rules-actions {
            display: flex;
            gap: 10px;
        }

        .rules-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .rules-filters select,
        .rules-filters input {
            padding: 6px 10px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            color: #cccccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .rules-filters input {
            flex: 1;
            min-width: 200px;
        }

        .rules-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 15px;
        }

        .rule-card {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            padding: 15px;
            transition: all 0.2s;
        }

        .rule-card:hover {
            border-color: #007acc;
            box-shadow: 0 2px 8px rgba(0, 122, 204, 0.2);
        }

        .rule-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .rule-id {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #969696;
            background: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .rule-status {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
        }

        .rule-status.active {
            background: #1b5e20;
            color: #a5d6a7;
        }

        .rule-status.draft {
            background: #e65100;
            color: #ffcc80;
        }

        .rule-status.inactive {
            background: #424242;
            color: #9e9e9e;
        }

        .rule-name {
            margin: 0 0 8px 0;
            color: #e8e8e8;
            font-size: 16px;
        }

        .rule-description {
            margin: 0 0 15px 0;
            color: #969696;
            font-size: 13px;
            line-height: 1.4;
        }

        .rule-attributes {
            margin-bottom: 15px;
        }

        .attribute-group {
            margin-bottom: 10px;
        }

        .attribute-group label {
            display: block;
            font-size: 11px;
            color: #969696;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .attribute-tag {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .attribute-tag.business {
            background: #1565c0;
            color: #90caf9;
            border: 1px solid #1976d2;
        }

        .attribute-tag.derived {
            background: #2e7d32;
            color: #a5d6a7;
            border: 1px solid #388e3c;
        }

        .rule-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
            background: #3c3c3c;
            color: #cccccc;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-small:hover {
            background: #505050;
            border-color: #007acc;
        }

        .btn-small.secondary {
            background: transparent;
            border-color: #3e3e42;
        }

        .btn-small.secondary:hover {
            background: #3c3c3c;
        }

        /* AST Visualization Styles */
        .ast-view-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #858585;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .ast-view-tab:hover {
            color: #d4d4d4;
        }

        .ast-view-tab.active {
            color: #007acc;
            border-bottom-color: #007acc;
        }

        .ast-view {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
        }

        .ast-node {
            margin: 2px 0;
            padding: 4px 8px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .ast-node:hover {
            background: #2d2d30;
        }

        .ast-node-type {
            color: #4ec9b0;
            font-weight: bold;
        }

        .ast-node-value {
            color: #ce9178;
        }

        .ast-node-metadata {
            color: #858585;
            font-size: 11px;
            margin-left: 20px;
        }
    </style>
</body>
</html>