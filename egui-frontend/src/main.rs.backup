use eframe::egui;
use data_designer_core::db::{
    init_db, DbPool,
    ClientBusinessUnit, CreateCbuRequest, CbuMemberDetail,
    DbOperations, DataDictionaryResponse, EmbeddingOperations, SimilarRule
};

mod code_editor;
use code_editor::{DslCodeEditor, DslLanguage};

mod ai_assistant;
use ai_assistant::{AiAssistant, AiProvider, AiSuggestion, SuggestionType};
use data_designer_core::{parser, evaluator, models::{Value, DataDictionary, ViewerState}, transpiler::{Transpiler, TranspilerOptions, TargetLanguage, DslTranspiler, DslRule, TranspileError}};
use std::collections::HashMap;
use tokio::runtime::Runtime;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use rust_decimal::prelude::*;
use sqlx::Row;
use regex::Regex;

fn main() -> Result<(), eframe::Error> {
    env_logger::init();

    println!("üöÄ Starting Data Designer - Pure Rust Edition!");
    println!("üîå Connecting to PostgreSQL database...");

    // Initialize database connection
    let rt = Arc::new(Runtime::new().expect("Failed to create Tokio runtime"));
    let pool = rt.block_on(async {
        match init_db().await {
            Ok(pool) => {
                println!("‚úÖ Database connected successfully");
                Some(pool)
            }
            Err(e) => {
                eprintln!("‚ùå Database connection failed: {}", e);
                eprintln!("   Continuing with offline mode...");
                None
            }
        }
    });

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1400.0, 900.0])
            .with_min_inner_size([1000.0, 600.0]),
        ..Default::default()
    };

    eframe::run_native(
        "Data Designer - Pure Rust + Database",
        options,
        Box::new(move |cc| {
            cc.egui_ctx.set_visuals(egui::Visuals::dark());
            Ok(Box::new(DataDesignerApp::new(pool, rt)))
        }),
    )
}

struct DataDesignerApp {
    current_tab: Tab,
    db_pool: Option<DbPool>,
    runtime: Arc<Runtime>,

    // Data
    cbus: Vec<ClientBusinessUnit>,
    selected_cbu: Option<usize>,

    // Attribute Dictionary Data
    data_dictionary: Option<DataDictionaryResponse>,
    attribute_search: String,

    // Attribute Filters
    filter_business: bool,
    filter_derived: bool,
    filter_system: bool,
    filter_required: bool,
    filter_optional: bool,
    filter_key: bool,

    // Rule Engine Data
    rules: Vec<serde_json::Value>,
    selected_rule: Option<usize>,

    // Rule Testing
    rule_input: String,
    test_context: String,
    rule_result: Option<String>,
    rule_error: Option<String>,

    // Syntax highlighting
    syntax_highlighter: SyntaxHighlighter,

    // Autocomplete
    show_autocomplete: bool,
    autocomplete_suggestions: Vec<String>,
    autocomplete_position: usize,

    // Vector search
    semantic_search_query: String,
    similar_rules: Vec<SimilarRule>,
    embedding_status: String,

    // Dictionary Viewer State
    dictionary_data: Option<DataDictionary>,
    viewer_state: ViewerState,
    dictionary_loaded: bool,
    // Transpiler State
    transpiler_input: String,
    transpiler_output: String,
    target_language: String,
    optimization_enabled: bool,
    transpiler_error: Option<String>,
    // Custom Code Editor
    dsl_editor: DslCodeEditor,
    output_editor: DslCodeEditor,

    // Enhanced DSL Transpiler
    dsl_transpiler: DslTranspiler,
    parsed_rules: Vec<DslRule>,
    transpile_errors: Vec<TranspileError>,
    multi_rule_mode: bool,
    // AI Assistant
    ai_assistant: AiAssistant,
    ai_suggestions: Vec<AiSuggestion>,
    ai_query: String,
    show_ai_panel: bool,
    ai_loading: bool,
    ai_api_key_input: String,
    show_api_key_input: bool,

    // White Truffle #4: Code Intelligence
    show_code_intelligence: bool,

    // AI Command Palette
    show_command_palette: bool,
    command_palette_input: String,
    command_suggestions: Vec<CommandSuggestion>,
    selected_command_index: usize,
    palette_loading: bool,

    // White Truffle #4: Enhanced Code Intelligence
    code_intelligence: CodeIntelligence,
    live_errors: Vec<LiveError>,
    code_metrics: CodeMetrics,
    refactoring_suggestions: Vec<RefactoringSuggestion>,
    show_intelligence_panel: bool,
    analysis_in_progress: bool,

    // White Truffle #5: Advanced Debugging & Testing Framework
    show_debug_panel: bool,
    debug_session: DebugSession,
    breakpoints: Vec<Breakpoint>,
    execution_state: ExecutionState,
    variable_inspector: VariableInspector,
    test_framework: TestFramework,
    test_results: Vec<TestResult>,
    coverage_data: CoverageData,

    // Resource Data Dictionary
    resource_dictionary: ResourceDictionaryManager,
    show_resource_dictionary: bool,
    selected_resource: Option<usize>,
    resource_search_query: String,

    // UI State
    show_cbu_form: bool,
    cbu_form: CbuForm,
    status_message: String,
    loading: bool,

    // CBU Expansion State
    expanded_cbus: std::collections::HashSet<String>, // Set of expanded CBU IDs
    cbu_members: std::collections::HashMap<String, Vec<CbuMemberDetail>>, // CBU ID -> Members

    // Taxonomy Data
    products: Vec<Product>,
    product_options: Vec<ProductOption>,
    services: Vec<Service>,
    resources: Vec<ResourceObject>,
    service_resource_hierarchy: Vec<ServiceResourceHierarchy>,
    investment_mandates: Vec<InvestmentMandate>,
    mandate_instruments: Vec<MandateInstrument>,
    instruction_formats: Vec<InstructionFormat>,
    cbu_mandate_structure: Vec<CbuInvestmentMandateStructure>,
    cbu_member_roles: Vec<CbuMemberInvestmentRole>,
    taxonomy_hierarchy: Vec<TaxonomyHierarchyItem>,
    selected_mandate: Option<String>, // Selected mandate ID for drill-down

    // Onboarding Requests - CBU + Product Bundle combinations
    onboarding_requests: Vec<OnboardingRequest>,
    onboarding_product_items: Vec<OnboardingProductItem>,
    onboarding_product_options: Vec<OnboardingProductOption>,

    // Editable Attributes State
    editable_attributes: Vec<EditableAttribute>,
    modified_attributes: std::collections::HashSet<i32>, // Track changed attribute IDs
    edit_mode: bool,
    show_save_button: bool,

    // CBU Tree State
    cbu_tree: Option<CbuTreeNode>,
    selected_cbu_node: Option<String>, // Selected CBU ID
    show_cbu_editor: bool,

    // Editing State for Product Taxonomy
    edit_mode_products: bool,
    edit_mode_services: bool,
    edit_mode_options: bool,
    pending_changes: bool,
    save_feedback: Option<String>, // Success/error messages

    // Advanced Find & Replace (White Truffle #3)
    show_find_replace: bool,
    find_query: String,
    replace_query: String,
    search_mode: SearchMode,
    case_sensitive: bool,
    use_regex: bool,
    whole_words_only: bool,
    search_results: Vec<SearchResult>,
    current_result_index: usize,
    search_history: Vec<String>,
    ai_search_suggestions: Vec<String>,
    semantic_search_enabled: bool,
}

// CBU Tree Node for hierarchical representation
#[derive(Debug, Clone)]
struct CbuTreeNode {
    cbu: ClientBusinessUnit,
    children: Vec<CbuTreeNode>,
    is_expanded: bool,
    depth: usize,
}

// Advanced Find & Replace structures (White Truffle #3)
#[derive(Debug, Clone, PartialEq)]
enum SearchMode {
    Normal,     // Basic text search
    Regex,      // Regular expression search
    Semantic,   // AI-powered semantic search
    Fuzzy,      // Fuzzy matching search
}

#[derive(Debug, Clone)]
struct SearchResult {
    line_number: usize,
    column_start: usize,
    column_end: usize,
    matched_text: String,
    context_before: String,
    context_after: String,
    similarity_score: Option<f64>, // For semantic search
}

#[derive(Debug, Clone)]
struct SearchPattern {
    pattern: String,
    mode: SearchMode,
    case_sensitive: bool,
    use_regex: bool,
    whole_words_only: bool,
    timestamp: std::time::SystemTime,
}

// White Truffle #4: Enhanced Code Intelligence structures
#[derive(Debug, Clone)]
struct CodeIntelligence {
    last_analysis: Option<std::time::SystemTime>,
    ast_cache: Option<String>, // Cached AST representation
    syntax_errors: Vec<SyntaxError>,
    warnings: Vec<CodeWarning>,
    suggestions: Vec<IntelligentSuggestion>,
    hover_info: Option<HoverInfo>,
}

#[derive(Debug, Clone)]
struct LiveError {
    line: usize,
    column: usize,
    severity: ErrorSeverity,
    message: String,
    suggestion: Option<String>,
    error_type: ErrorType,
}

#[derive(Debug, Clone, PartialEq)]
enum ErrorSeverity {
    Error,
    Warning,
    Info,
    Hint,
}

#[derive(Debug, Clone)]
enum ErrorType {
    Syntax,
    Semantic,
    Type,
    Runtime,
    Style,
}

#[derive(Debug, Clone)]
struct CodeMetrics {
    complexity_score: f32,
    lines_of_code: usize,
    function_count: usize,
    variable_count: usize,
    operator_density: f32,
    readability_score: f32,
    performance_score: f32,
}

#[derive(Debug, Clone)]
struct RefactoringSuggestion {
    title: String,
    description: String,
    location: CodeLocation,
    confidence: f32,
    refactoring_type: RefactoringType,
    before_code: String,
    after_code: String,
}

#[derive(Debug, Clone)]
enum RefactoringType {
    SimplifyExpression,
    ExtractVariable,
    RemoveRedundancy,
    OptimizePerformance,
    ImproveReadability,
    FixTyping,
}

#[derive(Debug, Clone)]
struct CodeLocation {
    line_start: usize,
    line_end: usize,
    column_start: usize,
    column_end: usize,
}

#[derive(Debug, Clone)]
struct SyntaxError {
    position: CodeLocation,
    message: String,
    expected: Option<String>,
    found: Option<String>,
}

#[derive(Debug, Clone)]
struct CodeWarning {
    position: CodeLocation,
    message: String,
    category: WarningCategory,
}

#[derive(Debug, Clone)]
enum WarningCategory {
    Performance,
    Style,
    Best_Practice,
    Potential_Bug,
    Deprecated,
}

#[derive(Debug, Clone)]
struct IntelligentSuggestion {
    trigger: String, // What user typed to trigger this
    completion: String,
    description: String,
    documentation: Option<String>,
    snippet_type: SnippetType,
}

#[derive(Debug, Clone)]
enum SnippetType {
    Function,
    Variable,
    Operator,
    Keyword,
    Template,
}

#[derive(Debug, Clone)]
struct HoverInfo {
    title: String,
    documentation: String,
    examples: Vec<String>,
    related_functions: Vec<String>,
}

// White Truffle #5: Advanced Debugging & Testing Framework Structures

#[derive(Debug, Clone)]
struct DebugSession {
    is_active: bool,
    current_step: usize,
    total_steps: usize,
    execution_stack: Vec<ExecutionFrame>,
    current_variables: std::collections::HashMap<String, DebugValue>,
    session_id: Option<String>,
}

#[derive(Debug, Clone)]
struct ExecutionFrame {
    function_name: String,
    line_number: usize,
    column: usize,
    local_variables: std::collections::HashMap<String, DebugValue>,
    expression: String,
}

#[derive(Debug, Clone)]
struct DebugValue {
    value: String,
    data_type: String,
    is_complex: bool,
    children: Vec<DebugValue>,
}

#[derive(Debug, Clone)]
struct Breakpoint {
    id: usize,
    line: usize,
    column: usize,
    condition: Option<String>,
    hit_count: usize,
    enabled: bool,
    temporary: bool, // One-time breakpoint
}

#[derive(Debug, Clone)]
enum ExecutionState {
    Stopped,
    Running,
    Paused,
    SteppingOver,
    SteppingInto,
    SteppingOut,
    Error(String),
}

#[derive(Debug, Clone)]
struct VariableInspector {
    variables: std::collections::HashMap<String, DebugValue>,
    watch_expressions: Vec<WatchExpression>,
    expanded_variables: std::collections::HashSet<String>,
}

#[derive(Debug, Clone)]
struct WatchExpression {
    id: usize,
    expression: String,
    current_value: Option<DebugValue>,
    error: Option<String>,
}

#[derive(Debug, Clone)]
struct TestFramework {
    test_suites: Vec<TestSuite>,
    current_suite: Option<usize>,
    auto_generate_tests: bool,
    test_data_sets: Vec<TestDataSet>,
}

#[derive(Debug, Clone)]
struct TestSuite {
    id: usize,
    name: String,
    description: String,
    test_cases: Vec<TestCase>,
    setup_code: Option<String>,
    teardown_code: Option<String>,
}

#[derive(Debug, Clone)]
struct TestCase {
    id: usize,
    name: String,
    description: String,
    input_data: std::collections::HashMap<String, String>,
    expected_output: String,
    rule_expression: String,
    status: TestStatus,
    execution_time: Option<f64>,
    error_message: Option<String>,
}

#[derive(Debug, Clone)]
enum TestStatus {
    Pending,
    Running,
    Passed,
    Failed,
    Skipped,
    Error,
}

#[derive(Debug, Clone)]
struct TestResult {
    test_case_id: usize,
    suite_id: usize,
    status: TestStatus,
    actual_output: Option<String>,
    execution_time: f64,
    timestamp: std::time::SystemTime,
    error_details: Option<String>,
}

#[derive(Debug, Clone)]
struct TestDataSet {
    id: usize,
    name: String,
    description: String,
    data: std::collections::HashMap<String, String>,
    data_source: DataSource,
}

#[derive(Debug, Clone)]
enum DataSource {
    Manual,
    Database(String),
    File(String),
    Generated,
}

#[derive(Debug, Clone)]
struct CoverageData {
    total_lines: usize,
    covered_lines: usize,
    line_coverage: std::collections::HashMap<usize, bool>,
    branch_coverage: std::collections::HashMap<usize, BranchCoverage>,
    function_coverage: std::collections::HashMap<String, bool>,
}

#[derive(Debug, Clone)]
struct BranchCoverage {
    total_branches: usize,
    covered_branches: usize,
    branch_details: Vec<(usize, bool)>, // (branch_id, covered)
}

// Resource Data Dictionary Structures
#[derive(Debug, Clone)]
struct ResourceDataDictionary {
    id: usize,
    name: String,
    description: String,
    resource_type: ResourceType,
    attributes: Vec<ResourceAttribute>,
    metadata: ResourceMetadata,
    version: String,
    created_at: std::time::SystemTime,
    updated_at: std::time::SystemTime,
    status: ResourceStatus,
}

#[derive(Debug, Clone)]
enum ResourceType {
    Application,        // Apps like Reconciliation App, FA App
    Database,          // Database tables and schemas
    Integration,       // API endpoints, message queues
    UserInterface,     // Forms, dashboards, reports
    Workflow,          // Business process definitions
    Configuration,     // Settings, parameters, rules
    Document,          // Templates, contracts, agreements
    DataSet,          // Reference data, lookup tables
}

#[derive(Debug, Clone)]
struct ResourceAttribute {
    id: usize,
    name: String,
    display_name: String,
    description: String,
    data_type: AttributeDataType,
    attribute_category: AttributeCategory,
    is_required: bool,
    is_key: bool,
    default_value: Option<String>,
    validation_rules: Vec<ValidationRule>,
    business_context: String,
    technical_context: String,
    source_system: Option<String>,
    target_system: Option<String>,
    transformation_logic: Option<String>,
    ai_metadata: AttributeAiMetadata,
}

#[derive(Debug, Clone)]
enum AttributeDataType {
    String(Option<usize>),     // String with optional max length
    Integer,
    Decimal(u8, u8),          // Precision, scale
    Boolean,
    Date,
    DateTime,
    Time,
    Currency(String),         // Currency code
    Percentage,
    Email,
    Phone,
    URL,
    JSON,
    Binary,
    Enum(Vec<String>),        // Enumeration values
    Reference(String),        // Reference to another resource
}

#[derive(Debug, Clone)]
enum AttributeCategory {
    Business,     // Core business attributes
    System,       // System-generated attributes
    Derived,      // Calculated/derived attributes
    Audit,        // Audit trail attributes
    Metadata,     // Descriptive metadata
    Security,     // Security-related attributes
    Configuration, // Configuration parameters
}

#[derive(Debug, Clone)]
struct ValidationRule {
    rule_type: ValidationType,
    expression: String,
    error_message: String,
    severity: ValidationSeverity,
}

#[derive(Debug, Clone)]
enum ValidationType {
    Required,
    MinLength(usize),
    MaxLength(usize),
    MinValue(f64),
    MaxValue(f64),
    Regex(String),
    Custom(String),     // Custom validation expression
    CrossField(String), // Validation involving other fields
}

#[derive(Debug, Clone)]
enum ValidationSeverity {
    Error,      // Blocks processing
    Warning,    // Shows warning but allows processing
    Info,       // Informational only
}

#[derive(Debug, Clone)]
struct ResourceMetadata {
    owner: String,
    steward: String,
    classification: DataClassification,
    retention_period: Option<String>,
    access_level: AccessLevel,
    compliance_tags: Vec<String>,
    business_glossary_terms: Vec<String>,
    technical_tags: Vec<String>,
}

#[derive(Debug, Clone)]
enum DataClassification {
    Public,
    Internal,
    Confidential,
    Restricted,
    PersonalData,
    SensitivePersonalData,
}

#[derive(Debug, Clone)]
enum AccessLevel {
    Public,
    Authenticated,
    Authorized,
    Restricted,
    AdminOnly,
}

#[derive(Debug, Clone)]
enum ResourceStatus {
    Draft,
    Active,
    Deprecated,
    Retired,
    UnderReview,
}

#[derive(Debug, Clone)]
struct AttributeAiMetadata {
    semantic_description: String,
    business_examples: Vec<String>,
    common_transformations: Vec<String>,
    related_attributes: Vec<String>,
    ai_suggestions: Vec<String>,
    embedding: Option<Vec<f32>>, // Vector embedding for similarity search
}

#[derive(Debug, Clone)]
struct ResourceRelationship {
    from_resource_id: usize,
    to_resource_id: usize,
    relationship_type: RelationshipType,
    description: String,
    cardinality: Cardinality,
}

#[derive(Debug, Clone)]
enum RelationshipType {
    Contains,       // Resource contains other resources
    Uses,          // Resource uses/depends on other resources
    Derives,       // Resource derives from other resources
    Transforms,    // Resource transforms data from other resources
    Inherits,      // Resource inherits structure from other resources
    References,    // Resource references other resources
}

#[derive(Debug, Clone)]
enum Cardinality {
    OneToOne,
    OneToMany,
    ManyToOne,
    ManyToMany,
}

// Resource Dictionary Management
#[derive(Debug, Clone)]
struct ResourceDictionaryManager {
    dictionaries: Vec<ResourceDataDictionary>,
    relationships: Vec<ResourceRelationship>,
    search_index: std::collections::HashMap<String, Vec<usize>>, // keyword -> resource IDs
    category_index: std::collections::HashMap<ResourceType, Vec<usize>>,
    attribute_index: std::collections::HashMap<String, Vec<(usize, usize)>>, // attr_name -> (resource_id, attr_id)
}

// Default implementations for debugging structures
impl Default for DebugSession {
    fn default() -> Self {
        Self {
            is_active: false,
            current_step: 0,
            total_steps: 0,
            execution_stack: Vec::new(),
            current_variables: std::collections::HashMap::new(),
            session_id: None,
        }
    }
}

impl Default for ExecutionFrame {
    fn default() -> Self {
        Self {
            function_name: String::new(),
            line_number: 0,
            column: 0,
            local_variables: std::collections::HashMap::new(),
            expression: String::new(),
        }
    }
}

impl Default for DebugValue {
    fn default() -> Self {
        Self {
            value: String::new(),
            data_type: "unknown".to_string(),
            is_complex: false,
            children: Vec::new(),
        }
    }
}

impl Default for Breakpoint {
    fn default() -> Self {
        Self {
            id: 0,
            line: 0,
            column: 0,
            condition: None,
            hit_count: 0,
            enabled: true,
            temporary: false,
        }
    }
}

impl Default for ExecutionState {
    fn default() -> Self {
        Self::Stopped
    }
}

impl Default for VariableInspector {
    fn default() -> Self {
        Self {
            variables: std::collections::HashMap::new(),
            watch_expressions: Vec::new(),
            expanded_variables: std::collections::HashSet::new(),
        }
    }
}

impl Default for WatchExpression {
    fn default() -> Self {
        Self {
            id: 0,
            expression: String::new(),
            current_value: None,
            error: None,
        }
    }
}

impl Default for TestFramework {
    fn default() -> Self {
        Self {
            test_suites: Vec::new(),
            current_suite: None,
            auto_generate_tests: false,
            test_data_sets: Vec::new(),
        }
    }
}

impl Default for TestSuite {
    fn default() -> Self {
        Self {
            id: 0,
            name: "New Test Suite".to_string(),
            description: String::new(),
            test_cases: Vec::new(),
            setup_code: None,
            teardown_code: None,
        }
    }
}

impl Default for TestCase {
    fn default() -> Self {
        Self {
            id: 0,
            name: "New Test Case".to_string(),
            description: String::new(),
            input_data: std::collections::HashMap::new(),
            expected_output: String::new(),
            rule_expression: String::new(),
            status: TestStatus::Pending,
            execution_time: None,
            error_message: None,
        }
    }
}

impl Default for TestStatus {
    fn default() -> Self {
        Self::Pending
    }
}

impl Default for TestResult {
    fn default() -> Self {
        Self {
            test_case_id: 0,
            suite_id: 0,
            status: TestStatus::Pending,
            actual_output: None,
            execution_time: 0.0,
            timestamp: std::time::SystemTime::now(),
            error_details: None,
        }
    }
}

impl Default for TestDataSet {
    fn default() -> Self {
        Self {
            id: 0,
            name: "New Data Set".to_string(),
            description: String::new(),
            data: std::collections::HashMap::new(),
            data_source: DataSource::Manual,
        }
    }
}

impl Default for DataSource {
    fn default() -> Self {
        Self::Manual
    }
}

impl Default for CoverageData {
    fn default() -> Self {
        Self {
            total_lines: 0,
            covered_lines: 0,
            line_coverage: std::collections::HashMap::new(),
            branch_coverage: std::collections::HashMap::new(),
            function_coverage: std::collections::HashMap::new(),
        }
    }
}

impl Default for BranchCoverage {
    fn default() -> Self {
        Self {
            total_branches: 0,
            covered_branches: 0,
            branch_details: Vec::new(),
        }
    }
}

// Default implementations for resource data dictionary structures
impl Default for ResourceDataDictionary {
    fn default() -> Self {
        Self {
            id: 0,
            name: "New Resource".to_string(),
            description: String::new(),
            resource_type: ResourceType::Application,
            attributes: Vec::new(),
            metadata: ResourceMetadata::default(),
            version: "1.0.0".to_string(),
            created_at: std::time::SystemTime::now(),
            updated_at: std::time::SystemTime::now(),
            status: ResourceStatus::Draft,
        }
    }
}

impl Default for ResourceType {
    fn default() -> Self {
        Self::Application
    }
}

impl Default for ResourceAttribute {
    fn default() -> Self {
        Self {
            id: 0,
            name: "new_attribute".to_string(),
            display_name: "New Attribute".to_string(),
            description: String::new(),
            data_type: AttributeDataType::String(None),
            attribute_category: AttributeCategory::Business,
            is_required: false,
            is_key: false,
            default_value: None,
            validation_rules: Vec::new(),
            business_context: String::new(),
            technical_context: String::new(),
            source_system: None,
            target_system: None,
            transformation_logic: None,
            ai_metadata: AttributeAiMetadata::default(),
        }
    }
}

impl Default for AttributeDataType {
    fn default() -> Self {
        Self::String(None)
    }
}

impl Default for AttributeCategory {
    fn default() -> Self {
        Self::Business
    }
}

impl Default for ValidationRule {
    fn default() -> Self {
        Self {
            rule_type: ValidationType::Required,
            expression: String::new(),
            error_message: "Validation failed".to_string(),
            severity: ValidationSeverity::Error,
        }
    }
}

impl Default for ValidationType {
    fn default() -> Self {
        Self::Required
    }
}

impl Default for ValidationSeverity {
    fn default() -> Self {
        Self::Error
    }
}

impl Default for ResourceMetadata {
    fn default() -> Self {
        Self {
            owner: "Unknown".to_string(),
            steward: "Unknown".to_string(),
            classification: DataClassification::Internal,
            retention_period: None,
            access_level: AccessLevel::Authenticated,
            compliance_tags: Vec::new(),
            business_glossary_terms: Vec::new(),
            technical_tags: Vec::new(),
        }
    }
}

impl Default for DataClassification {
    fn default() -> Self {
        Self::Internal
    }
}

impl Default for AccessLevel {
    fn default() -> Self {
        Self::Authenticated
    }
}

impl Default for ResourceStatus {
    fn default() -> Self {
        Self::Draft
    }
}

impl Default for AttributeAiMetadata {
    fn default() -> Self {
        Self {
            semantic_description: String::new(),
            business_examples: Vec::new(),
            common_transformations: Vec::new(),
            related_attributes: Vec::new(),
            ai_suggestions: Vec::new(),
            embedding: None,
        }
    }
}

impl Default for ResourceRelationship {
    fn default() -> Self {
        Self {
            from_resource_id: 0,
            to_resource_id: 0,
            relationship_type: RelationshipType::Uses,
            description: String::new(),
            cardinality: Cardinality::OneToMany,
        }
    }
}

impl Default for RelationshipType {
    fn default() -> Self {
        Self::Uses
    }
}

impl Default for Cardinality {
    fn default() -> Self {
        Self::OneToMany
    }
}

impl Default for ResourceDictionaryManager {
    fn default() -> Self {
        Self {
            dictionaries: Vec::new(),
            relationships: Vec::new(),
            search_index: std::collections::HashMap::new(),
            category_index: std::collections::HashMap::new(),
            attribute_index: std::collections::HashMap::new(),
        }
    }
}

// Default implementations for code intelligence
impl Default for CodeIntelligence {
    fn default() -> Self {
        Self {
            last_analysis: None,
            ast_cache: None,
            syntax_errors: Vec::new(),
            warnings: Vec::new(),
            suggestions: Vec::new(),
            hover_info: None,
        }
    }
}

impl Default for CodeMetrics {
    fn default() -> Self {
        Self {
            complexity_score: 0.0,
            lines_of_code: 0,
            function_count: 0,
            variable_count: 0,
            operator_density: 0.0,
            readability_score: 0.0,
            performance_score: 0.0,
        }
    }
}

// Editable attribute structure for change tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
struct EditableAttribute {
    id: i32,
    attribute_name: String,
    full_path: String,
    data_type: String,
    description: Option<String>,
    attribute_type: String,
    entity_name: String,
    is_key: bool,
    is_nullable: bool,
    // Track if this attribute has been modified
    is_dirty: bool,
    // Original values for comparison
    original_description: Option<String>,
    original_data_type: String,
}

impl EditableAttribute {
    fn from_json_value(value: &serde_json::Value, id: i32) -> Self {
        Self {
            id,
            attribute_name: value.get("attribute_name").and_then(|v| v.as_str()).unwrap_or("").to_string(),
            full_path: value.get("full_path").and_then(|v| v.as_str()).unwrap_or("").to_string(),
            data_type: value.get("data_type").and_then(|v| v.as_str()).unwrap_or("").to_string(),
            description: value.get("description").and_then(|v| v.as_str()).map(|s| s.to_string()),
            attribute_type: value.get("attribute_type").and_then(|v| v.as_str()).unwrap_or("").to_string(),
            entity_name: value.get("entity_name").and_then(|v| v.as_str()).unwrap_or("").to_string(),
            is_key: value.get("is_key").and_then(|v| v.as_bool()).unwrap_or(false),
            is_nullable: value.get("is_nullable").and_then(|v| v.as_bool()).unwrap_or(false),
            is_dirty: false,
            original_description: value.get("description").and_then(|v| v.as_str()).map(|s| s.to_string()),
            original_data_type: value.get("data_type").and_then(|v| v.as_str()).unwrap_or("").to_string(),
        }
    }

    fn mark_dirty_if_changed(&mut self) {
        self.is_dirty =
            self.description != self.original_description ||
            self.data_type != self.original_data_type;
    }
}

#[derive(PartialEq, Default)]
enum Tab {
    #[default]
    Dashboard,
    CBUs,
    CbuTaxonomyEditor, // New CBU Tree Editor
    AttributeDictionary,
    DictionaryViewer,  // New tab for the JSON viewer
    RuleEngine,
    Transpiler,        // New tab for code generation
    Database,
    // New taxonomy tabs
    ProductTaxonomy,   // Products ‚Üí Options ‚Üí Services ‚Üí Resources
    InvestmentMandates, // Investment mandates with CBU roles
    TaxonomyHierarchy, // Complete hierarchy view
}

#[derive(Default)]
struct CbuForm {
    cbu_name: String,
    description: String,
    primary_entity_id: String,
    primary_lei: String,
    domicile_country: String,
    business_type: String,
}

// AI Command Palette Structures
#[derive(Debug, Clone)]
struct CommandSuggestion {
    command_type: CommandType,
    title: String,
    description: String,
    action: String,
    shortcut: Option<String>,
    confidence: f32,
}

#[derive(Debug, Clone, PartialEq)]
enum CommandType {
    GenerateDsl,
    AnalyzeRule,
    OptimizeExpression,
    FindSimilar,
    ExplainError,
    NavigateTo,
    QuickAction,
    Template,
}

impl CommandSuggestion {
    fn new(command_type: CommandType, title: &str, description: &str, action: &str) -> Self {
        Self {
            command_type,
            title: title.to_string(),
            description: description.to_string(),
            action: action.to_string(),
            shortcut: None,
            confidence: 1.0,
        }
    }

    fn with_shortcut(mut self, shortcut: &str) -> Self {
        self.shortcut = Some(shortcut.to_string());
        self
    }

    fn with_confidence(mut self, confidence: f32) -> Self {
        self.confidence = confidence;
        self
    }
}

// Taxonomy Database Structs
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Product {
    id: i32,
    product_id: String,
    product_name: String,
    line_of_business: String,
    description: Option<String>,
    status: String,
    contract_type: Option<String>,
    commercial_status: Option<String>,
    pricing_model: Option<String>,
    target_market: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ProductOption {
    id: i32,
    option_id: String,
    product_id: i32,
    option_name: String,
    option_category: String,
    option_type: String,
    option_value: serde_json::Value,
    display_name: Option<String>,
    description: Option<String>,
    pricing_impact: Option<rust_decimal::Decimal>,
    status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Service {
    id: i32,
    service_id: String,
    service_name: String,
    service_category: Option<String>,
    description: Option<String>,
    service_type: Option<String>,
    delivery_model: Option<String>,
    billable: Option<bool>,
    status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct InvestmentMandate {
    mandate_id: String,
    cbu_id: String,
    asset_owner_name: String,
    asset_owner_lei: String,
    investment_manager_name: String,
    investment_manager_lei: String,
    base_currency: String,
    effective_date: String,
    expiry_date: Option<String>,
    gross_exposure_pct: Option<f64>,
    net_exposure_pct: Option<f64>,
    leverage_max: Option<f64>,
}

// Onboarding Request - Basket of foreign keys representing CBU + Product Bundle combination
#[derive(Debug, Clone, Serialize, Deserialize)]
struct OnboardingRequest {
    id: i32,
    onboarding_request_id: String,              // Primary key: "ORQ-2024-001"
    cbu_id: String,                             // FK to CBU
    cbu_name: String,                           // Denormalized for display
    product_bundle: Vec<OnboardingProductItem>, // Basket of products with options
    request_date: String,                       // ISO date
    requested_by: String,                       // Entity making the request
    status: String,                             // "pending", "approved", "rejected", "in_progress", "completed"
    priority: String,                           // "urgent", "high", "normal", "low"
    expected_go_live_date: Option<String>,      // Target launch date
    estimated_setup_time_days: Option<i32>,    // Business estimate
    approval_workflow_stage: String,            // "intake", "review", "approval", "implementation"
    assigned_relationship_manager: Option<String>,
    estimated_annual_revenue: Option<f64>,     // Business value estimate
    complexity_score: Option<i32>,             // 1-10 complexity rating
    notes: Option<String>,
}

// Individual product item in an onboarding request basket
#[derive(Debug, Clone, Serialize, Deserialize)]
struct OnboardingProductItem {
    id: i32,
    onboarding_request_id: String,             // FK to OnboardingRequest
    product_id: i32,                           // FK to Product
    product_name: String,                      // Denormalized for display
    selected_options: Vec<OnboardingProductOption>, // Selected product options
    estimated_volume: Option<String>,          // Expected transaction volume
    go_live_priority: String,                  // "phase1", "phase2", "phase3"
    special_requirements: Option<String>,      // Custom needs
}

// Selected product option within an onboarding product item
#[derive(Debug, Clone, Serialize, Deserialize)]
struct OnboardingProductOption {
    id: i32,
    onboarding_product_item_id: i32,          // FK to OnboardingProductItem
    option_id: String,                         // FK to ProductOption
    option_name: String,                       // Denormalized for display
    option_value: serde_json::Value,           // Selected configuration
    custom_configuration: Option<String>,      // Any custom settings
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct MandateInstrument {
    id: i32,
    mandate_id: String,
    instrument_family: String,
    subtype: Option<String>,
    cfi_code: Option<String>,
    exposure_pct: Option<f64>,
    short_allowed: Option<bool>,
    issuer_max_pct: Option<f64>,
    rating_floor: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct InstructionFormat {
    id: i32,
    format_id: String,
    format_name: String,
    format_category: Option<String>,
    message_standard: Option<String>,
    message_type: Option<String>,
    status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct CbuInvestmentMandateStructure {
    cbu_id: String,
    cbu_name: String,
    mandate_id: Option<String>,
    asset_owner_name: Option<String>,
    investment_manager_name: Option<String>,
    base_currency: Option<String>,
    total_instruments: Option<i64>,
    families: Option<String>,
    total_exposure_pct: Option<rust_decimal::Decimal>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct CbuMemberInvestmentRole {
    cbu_id: String,
    cbu_name: String,
    entity_name: String,
    entity_lei: Option<String>,
    role_name: String,
    role_code: String,
    investment_responsibility: String,
    mandate_id: Option<String>,
    has_trading_authority: Option<bool>,
    has_settlement_authority: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ResourceObject {
    id: i32,
    resource_name: String,
    description: Option<String>,
    version: String,
    category: Option<String>,
    resource_type: Option<String>,
    criticality_level: Option<String>,
    operational_status: Option<String>,
    owner_team: Option<String>,
    status: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceResourceHierarchy {
    // Service Information
    service_id: i32,
    service_code: String,
    service_name: String,
    service_category: Option<String>,
    service_type: Option<String>,
    delivery_model: Option<String>,
    billable: Option<bool>,
    service_description: Option<String>,
    service_status: Option<String>,

    // Resource Information
    resource_id: i32,
    resource_name: String,
    resource_description: Option<String>,
    resource_version: String,
    resource_category: Option<String>,
    resource_type: Option<String>,
    criticality_level: Option<String>,
    operational_status: Option<String>,
    owner_team: Option<String>,

    // Mapping Details
    usage_type: String,
    resource_role: Option<String>,
    cost_allocation_percentage: Option<rust_decimal::Decimal>,
    dependency_level: Option<i32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct TaxonomyHierarchyItem {
    level: i32,
    item_type: String,
    item_id: i32,
    item_name: String,
    item_description: Option<String>,
    parent_id: Option<i32>,
    configuration: Option<serde_json::Value>,
    metadata: Option<serde_json::Value>,
}

// Syntax highlighting for DSL
#[derive(Debug, Clone)]
struct SyntaxToken {
    start: usize,
    end: usize,
    token_type: TokenType,
}

#[derive(Debug, Clone, Copy)]
enum TokenType {
    Keyword,      // IF, THEN, ELSE, AND, OR, NOT
    Function,     // CONCAT, UPPER, ABS, etc.
    Operator,     // +, -, *, /, =, >, <, etc.
    String,       // "text", 'text'
    Number,       // 123, 45.67
    Boolean,      // true, false
    Identifier,   // variable names
    Comment,      // // comments
    Regex,        // /pattern/
    Delimiter,    // (, ), [, ], {, }
}

struct SyntaxHighlighter {
    keywords: Vec<&'static str>,
    functions: Vec<&'static str>,
    operators: Vec<&'static str>,
}

impl SyntaxHighlighter {
    fn new() -> Self {
        Self {
            keywords: vec![
                "IF", "THEN", "ELSE", "WHEN", "AND", "OR", "NOT", "IN", "NOT_IN",
                "MATCHES", "NOT_MATCHES", "CONTAINS", "STARTS_WITH", "ENDS_WITH",
                "true", "false", "null"
            ],
            functions: vec![
                "CONCAT", "SUBSTRING", "UPPER", "LOWER", "LENGTH", "TRIM",
                "ABS", "ROUND", "FLOOR", "CEIL", "MIN", "MAX", "SUM", "AVG", "COUNT",
                "HAS", "IS_NULL", "IS_EMPTY", "TO_STRING", "TO_NUMBER", "TO_BOOLEAN",
                "FIRST", "LAST", "GET", "LOOKUP"
            ],
            operators: vec![
                "+", "-", "*", "/", "%", "**", "&", "=", "!=", "<>", "<", "<=", ">", ">=",
                "&&", "||", "==", "MATCHES", "CONTAINS"
            ],
        }
    }

    fn tokenize(&self, text: &str) -> Vec<SyntaxToken> {
        let mut tokens = Vec::new();
        let mut chars = text.char_indices().peekable();

        while let Some((start, ch)) = chars.next() {
            match ch {
                // String literals
                '"' | '\'' => {
                    let quote = ch;
                    let mut end = start + 1;
                    let mut escaped = false;

                    while let Some((pos, ch)) = chars.next() {
                        end = pos + ch.len_utf8();
                        if !escaped && ch == quote {
                            break;
                        }
                        escaped = ch == '\\' && !escaped;
                    }

                    tokens.push(SyntaxToken {
                        start,
                        end,
                        token_type: TokenType::String,
                    });
                }

                // Regex literals
                '/' => {
                    if let Some((_, next_ch)) = chars.peek() {
                        if *next_ch != '/' && *next_ch != '=' && *next_ch != '*' {
                            // Likely a regex
                            let mut end = start + 1;
                            while let Some((pos, ch)) = chars.next() {
                                end = pos + ch.len_utf8();
                                if ch == '/' {
                                    break;
                                }
                            }

                            tokens.push(SyntaxToken {
                                start,
                                end,
                                token_type: TokenType::Regex,
                            });
                            continue;
                        }
                    }

                    // Regular operator
                    tokens.push(SyntaxToken {
                        start,
                        end: start + 1,
                        token_type: TokenType::Operator,
                    });
                }

                // Numbers
                '0'..='9' => {
                    let mut end = start;
                    let mut has_dot = false;

                    while let Some((pos, ch)) = chars.peek() {
                        if ch.is_ascii_digit() {
                            end = *pos + ch.len_utf8();
                            chars.next();
                        } else if *ch == '.' && !has_dot {
                            has_dot = true;
                            end = *pos + ch.len_utf8();
                            chars.next();
                        } else {
                            break;
                        }
                    }

                    tokens.push(SyntaxToken {
                        start,
                        end,
                        token_type: TokenType::Number,
                    });
                }

                // Identifiers, keywords, functions
                ch if ch.is_alphabetic() || ch == '_' => {
                    let mut end = start;

                    while let Some((pos, ch)) = chars.peek() {
                        if ch.is_alphanumeric() || *ch == '_' || *ch == '.' {
                            end = *pos + ch.len_utf8();
                            chars.next();
                        } else {
                            break;
                        }
                    }

                    let word = &text[start..end];
                    let token_type = if self.keywords.contains(&word.to_uppercase().as_str()) {
                        TokenType::Keyword
                    } else if self.functions.contains(&word.to_uppercase().as_str()) {
                        TokenType::Function
                    } else {
                        TokenType::Identifier
                    };

                    tokens.push(SyntaxToken {
                        start,
                        end,
                        token_type,
                    });
                }

                // Operators and delimiters
                '+' | '-' | '*' | '%' | '=' | '!' | '<' | '>' | '&' | '|' => {
                    let mut end = start + ch.len_utf8();

                    // Check for multi-character operators
                    if let Some((pos, next_ch)) = chars.peek() {
                        let two_char = format!("{}{}", ch, next_ch);
                        if self.operators.contains(&two_char.as_str()) {
                            end = *pos + next_ch.len_utf8();
                            chars.next();
                        }
                    }

                    tokens.push(SyntaxToken {
                        start,
                        end,
                        token_type: TokenType::Operator,
                    });
                }

                // Delimiters
                '(' | ')' | '[' | ']' | '{' | '}' | ',' => {
                    tokens.push(SyntaxToken {
                        start,
                        end: start + ch.len_utf8(),
                        token_type: TokenType::Delimiter,
                    });
                }

                // Skip whitespace
                _ if ch.is_whitespace() => continue,

                // Everything else as identifier for now
                _ => {
                    tokens.push(SyntaxToken {
                        start,
                        end: start + ch.len_utf8(),
                        token_type: TokenType::Identifier,
                    });
                }
            }
        }

        tokens
    }

    fn get_color(&self, token_type: TokenType) -> egui::Color32 {
        match token_type {
            TokenType::Keyword => egui::Color32::from_rgb(197, 134, 192),    // Purple
            TokenType::Function => egui::Color32::from_rgb(78, 201, 176),    // Teal
            TokenType::Operator => egui::Color32::from_rgb(86, 156, 214),    // Blue
            TokenType::String => egui::Color32::from_rgb(206, 145, 120),     // Orange
            TokenType::Number => egui::Color32::from_rgb(181, 206, 168),     // Green
            TokenType::Boolean => egui::Color32::from_rgb(86, 156, 214),     // Blue
            TokenType::Identifier => egui::Color32::from_rgb(220, 220, 170), // Yellow
            TokenType::Comment => egui::Color32::from_rgb(106, 153, 85),     // Dark Green
            TokenType::Regex => egui::Color32::from_rgb(215, 186, 125),      // Gold
            TokenType::Delimiter => egui::Color32::from_rgb(128, 128, 128),  // Gray
        }
    }

    fn get_autocomplete_suggestions(&self, partial_word: &str) -> Vec<String> {
        let mut suggestions = Vec::new();
        let partial_upper = partial_word.to_uppercase();

        // Add matching keywords
        for &keyword in &self.keywords {
            if keyword.starts_with(&partial_upper) {
                suggestions.push(keyword.to_string());
            }
        }

        // Add matching functions
        for &function in &self.functions {
            if function.starts_with(&partial_upper) {
                suggestions.push(format!("{}()", function));
            }
        }

        // Add common attribute suggestions
        let common_attributes = vec![
            "age", "balance", "country", "email", "name", "id", "status",
            "amount", "date", "type", "value", "score", "rating", "level"
        ];

        for attr in common_attributes {
            if attr.to_uppercase().starts_with(&partial_upper) {
                suggestions.push(attr.to_string());
            }
        }

        suggestions.sort();
        suggestions.dedup();
        suggestions.truncate(10); // Limit to 10 suggestions
        suggestions
    }
}

impl DataDesignerApp {
    fn new(db_pool: Option<DbPool>, runtime: Arc<Runtime>) -> Self {
        let ai_assistant = if let Some(ref pool) = db_pool {
            AiAssistant::new()
                .with_provider(AiProvider::Offline)
                .with_env_api_keys()
                .load_keys_from_keychain()  // Load securely stored keys
                .with_database(pool.clone())
        } else {
            AiAssistant::new()
                .with_provider(AiProvider::Offline)
                .with_env_api_keys()
                .load_keys_from_keychain()  // Load securely stored keys
        };

        let mut app = Self {
            current_tab: Tab::default(),
            db_pool,
            runtime,
            cbus: Vec::new(),
            selected_cbu: None,
            data_dictionary: None,
            attribute_search: String::new(),

            // Initialize attribute filters (all enabled by default)
            filter_business: true,
            filter_derived: true,
            filter_system: true,
            filter_required: true,
            filter_optional: true,
            filter_key: true,
            rules: Vec::new(),
            selected_rule: None,
            rule_input: String::from("age > 18 AND country = \"USA\""),
            test_context: String::from("{\n  \"age\": 25,\n  \"country\": \"USA\",\n  \"balance\": 50000\n}"),
            rule_result: None,
            rule_error: None,
            syntax_highlighter: SyntaxHighlighter::new(),
            show_autocomplete: false,
            autocomplete_suggestions: Vec::new(),
            autocomplete_position: 0,
            semantic_search_query: String::new(),
            similar_rules: Vec::new(),
            embedding_status: "Ready for semantic search".to_string(),
            dictionary_data: None,
            viewer_state: ViewerState::default(),
            dictionary_loaded: false,
            transpiler_input: "price * quantity + tax".to_string(),
            transpiler_output: String::new(),
            target_language: "Rust".to_string(),
            optimization_enabled: true,
            transpiler_error: None,
            dsl_editor: DslCodeEditor::new()
                .with_text("price * quantity + tax")
                .with_language(DslLanguage::Dsl)
                .with_rows(12)
                .with_font_size(16.0)
                .show_line_numbers(true),
            output_editor: DslCodeEditor::new()
                .with_language(DslLanguage::Rust)
                .with_rows(15)
                .with_font_size(16.0)
                .show_line_numbers(true),

            // Enhanced DSL Transpiler
            dsl_transpiler: DslTranspiler::new(),
            parsed_rules: Vec::new(),
            transpile_errors: Vec::new(),
            multi_rule_mode: false,

            ai_assistant,
            ai_suggestions: Vec::new(),
            ai_query: String::new(),
            show_ai_panel: true,
            ai_loading: false,
            ai_api_key_input: String::new(),
            show_api_key_input: false,

            // White Truffle #4: Code Intelligence
            show_code_intelligence: false,

            // AI Command Palette
            show_command_palette: false,
            command_palette_input: String::new(),
            command_suggestions: Vec::new(),
            selected_command_index: 0,
            palette_loading: false,

            // White Truffle #4: Enhanced Code Intelligence
            code_intelligence: CodeIntelligence::default(),
            live_errors: Vec::new(),
            code_metrics: CodeMetrics::default(),
            refactoring_suggestions: Vec::new(),
            show_intelligence_panel: true,
            analysis_in_progress: false,

            // White Truffle #5: Advanced Debugging & Testing Framework
            show_debug_panel: false,
            debug_session: DebugSession::default(),
            breakpoints: Vec::new(),
            execution_state: ExecutionState::default(),
            variable_inspector: VariableInspector::default(),
            test_framework: TestFramework::default(),
            test_results: Vec::new(),
            coverage_data: CoverageData::default(),

            // Resource Data Dictionary
            resource_dictionary: ResourceDictionaryManager::default(),
            show_resource_dictionary: false,
            selected_resource: None,
            resource_search_query: String::new(),

            show_cbu_form: false,
            cbu_form: CbuForm::default(),
            status_message: "Initializing...".to_string(),
            loading: false,
            expanded_cbus: std::collections::HashSet::new(),
            cbu_members: std::collections::HashMap::new(),

            // Initialize taxonomy data
            products: Vec::new(),
            product_options: Vec::new(),
            services: Vec::new(),
            resources: Vec::new(),
            service_resource_hierarchy: Vec::new(),
            investment_mandates: Vec::new(),
            mandate_instruments: Vec::new(),
            instruction_formats: Vec::new(),
            cbu_mandate_structure: Vec::new(),
            cbu_member_roles: Vec::new(),
            taxonomy_hierarchy: Vec::new(),
            selected_mandate: None,

            // Onboarding Requests
            onboarding_requests: Vec::new(),
            onboarding_product_items: Vec::new(),
            onboarding_product_options: Vec::new(),

            // Editable Attributes State
            editable_attributes: Vec::new(),
            modified_attributes: std::collections::HashSet::new(),
            edit_mode: false,
            show_save_button: false,

            // CBU Tree State
            cbu_tree: None,
            selected_cbu_node: None,
            show_cbu_editor: false,

            // Editing State for Product Taxonomy
            edit_mode_products: false,
            edit_mode_services: false,
            edit_mode_options: false,
            pending_changes: false,
            save_feedback: None,

            // Advanced Find & Replace (White Truffle #3)
            show_find_replace: false,
            find_query: String::new(),
            replace_query: String::new(),
            search_mode: SearchMode::Normal,
            case_sensitive: false,
            use_regex: false,
            whole_words_only: false,
            search_results: Vec::new(),
            current_result_index: 0,
            search_history: Vec::new(),
            ai_search_suggestions: Vec::new(),
            semantic_search_enabled: false,
        };

        // Load initial data
        app.load_cbus();
        app.load_data_dictionary();
        app.load_product_taxonomy();
        app.load_investment_mandates();
        app
    }

    fn load_cbus(&mut self) {
        if let Some(ref pool) = self.db_pool {
            self.loading = true;
            self.status_message = "Loading CBUs from database...".to_string();

            let _pool = pool.clone();
            let rt = self.runtime.clone();

            match rt.block_on(async {
                DbOperations::list_cbus().await
            }) {
                Ok(cbu_summaries) => {
                    // Convert summaries to full CBUs - for now just create basic ones
                    self.cbus = cbu_summaries.into_iter().map(|summary| ClientBusinessUnit {
                        id: summary.id,
                        cbu_id: summary.cbu_id,
                        cbu_name: summary.cbu_name,
                        description: summary.description,
                        primary_entity_id: None,
                        primary_lei: None,
                        domicile_country: None,
                        regulatory_jurisdiction: None,
                        business_type: None,
                        status: summary.status,
                        created_date: None,
                        last_review_date: None,
                        next_review_date: None,
                        created_by: None,
                        created_at: summary.created_at,
                        updated_by: None,
                        updated_at: summary.updated_at,
                        metadata: None,
                    }).collect();

                    self.status_message = format!("‚úÖ Loaded {} CBUs from database", self.cbus.len());
                }
                Err(e) => {
                    eprintln!("Failed to load CBUs: {}", e);
                    self.status_message = format!("‚ùå Failed to load CBUs: {}", e);
                    self.load_sample_data();
                }
            }
            self.loading = false;
        } else {
            self.load_sample_data();
        }
    }

    fn load_sample_data(&mut self) {
        use chrono::Utc;

        self.cbus = vec![
            ClientBusinessUnit {
                id: 0,
                cbu_id: "OFFLINE001".to_string(),
                cbu_name: "Sample CBU (Offline Mode)".to_string(),
                description: Some("No database connection - sample data".to_string()),
                primary_entity_id: None,
                primary_lei: None,
                domicile_country: None,
                regulatory_jurisdiction: None,
                business_type: None,
                status: "Sample".to_string(),
                created_date: None,
                last_review_date: None,
                next_review_date: None,
                created_by: None,
                created_at: Utc::now(),
                updated_by: None,
                updated_at: Utc::now(),
                metadata: None,
            }
        ];
        self.status_message = "‚ö†Ô∏è Offline mode - using sample data".to_string();
    }

    fn load_cbu_members(&mut self, cbu_id: &str) {
        if let Some(ref _pool) = self.db_pool {
            let rt = self.runtime.clone();
            let cbu_id_owned = cbu_id.to_string();

            match rt.block_on(async {
                DbOperations::get_cbu_members(&cbu_id_owned).await
            }) {
                Ok(members) => {
                    self.cbu_members.insert(cbu_id_owned, members);
                    self.status_message = format!("‚úÖ Loaded members for CBU {}", cbu_id);
                }
                Err(e) => {
                    eprintln!("Failed to load CBU members: {}", e);
                    self.status_message = format!("‚ùå Failed to load members: {}", e);
                }
            }
        }
    }

    fn create_cbu(&mut self) {
        if let Some(ref _pool) = self.db_pool {
            let request = CreateCbuRequest {
                cbu_name: self.cbu_form.cbu_name.clone(),
                description: if self.cbu_form.description.is_empty() { None } else { Some(self.cbu_form.description.clone()) },
                primary_entity_id: if self.cbu_form.primary_entity_id.is_empty() { None } else { Some(self.cbu_form.primary_entity_id.clone()) },
                primary_lei: if self.cbu_form.primary_lei.is_empty() { None } else { Some(self.cbu_form.primary_lei.clone()) },
                domicile_country: if self.cbu_form.domicile_country.is_empty() { None } else { Some(self.cbu_form.domicile_country.clone()) },
                regulatory_jurisdiction: None,
                business_type: if self.cbu_form.business_type.is_empty() { None } else { Some(self.cbu_form.business_type.clone()) },
                created_by: Some("egui-app".to_string()),
            };

            let rt = self.runtime.clone();
            match rt.block_on(async {
                DbOperations::create_cbu(request).await
            }) {
                Ok(cbu) => {
                    self.cbus.push(cbu);
                    self.status_message = "‚úÖ CBU created successfully".to_string();
                    self.show_cbu_form = false;
                    self.cbu_form = CbuForm::default();
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Failed to create CBU: {}", e);
                }
            }
        } else {
            self.status_message = "‚ùå No database connection".to_string();
        }
    }

    fn load_data_dictionary(&mut self) {
        // Load JSON dictionary for viewer
        self.load_json_dictionary();

        // Load database dictionary for existing functionality
        if let Some(ref _pool) = self.db_pool {
            let rt = self.runtime.clone();

            match rt.block_on(async {
                let pool = DbOperations::get_pool().await.map_err(|e| e.to_string())?;
                use data_designer_core::db::DataDictionaryOperations;
                DataDictionaryOperations::get_data_dictionary(&pool, None).await
            }) {
                Ok(dictionary) => {
                    // Populate editable attributes
                    self.editable_attributes = dictionary.attributes.iter()
                        .enumerate()
                        .map(|(i, attr)| EditableAttribute::from_json_value(attr, i as i32))
                        .collect();

                    self.data_dictionary = Some(dictionary);
                }
                Err(e) => {
                    eprintln!("Failed to load data dictionary: {}", e);
                }
            }
        }
    }

    fn load_json_dictionary(&mut self) {
        match std::fs::read_to_string("test_data/source_attributes.json") {
            Ok(json_content) => {
                match DataDictionary::load_from_json(&json_content) {
                    Ok(dictionary) => {
                        self.dictionary_data = Some(dictionary);
                        self.dictionary_loaded = true;
                        println!("‚úÖ Dictionary JSON loaded successfully");
                    }
                    Err(e) => {
                        eprintln!("‚ùå Failed to parse dictionary JSON: {}", e);
                    }
                }
            }
            Err(e) => {
                eprintln!("‚ùå Failed to read test_data/source_attributes.json: {}", e);
                eprintln!("   Make sure the file exists in the project root");
            }
        }
    }
}

impl eframe::App for DataDesignerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Handle keyboard shortcuts for command palette and autocomplete
        ctx.input(|i| {
            if i.modifiers.command && i.key_pressed(egui::Key::K) {
                self.show_command_palette = !self.show_command_palette;
                if self.show_command_palette {
                    self.command_palette_input.clear();
                    self.generate_command_suggestions();
                }
            }

            // Ctrl+F / Cmd+F for Find & Replace (White Truffle #3)
            if i.modifiers.command && i.key_pressed(egui::Key::F) {
                self.show_find_replace = !self.show_find_replace;
                if self.show_find_replace {
                    self.generate_ai_search_suggestions();
                }
            }

            // Ctrl+I / Cmd+I for Code Intelligence (White Truffle #4)
            if i.modifiers.command && i.key_pressed(egui::Key::I) {
                self.show_code_intelligence = !self.show_code_intelligence;
                if self.show_code_intelligence {
                    self.perform_live_analysis();
                }
            }

            // Ctrl+D / Cmd+D for Debug Panel (White Truffle #5)
            if i.modifiers.command && i.key_pressed(egui::Key::D) {
                self.show_debug_panel = !self.show_debug_panel;
                if self.show_debug_panel && !self.debug_session.is_active {
                    self.generate_sample_debug_data();
                }
            }

            // Handle autocomplete navigation
            if self.dsl_editor.show_autocomplete {
                if i.key_pressed(egui::Key::ArrowUp) {
                    self.dsl_editor.navigate_autocomplete(-1);
                } else if i.key_pressed(egui::Key::ArrowDown) {
                    self.dsl_editor.navigate_autocomplete(1);
                } else if i.key_pressed(egui::Key::Enter) {
                    if let Some(suggestion) = self.dsl_editor.accept_autocomplete() {
                        // Insert suggestion at cursor position
                        self.apply_autocomplete_suggestion(&suggestion);
                    }
                } else if i.key_pressed(egui::Key::Escape) {
                    self.dsl_editor.hide_autocomplete();
                }
            } else if i.key_pressed(egui::Key::Escape) {
                // Escape to close command palette only if autocomplete is not open
                self.show_command_palette = false;
            }
        });

        // Command Palette Modal
        if self.show_command_palette {
            self.show_command_palette_modal(ctx);
        }

        // Find & Replace Modal (White Truffle #3)
        if self.show_find_replace {
            self.show_find_replace_modal(ctx);
        }

        // Top menu bar
        egui::TopBottomPanel::top("top_panel").show(ctx, |ui| {
            egui::MenuBar::new().ui(ui, |ui| {
                ui.menu_button("File", |ui| {
                    if ui.button("Exit").clicked() {
                        ui.close();
                    }
                });
                ui.menu_button("Database", |ui| {
                    if ui.button("Refresh").clicked() {
                        self.load_cbus();
                        ui.close();
                    }
                    if ui.button("Test Connection").clicked() {
                        if self.db_pool.is_some() {
                            self.status_message = "‚úÖ Database connected".to_string();
                        } else {
                            self.status_message = "‚ùå No database connection".to_string();
                        }
                        ui.close();
                    }
                });
            });
        });

        // Status bar
        egui::TopBottomPanel::bottom("status_panel").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.label("Status:");
                let color = if self.db_pool.is_some() {
                    egui::Color32::GREEN
                } else {
                    egui::Color32::YELLOW
                };
                ui.colored_label(color, &self.status_message);

                if self.loading {
                    ui.spinner();
                }
            });
        });

        // Tab panel
        egui::TopBottomPanel::top("tab_panel").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.selectable_value(&mut self.current_tab, Tab::Dashboard, "üè† Dashboard");
                ui.selectable_value(&mut self.current_tab, Tab::CBUs, "üè¢ CBUs");
                ui.selectable_value(&mut self.current_tab, Tab::CbuTaxonomyEditor, "üå≥ CBU Tree");
                ui.selectable_value(&mut self.current_tab, Tab::AttributeDictionary, "üìö Attributes");
                ui.selectable_value(&mut self.current_tab, Tab::DictionaryViewer, "üìã Dictionary Viewer");
                ui.selectable_value(&mut self.current_tab, Tab::RuleEngine, "‚ö° Rules");
                ui.selectable_value(&mut self.current_tab, Tab::Transpiler, "üîÑ Transpiler");
                ui.selectable_value(&mut self.current_tab, Tab::Database, "üóÑÔ∏è Database");
                ui.separator();
                ui.selectable_value(&mut self.current_tab, Tab::ProductTaxonomy, "üì¶ Product Taxonomy");
                ui.selectable_value(&mut self.current_tab, Tab::InvestmentMandates, "üéØ Investment Mandates");
                ui.selectable_value(&mut self.current_tab, Tab::TaxonomyHierarchy, "üèóÔ∏è Taxonomy Hierarchy");
            });
        });

        // Main content
        egui::CentralPanel::default().show(ctx, |ui| {
            match self.current_tab {
                Tab::Dashboard => self.show_dashboard(ui),
                Tab::CBUs => self.show_cbu_tab(ui),
                Tab::CbuTaxonomyEditor => self.show_cbu_tree_tab(ui),
                Tab::AttributeDictionary => self.show_attribute_dictionary_tab(ui),
                Tab::DictionaryViewer => self.show_dictionary_viewer_tab(ui),
                Tab::RuleEngine => self.show_rule_engine_tab(ui),
                Tab::Transpiler => self.show_transpiler_tab(ui),
                Tab::Database => self.show_database_tab(ui),
                Tab::ProductTaxonomy => self.show_product_taxonomy_tab(ui),
                Tab::InvestmentMandates => self.show_investment_mandates_tab(ui),
                Tab::TaxonomyHierarchy => self.show_taxonomy_hierarchy_tab(ui),
            }
        });

        // CBU form modal
        if self.show_cbu_form {
            egui::Window::new("Create CBU")
                .collapsible(false)
                .resizable(true)
                .show(ctx, |ui| {
                    self.show_cbu_form_ui(ui);
                });
        }
    }
}

impl DataDesignerApp {
    fn show_dashboard(&mut self, ui: &mut egui::Ui) {
        ui.heading("ü¶Ä Pure Rust Data Designer");

        ui.separator();

        ui.horizontal(|ui| {
            ui.label("Database Status:");
            if self.db_pool.is_some() {
                ui.colored_label(egui::Color32::GREEN, "‚úÖ Connected to PostgreSQL");
            } else {
                ui.colored_label(egui::Color32::YELLOW, "‚ö†Ô∏è Offline mode");
            }
        });

        ui.horizontal(|ui| {
            ui.label("CBUs Loaded:");
            ui.label(format!("{}", self.cbus.len()));
        });

        ui.separator();

        if ui.button("üîÑ Refresh Data").clicked() {
            self.load_cbus();
        }
    }

    fn show_cbu_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("Client Business Units");

        ui.horizontal(|ui| {
            if ui.button("‚ûï Create CBU").clicked() {
                self.show_cbu_form = true;
                self.cbu_form = CbuForm::default();
            }

            if ui.button("üîÑ Refresh").clicked() {
                self.load_cbus();
            }
        });

        ui.separator();

        // Expandable CBU list
        egui::ScrollArea::vertical().show(ui, |ui| {
            // Clone the CBUs to avoid borrowing issues
            let cbus_list = self.cbus.clone();
            let mut cbus_to_expand: Option<String> = None;
            let mut cbus_to_collapse: Option<String> = None;

            for cbu in cbus_list.iter() {
                let is_expanded = self.expanded_cbus.contains(&cbu.cbu_id);

                ui.push_id(&cbu.cbu_id, |ui| {
                    // CBU header row
                    ui.horizontal(|ui| {
                        // Expand/collapse button
                        let expand_button = if is_expanded { "üîΩ" } else { "‚ñ∂Ô∏è" };
                        if ui.button(expand_button).clicked() {
                            if is_expanded {
                                cbus_to_collapse = Some(cbu.cbu_id.clone());
                            } else {
                                cbus_to_expand = Some(cbu.cbu_id.clone());
                            }
                        }

                        // CBU basic info
                        ui.separator();
                        ui.label(format!("üè¢ {}", cbu.cbu_name));
                        ui.separator();
                        ui.label(format!("ID: {}", cbu.cbu_id));
                        ui.separator();
                        ui.label(format!("Status: {}", cbu.status));
                        ui.separator();
                        ui.label(format!("Type: {}", cbu.business_type.as_ref().unwrap_or(&"N/A".to_string())));
                    });

                    // Description row
                    if let Some(description) = &cbu.description {
                        ui.indent("desc", |ui| {
                            ui.label(format!("üìù {}", description));
                        });
                    }

                    // Expanded members section
                    if is_expanded {
                        ui.separator();

                        if let Some(members) = self.cbu_members.get(&cbu.cbu_id) {
                            ui.indent("members", |ui| {
                                ui.heading("üë• Entity Members & Roles");

                                if members.is_empty() {
                                    ui.label("No members found for this CBU");
                                } else {
                                    // Members table
                                    egui::Grid::new(format!("members_grid_{}", cbu.cbu_id))
                                        .striped(true)
                                        .show(ui, |ui| {
                                            // Header
                                            ui.label("üèóÔ∏è Entity");
                                            ui.label("üé≠ Role");
                                            ui.label("üÜî LEI");
                                            ui.label("üìß Contact");
                                            ui.label("‚≠ê Primary");
                                            ui.label("üõ°Ô∏è Authority");
                                            ui.end_row();

                                            // Member rows
                                            for member in members {
                                                ui.label(&member.entity_name);
                                                ui.label(&member.role_name);
                                                ui.label(member.entity_lei.as_ref().unwrap_or(&"N/A".to_string()));
                                                ui.label(member.contact_email.as_ref().unwrap_or(&"N/A".to_string()));
                                                ui.label(if member.is_primary { "‚≠ê Yes" } else { "No" });

                                                let authority = match (member.has_trading_authority, member.has_settlement_authority) {
                                                    (true, true) => "Trading + Settlement",
                                                    (true, false) => "Trading Only",
                                                    (false, true) => "Settlement Only",
                                                    (false, false) => "None"
                                                };
                                                ui.label(authority);
                                                ui.end_row();
                                            }
                                        });
                                }
                            });
                        } else {
                            ui.indent("loading", |ui| {
                                ui.label("üîÑ Loading entity members...");
                            });
                        }
                    }

                    ui.separator();
                });
            }

            // Handle expansion/collapse after the loop to avoid borrowing issues
            if let Some(cbu_id) = cbus_to_expand {
                self.expanded_cbus.insert(cbu_id.clone());
                // Load members if not already loaded
                if !self.cbu_members.contains_key(&cbu_id) {
                    self.load_cbu_members(&cbu_id);
                }
            }
            if let Some(cbu_id) = cbus_to_collapse {
                self.expanded_cbus.remove(&cbu_id);
            }
        });
    }

    fn show_database_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üóÑÔ∏è Database Management");

        ui.separator();

        if let Some(ref _pool) = self.db_pool {
            ui.colored_label(egui::Color32::GREEN, "‚úÖ PostgreSQL Connected");
            ui.label("Connection pool active and ready");

            ui.separator();

            ui.horizontal(|ui| {
                if ui.button("üß™ Test Query").clicked() {
                    self.load_cbus();
                }

                if ui.button("üå± Populate Taxonomy").clicked() {
                    self.populate_database_with_taxonomy();
                }
            });

            ui.separator();
            ui.label("üìä Database Operations:");
            ui.label("‚Ä¢ Test Query: Loads CBUs from database");
            ui.label("‚Ä¢ Populate Taxonomy: Inserts complete product‚Üíservice‚Üíresource hierarchy with investment mandates");
        } else {
            ui.colored_label(egui::Color32::YELLOW, "‚ö†Ô∏è No Database Connection");
            ui.label("The application is running in offline mode");
            ui.label("Check config.toml or DATABASE_URL environment variable");
        }
    }

    fn show_cbu_form_ui(&mut self, ui: &mut egui::Ui) {
        egui::Grid::new("cbu_form_grid").show(ui, |ui| {
            ui.label("CBU Name:");
            ui.text_edit_singleline(&mut self.cbu_form.cbu_name);
            ui.end_row();

            ui.label("Description:");
            ui.text_edit_multiline(&mut self.cbu_form.description);
            ui.end_row();

            ui.label("Primary Entity ID:");
            ui.text_edit_singleline(&mut self.cbu_form.primary_entity_id);
            ui.end_row();

            ui.label("Primary LEI:");
            ui.text_edit_singleline(&mut self.cbu_form.primary_lei);
            ui.end_row();

            ui.label("Domicile Country:");
            ui.text_edit_singleline(&mut self.cbu_form.domicile_country);
            ui.end_row();

            ui.label("Business Type:");
            ui.text_edit_singleline(&mut self.cbu_form.business_type);
            ui.end_row();
        });

        ui.horizontal(|ui| {
            if ui.button("üíæ Create").clicked() {
                self.create_cbu();
            }

            if ui.button("‚ùå Cancel").clicked() {
                self.show_cbu_form = false;
                self.cbu_form = CbuForm::default();
            }
        });
    }

    fn show_attribute_dictionary_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üìö Attribute Dictionary");

        ui.horizontal(|ui| {
            ui.label("Search:");
            if ui.text_edit_singleline(&mut self.attribute_search).changed() {
                // Trigger search when text changes
                self.search_attributes();
            }
            if ui.button("üîÑ Refresh").clicked() {
                self.load_data_dictionary();
            }
        });

        ui.separator();

        // Extract values to avoid borrowing conflicts
        let dictionary_info = self.data_dictionary.as_ref().map(|d| {
            (d.total_count, d.business_count, d.derived_count, d.system_count)
        });

        if let Some((total_count, business_count, derived_count, system_count)) = dictionary_info {
            // Statistics and edit mode controls
            ui.horizontal(|ui| {
                ui.label(format!("üìä Total: {}", total_count));
                ui.separator();
                ui.colored_label(egui::Color32::from_rgb(52, 152, 219), format!("üè¢ Business: {}", business_count));
                ui.separator();
                ui.colored_label(egui::Color32::from_rgb(155, 89, 182), format!("‚öôÔ∏è Derived: {}", derived_count));
                ui.separator();
                ui.colored_label(egui::Color32::from_rgb(231, 76, 60), format!("üîß System: {}", system_count));

                ui.separator();
                // Edit mode toggle
                let edit_button_text = if self.edit_mode { "üëÅÔ∏è View Mode" } else { "‚úèÔ∏è Edit Mode" };
                if ui.button(edit_button_text).clicked() {
                    self.edit_mode = !self.edit_mode;
                    self.show_save_button = false; // Reset save button when switching modes
                }

                // Show save button when in edit mode and has changes
                if self.edit_mode && !self.modified_attributes.is_empty() {
                    ui.separator();
                    if ui.button("üíæ Save Changes").clicked() {
                        self.save_attribute_changes();
                    }
                    ui.colored_label(egui::Color32::YELLOW, format!("({} modified)", self.modified_attributes.len()));
                }
            });

            ui.separator();

            // Filter buttons
            ui.label("üîç Filters:");
            ui.horizontal_wrapped(|ui| {
                // Attribute type filters
                let business_button = ui.selectable_label(self.filter_business, "üè¢ Business");
                if business_button.clicked() {
                    self.filter_business = !self.filter_business;
                }

                let derived_button = ui.selectable_label(self.filter_derived, "‚öôÔ∏è Derived");
                if derived_button.clicked() {
                    self.filter_derived = !self.filter_derived;
                }

                let system_button = ui.selectable_label(self.filter_system, "üîß System");
                if system_button.clicked() {
                    self.filter_system = !self.filter_system;
                }

                ui.separator();

                // Nullability filters
                let required_button = ui.selectable_label(self.filter_required, "üîí Required");
                if required_button.clicked() {
                    self.filter_required = !self.filter_required;
                }

                let optional_button = ui.selectable_label(self.filter_optional, "üìã Optional");
                if optional_button.clicked() {
                    self.filter_optional = !self.filter_optional;
                }

                ui.separator();

                // Key filter
                let key_button = ui.selectable_label(self.filter_key, "üîë Keys");
                if key_button.clicked() {
                    self.filter_key = !self.filter_key;
                }

                ui.separator();

                // Clear all / Select all buttons
                if ui.button("üö´ Clear All").clicked() {
                    self.filter_business = false;
                    self.filter_derived = false;
                    self.filter_system = false;
                    self.filter_required = false;
                    self.filter_optional = false;
                    self.filter_key = false;
                }

                if ui.button("‚úÖ Select All").clicked() {
                    self.filter_business = true;
                    self.filter_derived = true;
                    self.filter_system = true;
                    self.filter_required = true;
                    self.filter_optional = true;
                    self.filter_key = true;
                }
            });

            ui.separator();

            if self.edit_mode {
                // Interactive editing mode
                egui::ScrollArea::vertical().show(ui, |ui| {
                    self.show_editable_attributes_grid(ui);
                });
            } else {
                // Read-only view mode
                egui::ScrollArea::vertical().show(ui, |ui| {
                    if let Some(ref dictionary) = self.data_dictionary {
                        egui::Grid::new("attribute_grid").striped(true).show(ui, |ui| {
                            ui.label("Name");
                            ui.label("Type");
                            ui.label("Entity");
                            ui.label("Data Type");
                            ui.label("Description");
                            ui.label("Key");
                            ui.label("Nullable");
                            ui.end_row();

                            // Filter and display attributes
                            let mut displayed_count = 0;
                            for attr in &dictionary.attributes {
                            let attr_type = attr.get("attribute_type").and_then(|v| v.as_str()).unwrap_or("unknown");
                            let is_nullable = attr.get("is_nullable").and_then(|v| v.as_bool()).unwrap_or(false);
                            let is_key = attr.get("is_key").and_then(|v| v.as_bool()).unwrap_or(false);

                            // Apply filters
                            let mut show_attribute = false;

                            // Check attribute type filters
                            match attr_type {
                                "business" if self.filter_business => show_attribute = true,
                                "derived" if self.filter_derived => show_attribute = true,
                                "system" if self.filter_system => show_attribute = true,
                                _ => {}
                            }

                            // If attribute type doesn't match, skip regardless of other filters
                            if !show_attribute {
                                continue;
                            }

                            // Apply nullability filters (both required and optional must be checked for non-nullable and nullable respectively)
                            let nullability_matches =
                                (!is_nullable && self.filter_required) ||
                                (is_nullable && self.filter_optional);

                            if !nullability_matches {
                                continue;
                            }

                            // Apply key filter - when disabled, only show non-key attributes
                            if !self.filter_key && is_key {
                                continue;
                            }

                            // If we get here, show the attribute
                            let color = match attr_type {
                                "business" => egui::Color32::from_rgb(52, 152, 219),
                                "derived" => egui::Color32::from_rgb(155, 89, 182),
                                "system" => egui::Color32::from_rgb(231, 76, 60),
                                _ => egui::Color32::GRAY,
                            };

                            ui.colored_label(color, attr.get("attribute_name").and_then(|v| v.as_str()).unwrap_or(""));
                            ui.label(attr_type);
                            ui.label(attr.get("entity_name").and_then(|v| v.as_str()).unwrap_or(""));
                            ui.label(attr.get("data_type").and_then(|v| v.as_str()).unwrap_or(""));
                            ui.label(attr.get("description").and_then(|v| v.as_str()).unwrap_or("N/A"));
                            ui.label(if is_key { "üîë" } else { "" });
                            ui.label(if is_nullable { "‚úì" } else { "‚úó" });
                            ui.end_row();

                            displayed_count += 1;
                        }

                        // Show count of displayed vs total attributes
                        if displayed_count < dictionary.attributes.len() {
                            ui.end_row();
                            ui.colored_label(egui::Color32::GRAY, format!("Showing {} of {} attributes", displayed_count, dictionary.attributes.len()));
                            ui.label("");
                            ui.label("");
                            ui.label("");
                            ui.label("");
                            ui.label("");
                            ui.label("");
                            ui.end_row();
                        }
                        });
                    } else {
                        ui.label("Loading attribute dictionary...");
                        ui.spinner();
                    }
                });
            }
        } else {
            ui.label("Loading attribute dictionary...");
            ui.spinner();
        }
    }

    fn show_editable_attributes_grid(&mut self, ui: &mut egui::Ui) {
        egui::Grid::new("editable_attribute_grid").striped(true).show(ui, |ui| {
            ui.label("Name");
            ui.label("Type");
            ui.label("Entity");
            ui.label("Data Type");
            ui.label("Description");
            ui.label("Key");
            ui.label("Nullable");
            ui.label("Status");
            ui.end_row();

            let mut displayed_count = 0;
            // Create a mutable copy of the indices to iterate over
            let indices: Vec<usize> = (0..self.editable_attributes.len()).collect();

            for i in indices {
                let should_display = {
                    let attr = &self.editable_attributes[i];

                    // Apply the same filters as the read-only view
                    let mut show_attribute = false;
                    match attr.attribute_type.as_str() {
                        "business" if self.filter_business => show_attribute = true,
                        "derived" if self.filter_derived => show_attribute = true,
                        "system" if self.filter_system => show_attribute = true,
                        _ => {}
                    }

                    if !show_attribute {
                        false
                    } else {
                        let nullability_matches =
                            (!attr.is_nullable && self.filter_required) ||
                            (attr.is_nullable && self.filter_optional);

                        if !nullability_matches {
                            false
                        } else if !self.filter_key && attr.is_key {
                            false
                        } else {
                            true
                        }
                    }
                };

                if should_display {
                    // Get the attribute
                    let attr = &mut self.editable_attributes[i];

                    // Show name (read-only for now)
                    let color = match attr.attribute_type.as_str() {
                        "business" => egui::Color32::from_rgb(52, 152, 219),
                        "derived" => egui::Color32::from_rgb(155, 89, 182),
                        "system" => egui::Color32::from_rgb(231, 76, 60),
                        _ => egui::Color32::GRAY,
                    };
                    ui.colored_label(color, &attr.attribute_name);

                    // Type (read-only)
                    ui.label(&attr.attribute_type);

                    // Entity (read-only)
                    ui.label(&attr.entity_name);

                    // Data Type (editable)
                    let data_type_response = ui.text_edit_singleline(&mut attr.data_type);
                    if data_type_response.changed() {
                        attr.mark_dirty_if_changed();
                        if attr.is_dirty {
                            self.modified_attributes.insert(attr.id);
                        }
                    }

                    // Description (editable)
                    let mut description = attr.description.clone().unwrap_or_default();
                    let desc_response = ui.text_edit_singleline(&mut description);
                    if desc_response.changed() {
                        attr.description = if description.is_empty() { None } else { Some(description) };
                        attr.mark_dirty_if_changed();
                        if attr.is_dirty {
                            self.modified_attributes.insert(attr.id);
                        }
                    }

                    // Key (read-only for now)
                    ui.label(if attr.is_key { "üîë" } else { "" });

                    // Nullable (read-only for now)
                    ui.label(if attr.is_nullable { "‚úì" } else { "‚úó" });

                    // Status indicator
                    if attr.is_dirty {
                        ui.colored_label(egui::Color32::YELLOW, "‚ö†Ô∏è Modified");
                    } else {
                        ui.label("‚úÖ Saved");
                    }

                    ui.end_row();
                    displayed_count += 1;
                }
            }

            // Show count
            if displayed_count < self.editable_attributes.len() {
                ui.end_row();
                ui.colored_label(egui::Color32::GRAY, format!("Editing {} of {} attributes", displayed_count, self.editable_attributes.len()));
                ui.label("");
                ui.label("");
                ui.label("");
                ui.label("");
                ui.label("");
                ui.label("");
                ui.label("");
                ui.end_row();
            }
        });
    }

    fn save_attribute_changes(&mut self) {
        // For now, simulate saving and reset dirty flags
        println!("üîÑ Saving {} attribute changes...", self.modified_attributes.len());

        // Reset dirty flags for all modified attributes
        for attr in &mut self.editable_attributes {
            if self.modified_attributes.contains(&attr.id) {
                attr.is_dirty = false;
                // Update original values to current values
                attr.original_description = attr.description.clone();
                attr.original_data_type = attr.data_type.clone();
            }
        }

        // Clear modified set
        self.modified_attributes.clear();

        println!("‚úÖ All changes saved successfully!");

        // TODO: Implement actual database saving in the next step
    }

    fn show_rule_engine_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("‚ö° Rule Engine & DSL Live Testing");

        // Live Rule Testing Section
        ui.group(|ui| {
            ui.heading("üß™ Live Rule Testing");

            ui.horizontal(|ui| {
                ui.label("Rule DSL:");
                if ui.button("üìã Paste Sample").clicked() {
                    self.rule_input = "IF age >= 18 THEN \"adult\" ELSE \"minor\"".to_string();
                }
                if ui.button("üîÑ Clear").clicked() {
                    self.rule_input.clear();
                    self.rule_result = None;
                    self.rule_error = None;
                }
            });

            // Rule input with syntax highlighting
            let mut rule_input = self.rule_input.clone();
            let response = self.show_highlighted_text_edit(ui, &mut rule_input, [ui.available_width(), 120.0]);
            if response.changed() {
                self.rule_input = rule_input;
            }

            ui.horizontal(|ui| {
                ui.label("Test Context (JSON):");
                if ui.button("üìã Sample Data").clicked() {
                    self.test_context = "{\n  \"age\": 25,\n  \"country\": \"USA\",\n  \"balance\": 50000,\n  \"email\": \"test@example.com\"\n}".to_string();
                }
            });

            // Context input
            ui.add_sized([ui.available_width(), 100.0],
                egui::TextEdit::multiline(&mut self.test_context)
                    .hint_text("Enter test data as JSON...")
                    .font(egui::TextStyle::Monospace));

            ui.horizontal(|ui| {
                if ui.button("üöÄ Test Rule").clicked() {
                    self.test_rule();
                }
                if ui.button("üìä Parse AST").clicked() {
                    self.parse_ast_only();
                }
                if ui.button("üîç Validate Syntax").clicked() {
                    self.validate_syntax_only();
                }
                if ui.button("üíæ Save Rule").clicked() {
                    self.status_message = "Feature coming soon: Save to Database".to_string();
                }
            });

            ui.separator();

            // Results display
            if let Some(ref result) = self.rule_result {
                ui.group(|ui| {
                    ui.heading("‚úÖ Result");
                    ui.label(egui::RichText::new(result).color(egui::Color32::GREEN).monospace());
                });
            }

            if let Some(ref error) = self.rule_error {
                ui.group(|ui| {
                    ui.heading("‚ùå Error");
                    ui.label(egui::RichText::new(error).color(egui::Color32::RED).monospace());
                });
            }
        });

        ui.separator();

        // Semantic Search Section
        ui.group(|ui| {
            ui.heading("üîç Semantic Rule Search");

            ui.horizontal(|ui| {
                ui.label("Search Query:");
                ui.text_edit_singleline(&mut self.semantic_search_query);
                if ui.button("üß† Find Similar Rules").clicked() {
                    self.search_similar_rules();
                }
                if ui.button("‚ö° Generate Embeddings").clicked() {
                    self.generate_all_embeddings();
                }
            });

            ui.label(&self.embedding_status);

            if !self.similar_rules.is_empty() {
                ui.separator();
                ui.heading("üìä Similar Rules Found:");

                egui::ScrollArea::vertical().max_height(200.0).show(ui, |ui| {
                    egui::Grid::new("similar_rules_grid").striped(true).show(ui, |ui| {
                        ui.label("Similarity");
                        ui.label("Rule Name");
                        ui.label("Definition");
                        ui.label("Actions");
                        ui.end_row();

                        for similar_rule in &self.similar_rules {
                            ui.label(format!("{:.3}", 1.0 - similar_rule.similarity)); // Convert distance to similarity
                            ui.label(&similar_rule.rule_name);
                            ui.label(&similar_rule.rule_definition);
                            if ui.button("üìã Copy").clicked() {
                                self.rule_input = similar_rule.rule_definition.clone();
                            }
                            ui.end_row();
                        }
                    });
                });
            }
        });

        ui.separator();

        // DSL Reference
        ui.collapsing("üìñ DSL Quick Reference", |ui| {
            ui.label("üî¢ Arithmetic: +, -, *, /, %, **");
            ui.label("üî§ String: &, CONCAT(), UPPER(), LOWER(), LENGTH()");
            ui.label("üîç Comparison: =, !=, <, <=, >, >=");
            ui.label("üéØ Pattern: MATCHES, CONTAINS, STARTS_WITH, ENDS_WITH");
            ui.label("üîó Logical: AND, OR, NOT");
            ui.label("üìã Lists: IN, NOT_IN, [item1, item2]");
            ui.label("üéõÔ∏è Conditionals: IF...THEN...ELSE, WHEN...THEN...ELSE");
            ui.label("‚öôÔ∏è Functions: ABS(), ROUND(), MIN(), MAX(), SUM(), AVG()");
            ui.label("üîß Type Cast: TO_STRING(), TO_NUMBER(), TO_BOOLEAN()");
        });

        // Sample Rules Gallery
        ui.collapsing("üé® Sample Rules Gallery", |ui| {
            if ui.button("Age Classification").clicked() {
                self.rule_input = "IF age < 18 THEN \"minor\" ELSE IF age < 65 THEN \"adult\" ELSE \"senior\"".to_string();
            }
            if ui.button("KYC Risk Score").clicked() {
                self.rule_input = "IF balance > 100000 AND age > 25 THEN \"low_risk\" ELSE \"high_risk\"".to_string();
            }
            if ui.button("Email Validation").clicked() {
                self.rule_input = "email MATCHES /^[\\w\\._%+-]+@[\\w\\.-]+\\.[A-Za-z]{2,}$/".to_string();
            }
            if ui.button("Complex Business Rule").clicked() {
                self.rule_input = "WHEN country IN [\"USA\", \"UK\", \"CA\"] AND balance > 50000 THEN CONCAT(\"VIP_\", UPPER(country)) ELSE \"STANDARD\"".to_string();
            }
        });

        if !self.rules.is_empty() {
            ui.separator();
            ui.heading("üìù Saved Rules");

            for (i, _rule) in self.rules.iter().enumerate() {
                ui.horizontal(|ui| {
                    if ui.selectable_label(self.selected_rule == Some(i), format!("Rule {}", i + 1)).clicked() {
                        self.selected_rule = Some(i);
                    }
                });
            }
        }
    }

    fn test_rule(&mut self) {
        self.rule_result = None;
        self.rule_error = None;

        // Parse the rule
        let ast = match parser::parse_rule(&self.rule_input) {
            Ok((_, ast)) => ast,
            Err(e) => {
                self.rule_error = Some(format!("Parse Error: {:?}", e));
                return;
            }
        };

        // Parse the test context
        let context: HashMap<String, Value> = match serde_json::from_str(&self.test_context) {
            Ok(json_value) => {
                let mut facts = HashMap::new();
                if let serde_json::Value::Object(map) = json_value {
                    for (key, value) in map {
                        let val = match value {
                            serde_json::Value::String(s) => Value::String(s),
                            serde_json::Value::Number(n) => {
                                if let Some(i) = n.as_i64() {
                                    Value::Integer(i)
                                } else if let Some(f) = n.as_f64() {
                                    Value::Float(f)
                                } else {
                                    Value::Null
                                }
                            },
                            serde_json::Value::Bool(b) => Value::Boolean(b),
                            serde_json::Value::Array(arr) => {
                                let list: Vec<Value> = arr.into_iter().map(|v| match v {
                                    serde_json::Value::String(s) => Value::String(s),
                                    serde_json::Value::Number(n) => {
                                        if let Some(i) = n.as_i64() {
                                            Value::Integer(i)
                                        } else {
                                            Value::Float(n.as_f64().unwrap_or(0.0))
                                        }
                                    },
                                    serde_json::Value::Bool(b) => Value::Boolean(b),
                                    _ => Value::Null,
                                }).collect();
                                Value::List(list)
                            },
                            serde_json::Value::Null => Value::Null,
                            _ => Value::Null,
                        };
                        facts.insert(key, val);
                    }
                }
                facts
            },
            Err(e) => {
                self.rule_error = Some(format!("JSON Parse Error: {}", e));
                return;
            }
        };

        // Evaluate the rule
        match evaluator::evaluate(&ast, &context) {
            Ok(result) => {
                let result_str = match result {
                    Value::String(s) => format!("\"{}\"", s),
                    Value::Integer(i) => i.to_string(),
                    Value::Float(f) => f.to_string(),
                    Value::Number(n) => n.to_string(),
                    Value::Boolean(b) => b.to_string(),
                    Value::Null => "null".to_string(),
                    Value::List(list) => {
                        let items: Vec<String> = list.iter().map(|v| match v {
                            Value::String(s) => format!("\"{}\"", s),
                            Value::Integer(i) => i.to_string(),
                            Value::Float(f) => f.to_string(),
                            Value::Boolean(b) => b.to_string(),
                            Value::Null => "null".to_string(),
                            _ => "complex".to_string(),
                        }).collect();
                        format!("[{}]", items.join(", "))
                    },
                    Value::Regex(pattern) => format!("/{}/", pattern),
                };
                self.rule_result = Some(format!("Result: {}", result_str));
            },
            Err(e) => {
                self.rule_error = Some(format!("Evaluation Error: {}", e));
            }
        }
    }

    fn parse_ast_only(&mut self) {
        self.rule_result = None;
        self.rule_error = None;

        match parser::parse_rule(&self.rule_input) {
            Ok((_, ast)) => {
                self.rule_result = Some(format!("AST: {:#?}", ast));
            },
            Err(e) => {
                self.rule_error = Some(format!("Parse Error: {:?}", e));
            }
        }
    }

    fn validate_syntax_only(&mut self) {
        self.rule_result = None;
        self.rule_error = None;

        match parser::parse_rule(&self.rule_input) {
            Ok((remaining, _ast)) => {
                if remaining.trim().is_empty() {
                    self.rule_result = Some("‚úÖ Syntax is valid!".to_string());
                } else {
                    self.rule_error = Some(format!("‚ö†Ô∏è Unexpected remaining input: '{}'", remaining));
                }
            },
            Err(e) => {
                self.rule_error = Some(format!("‚ùå Syntax Error: {:?}", e));
            }
        }
    }

    fn search_similar_rules(&mut self) {
        if self.semantic_search_query.trim().is_empty() {
            self.embedding_status = "‚ùå Please enter a search query".to_string();
            return;
        }

        if let Some(ref _pool) = self.db_pool {
            let rt = self.runtime.clone();
            let query = self.semantic_search_query.clone();

            self.embedding_status = "üîÑ Searching for similar rules...".to_string();

            match rt.block_on(async {
                let pool = DbOperations::get_pool().await.map_err(|e| e.to_string())?;
                EmbeddingOperations::find_similar_rules(&pool, &query, 5).await
            }) {
                Ok(rules) => {
                    self.similar_rules = rules;
                    self.embedding_status = format!("‚úÖ Found {} similar rules", self.similar_rules.len());
                }
                Err(e) => {
                    self.embedding_status = format!("‚ùå Search failed: {}", e);
                    self.similar_rules.clear();
                }
            }
        } else {
            self.embedding_status = "‚ùå No database connection".to_string();
        }
    }

    fn generate_all_embeddings(&mut self) {
        if let Some(ref _pool) = self.db_pool {
            let rt = self.runtime.clone();

            self.embedding_status = "üîÑ Generating embeddings for all rules...".to_string();

            match rt.block_on(async {
                let pool = DbOperations::get_pool().await.map_err(|e| e.to_string())?;
                EmbeddingOperations::generate_all_embeddings(&pool).await
            }) {
                Ok(_) => {
                    self.embedding_status = "‚úÖ All embeddings generated successfully".to_string();
                }
                Err(e) => {
                    self.embedding_status = format!("‚ùå Embedding generation failed: {}", e);
                }
            }
        } else {
            self.embedding_status = "‚ùå No database connection".to_string();
        }
    }

    fn search_attributes(&mut self) {
        if self.attribute_search.len() >= 2 {
            if let Some(ref _pool) = self.db_pool {
                let rt = self.runtime.clone();
                let search_term = self.attribute_search.clone();

                match rt.block_on(async {
                    let pool = DbOperations::get_pool().await.map_err(|e| e.to_string())?;
                    use data_designer_core::db::DataDictionaryOperations;
                    DataDictionaryOperations::get_data_dictionary(&pool, Some(&search_term)).await
                }) {
                    Ok(dictionary) => {
                        self.data_dictionary = Some(dictionary);
                    }
                    Err(e) => {
                        eprintln!("Failed to search attributes: {}", e);
                    }
                }
            }
        } else if self.attribute_search.is_empty() {
            self.load_data_dictionary();
        }
    }

    fn show_highlighted_text_edit(&mut self, ui: &mut egui::Ui, text: &mut String, size: [f32; 2]) -> egui::Response {
        // For now, use a simple approach with colored text display
        ui.group(|ui| {
            ui.vertical(|ui| {
                // Show syntax highlighted preview
                if !text.is_empty() {
                    ui.label("üìñ Syntax Highlighted Preview:");
                    ui.separator();

                    let tokens = self.syntax_highlighter.tokenize(text);

                    ui.horizontal_wrapped(|ui| {
                        let mut last_end = 0;

                        for token in tokens {
                            // Add any whitespace between tokens
                            if token.start > last_end {
                                let whitespace = &text[last_end..token.start];
                                if !whitespace.trim().is_empty() {
                                    ui.label(whitespace);
                                }
                            }

                            // Add the colored token
                            let token_text = &text[token.start..token.end];
                            let color = self.syntax_highlighter.get_color(token.token_type);
                            ui.label(egui::RichText::new(token_text).color(color).monospace());

                            last_end = token.end;
                        }

                        // Add any remaining text
                        if last_end < text.len() {
                            ui.label(&text[last_end..]);
                        }
                    });

                    ui.separator();
                }

                // Regular text editor
                ui.add_sized(size, egui::TextEdit::multiline(text)
                    .hint_text("Enter your DSL code here...")
                    .font(egui::TextStyle::Monospace))
            }).inner
        }).inner
    }

    fn show_dictionary_viewer_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üìã Dictionary Viewer - JSON Data Explorer");

        if !self.dictionary_loaded {
            ui.colored_label(egui::Color32::YELLOW, "‚ö†Ô∏è Dictionary not loaded");
            if ui.button("üîÑ Reload Dictionary").clicked() {
                self.load_json_dictionary();
            }
            return;
        }

        if let Some(ref dictionary) = self.dictionary_data {
            // Statistics and overview
            ui.horizontal(|ui| {
                let stats = dictionary.get_statistics();
                ui.label(format!("üìä {} Datasets", stats.total_datasets));
                ui.separator();
                ui.label(format!("üè∑Ô∏è {} Attributes", stats.total_attributes));
                ui.separator();
                ui.label(format!("üìö {} Lookup Tables", stats.lookup_tables_count));
                ui.separator();
                ui.label(format!("üîó {} Lookup Entries", stats.total_lookup_entries));
            });

            ui.separator();

            // Search functionality
            ui.horizontal(|ui| {
                ui.label("üîç Search:");
                ui.text_edit_singleline(&mut self.viewer_state.search_query);
                if ui.button("‚ùå Clear").clicked() {
                    self.viewer_state.clear_search();
                }
                if self.viewer_state.has_active_filters() {
                    ui.colored_label(egui::Color32::GREEN, "Filters active");
                }
            });

            ui.separator();

            // Two-panel layout
            ui.horizontal(|ui| {
                // Left panel - Dataset list and groups
                ui.group(|ui| {
                    ui.vertical(|ui| {
                        ui.heading("üìÅ Datasets");
                        ui.set_width(300.0);

                        egui::ScrollArea::vertical()
                            .max_height(500.0)
                            .show(ui, |ui| {
                                for (i, dataset) in dictionary.datasets.iter().enumerate() {
                                    let group_name = &dataset.name;
                                    let expanded = self.viewer_state.is_group_expanded(group_name);

                                    ui.horizontal(|ui| {
                                        let expand_icon = if expanded { "üìÇ" } else { "üìÅ" };
                                        if ui.button(format!("{} {}", expand_icon, dataset.name)).clicked() {
                                            self.viewer_state.toggle_group(group_name);
                                        }
                                        ui.label(format!("({} attrs)", dataset.attributes.len()));
                                    });

                                    if expanded {
                                        ui.indent("dataset_attrs", |ui| {
                                            ui.label(&dataset.description);
                                            ui.separator();

                                            // Show filtered attributes
                                            for (attr_name, attr_value) in &dataset.attributes {
                                                if self.viewer_state.search_query.is_empty()
                                                   || attr_name.to_lowercase().contains(&self.viewer_state.search_query.to_lowercase()) {

                                                    if ui.selectable_label(false, format!("üè∑Ô∏è {}", attr_name)).clicked() {
                                                        self.viewer_state.selected_dataset = Some(format!("{}.{}", dataset.id, attr_name));
                                                    }
                                                }
                                            }
                                        });
                                    }
                                    ui.separator();
                                }
                            });
                    });
                });

                ui.separator();

                // Right panel - Attribute details
                ui.group(|ui| {
                    ui.vertical(|ui| {
                        ui.heading("üîç Attribute Details");

                        if let Some(ref selected) = self.viewer_state.selected_dataset {
                            if let Some((dataset_id, attr_name)) = selected.split_once('.') {
                                if let Some(dataset) = dictionary.get_dataset_by_id(dataset_id) {
                                    if let Some(attr_value) = dataset.attributes.get(attr_name) {
                                        ui.label(format!("Dataset: {}", dataset.name));
                                        ui.label(format!("Attribute: {}", attr_name));

                                        ui.separator();

                                        ui.label("Value:");
                                        ui.code(format!("{:#}", attr_value));

                                        ui.separator();

                                        // Type information
                                        match attr_value {
                                            serde_json::Value::String(s) => {
                                                ui.label(format!("Type: String (length: {})", s.len()));
                                                if s.contains('@') {
                                                    ui.colored_label(egui::Color32::BLUE, "üìß Looks like email");
                                                }
                                                if s.contains("http") {
                                                    ui.colored_label(egui::Color32::BLUE, "üîó Looks like URL");
                                                }
                                            }
                                            serde_json::Value::Number(n) => {
                                                if n.is_i64() {
                                                    ui.label("Type: Integer");
                                                } else {
                                                    ui.label("Type: Decimal");
                                                }
                                            }
                                            serde_json::Value::Bool(_) => {
                                                ui.label("Type: Boolean");
                                            }
                                            serde_json::Value::Array(arr) => {
                                                ui.label(format!("Type: Array (length: {})", arr.len()));
                                            }
                                            serde_json::Value::Object(obj) => {
                                                ui.label(format!("Type: Object (keys: {})", obj.len()));
                                            }
                                            serde_json::Value::Null => {
                                                ui.label("Type: Null");
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            ui.label("Select an attribute to view details");
                        }
                    });
                });
            });

            ui.separator();

            // Lookup tables section
            ui.collapsing("üìö Lookup Tables", |ui| {
                for (table_name, table_data) in &dictionary.lookup_tables {
                    ui.collapsing(format!("üìã {} ({} entries)", table_name, table_data.len()), |ui| {
                        egui::ScrollArea::vertical()
                            .max_height(200.0)
                            .show(ui, |ui| {
                                for (key, value) in table_data {
                                    ui.horizontal(|ui| {
                                        ui.label(format!("üîë {}", key));
                                        ui.separator();
                                        // Handle serde_json::Value properly
                                        let value_str = match value {
                                            serde_json::Value::String(s) => s.clone(),
                                            serde_json::Value::Number(n) => n.to_string(),
                                            serde_json::Value::Bool(b) => b.to_string(),
                                            serde_json::Value::Null => "null".to_string(),
                                            _ => serde_json::to_string_pretty(value).unwrap_or_else(|_| "Invalid JSON".to_string()),
                                        };
                                        ui.label(value_str);
                                    });
                                }
                            });
                    });
                }
            });

        } else {
            ui.colored_label(egui::Color32::RED, "‚ùå No dictionary data available");
        }
    }

    fn show_transpiler_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üîÑ DSL Transpiler & Code Generation");

        // AI Assistant and Code Intelligence Toggles
        ui.horizontal(|ui| {
            if ui.button(if self.show_ai_panel { "ü§ñ Hide AI Assistant" } else { "ü§ñ Show AI Assistant" }).clicked() {
                self.show_ai_panel = !self.show_ai_panel;
            }
            ui.separator();
            // White Truffle #4: Code Intelligence Toggle
            if ui.button(if self.show_code_intelligence { "üß† Hide Intelligence" } else { "üß† Show Intelligence" }).clicked() {
                self.show_code_intelligence = !self.show_code_intelligence;
            }
            ui.separator();
            ui.label("üí° Get intelligent suggestions and real-time code analysis");
        });

        ui.add_space(10.0);

        // Main layout with optional AI panel and Code Intelligence panel
        if self.show_ai_panel || self.show_code_intelligence {
            ui.horizontal(|ui| {
                // Left side: Editor and transpiler
                ui.vertical(|ui| {
                    self.show_editor_panel(ui);
                });

                ui.separator();

                // Right side: Side panels
                ui.vertical(|ui| {
                    if self.show_ai_panel {
                        self.show_ai_assistant_panel(ui);
                        if self.show_code_intelligence {
                            ui.separator();
                        }
                    }

                    // White Truffle #4: Code Intelligence Panel
                    if self.show_code_intelligence {
                        self.show_code_intelligence_panel(ui);
                    }

                    // White Truffle #5: Debug Panel
                    if self.show_debug_panel {
                        self.show_debug_panel(ui);
                    }
                });
            });
        } else {
            self.show_editor_panel(ui);
        }
    }

    fn show_editor_panel(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            ui.group(|ui| {
                ui.vertical(|ui| {
                    ui.heading("üìù Input DSL Expression");
                    ui.add_space(10.0);

                    // Input area with mode controls
                    ui.horizontal(|ui| {
                        ui.label("DSL Rule:");
                        if ui.button("üîÑ Clear").clicked() {
                            self.transpiler_input.clear();
                            self.dsl_editor.text.clear();
                        }
                        ui.separator();
                        ui.checkbox(&mut self.multi_rule_mode, "üîÄ Multi-Rule Mode");
                        if ui.small_button("‚ùì").on_hover_text("Enable to parse multiple rules separated by line breaks").clicked() {
                            // Help clicked
                        }
                    });

                    // Enhanced DSL Editor with syntax highlighting and real-time completion
                    let editor_response = ui.add(&mut self.dsl_editor);

                    // Sync with transpiler input for now
                    self.transpiler_input = self.dsl_editor.text.clone();

                    // Trigger intelligent code completion on typing
                    if editor_response.changed() || self.should_trigger_completion() {
                        self.trigger_code_completion();
                        // White Truffle #4: Trigger real-time code analysis
                        self.perform_live_analysis();
                    }

                    ui.add_space(10.0);

                    // Configuration
                    ui.horizontal(|ui| {
                        ui.label("Target Language:");
                        egui::ComboBox::from_id_salt("target_language")
                            .selected_text(&self.target_language)
                            .show_ui(ui, |ui| {
                                ui.selectable_value(&mut self.target_language, "Rust".to_string(), "ü¶Ä Rust");
                                ui.selectable_value(&mut self.target_language, "SQL".to_string(), "üóÑÔ∏è SQL");
                                ui.selectable_value(&mut self.target_language, "JavaScript".to_string(), "üì± JavaScript");
                                ui.selectable_value(&mut self.target_language, "Python".to_string(), "üêç Python");
                            });
                    });

                    ui.horizontal(|ui| {
                        ui.checkbox(&mut self.optimization_enabled, "Enable Optimizations");
                        ui.label("(constant folding, dead code elimination)");
                    });

                    ui.add_space(10.0);

                    // Real-time syntax validation
                    ui.horizontal(|ui| {
                        if ui.button("üîç Validate Syntax").clicked() {
                            self.dsl_editor.validate_syntax();
                        }

                        // Transpile button
                        if ui.add(egui::Button::new("üöÄ Transpile").min_size(egui::vec2(100.0, 30.0))).clicked() {
                            self.transpile_expression();
                        }
                    });
                });
            });

            ui.separator();

            ui.group(|ui| {
                ui.vertical(|ui| {
                    ui.heading("üíª Generated Code");
                    ui.add_space(10.0);

                    // Output area
                    ui.horizontal(|ui| {
                        ui.label(format!("Output ({})", self.target_language));
                        if ui.button("üìã Copy").clicked() {
                            ui.ctx().copy_text(self.transpiler_output.clone());
                        }
                    });

                    let output_color = if self.transpiler_error.is_some() {
                        egui::Color32::LIGHT_RED
                    } else {
                        ui.visuals().text_color()
                    };

                    // Enhanced output editor with syntax highlighting
                    ui.add(&mut self.output_editor);

                    // Error display
                    if let Some(error) = &self.transpiler_error {
                        ui.add_space(10.0);
                        ui.colored_label(egui::Color32::RED, format!("‚ùå Error: {}", error));

                        // Show detailed DSL parsing errors if available
                        if !self.transpile_errors.is_empty() {
                            ui.add_space(5.0);
                            ui.collapsing("üîç Detailed Error Report", |ui| {
                                for (i, parse_error) in self.transpile_errors.iter().enumerate() {
                                    ui.separator();
                                    ui.label(format!("Error {}:", i + 1));
                                    ui.colored_label(egui::Color32::LIGHT_RED, &parse_error.message);

                                    if let Some(line) = parse_error.line {
                                        ui.label(format!("Line: {}", line));
                                    }
                                    if let Some(column) = parse_error.column {
                                        ui.label(format!("Column: {}", column));
                                    }
                                    if let Some(rule_name) = &parse_error.rule_name {
                                        ui.label(format!("Rule: {}", rule_name));
                                    }
                                    ui.label(format!("Type: {:?}", parse_error.error_type));
                                }
                            });
                        }

                        // Show successfully parsed rules if any
                        if !self.parsed_rules.is_empty() {
                            ui.add_space(5.0);
                            ui.collapsing("‚úÖ Successfully Parsed Rules", |ui| {
                                for (i, rule) in self.parsed_rules.iter().enumerate() {
                                    ui.separator();
                                    ui.label(format!("Rule {}: {}", i + 1, rule.name));
                                    ui.label(format!("  Line: {}", rule.line_number));
                                    if !rule.dependencies.is_empty() {
                                        ui.label(format!("  Dependencies: {}", rule.dependencies.join(", ")));
                                    }
                                }
                            });
                        }
                    }

                    ui.add_space(10.0);

                    // Info panel
                    ui.collapsing("‚ÑπÔ∏è Transpiler Features", |ui| {
                        ui.label("üîß Optimizations:");
                        ui.label("  ‚Ä¢ Constant folding (2 + 3 ‚Üí 5)");
                        ui.label("  ‚Ä¢ Dead code elimination");
                        ui.label("  ‚Ä¢ Function inlining");
                        ui.separator();
                        ui.label("üéØ Target Languages:");
                        ui.label("  ‚Ä¢ Rust: Direct Value enum mapping");
                        ui.label("  ‚Ä¢ SQL: CASE/WHEN expressions");
                        ui.label("  ‚Ä¢ JavaScript: Ternary operators");
                        ui.label("  ‚Ä¢ Python: Native expressions");
                        ui.separator();
                        ui.label("‚úÖ Supported Features:");
                        ui.label("  ‚Ä¢ Arithmetic operations");
                        ui.label("  ‚Ä¢ Logical operations");
                        ui.label("  ‚Ä¢ Function calls");
                        ui.label("  ‚Ä¢ Conditional expressions");
                        ui.label("  ‚Ä¢ String operations");
                    });
                });
            });
        });
    }

    fn transpile_expression(&mut self) {
        self.transpiler_error = None;
        self.transpile_errors.clear();
        self.parsed_rules.clear();

        if self.transpiler_input.trim().is_empty() {
            self.transpiler_error = Some("Input expression is empty".to_string());
            self.transpiler_output = String::new();
            return;
        }

        if self.multi_rule_mode {
            // Use enhanced DSL transpiler for multi-rule mode
            match self.dsl_transpiler.transpile_dsl_to_rules(&self.transpiler_input) {
                Ok(rules) => {
                    self.parsed_rules = rules;

                    // Generate summary output
                    let mut output = String::new();
                    output.push_str(&format!("Successfully parsed {} rule(s):\n\n", self.parsed_rules.len()));

                    for (i, rule) in self.parsed_rules.iter().enumerate() {
                        output.push_str(&format!("Rule {}: {}\n", i + 1, rule.name));
                        output.push_str(&format!("  Definition: {}\n", rule.definition));
                        if !rule.dependencies.is_empty() {
                            output.push_str(&format!("  Dependencies: {}\n", rule.dependencies.join(", ")));
                        }
                        output.push_str("\n");
                    }

                    self.transpiler_output = output;
                    self.output_editor.text = self.transpiler_output.clone();
                    self.output_editor.language = DslLanguage::Rust; // Summary is text
                }
                Err(errors) => {
                    self.transpile_errors = errors;

                    // Generate error report
                    let mut error_output = String::new();
                    error_output.push_str(&format!("Found {} error(s):\n\n", self.transpile_errors.len()));

                    for error in &self.transpile_errors {
                        error_output.push_str(&format!("{}\n", error));
                    }

                    self.transpiler_error = Some(format!("DSL parsing failed with {} errors", self.transpile_errors.len()));
                    self.transpiler_output = error_output;
                    self.output_editor.text = self.transpiler_output.clone();

                    // Trigger AI error analysis for first error
                    if let Some(first_error) = self.transpile_errors.first() {
                        let error_message = first_error.message.clone();
                        self.trigger_error_analysis(&error_message);
                    }
                }
            }
        } else {
            // Single expression mode - use original transpiler
            match parser::parse_expression(&self.transpiler_input) {
                Ok((_, ast)) => {
                    // Determine target language
                    let target = match self.target_language.as_str() {
                        "Rust" => TargetLanguage::Rust,
                        "SQL" => TargetLanguage::SQL,
                        "JavaScript" => TargetLanguage::JavaScript,
                        "Python" => TargetLanguage::Python,
                        _ => TargetLanguage::Rust,
                    };

                    // Create transpiler with options
                    let options = TranspilerOptions {
                        target,
                        optimize: self.optimization_enabled,
                        inline_functions: self.optimization_enabled,
                        constant_folding: self.optimization_enabled,
                        dead_code_elimination: self.optimization_enabled,
                    };

                    let transpiler = Transpiler::new(options);

                    // Transpile
                    match transpiler.transpile(&ast) {
                        Ok(code) => {
                            self.transpiler_output = code.clone();
                            self.output_editor.text = code;

                            // Update output editor language based on target
                            self.output_editor.language = match self.target_language.as_str() {
                                "Rust" => DslLanguage::Rust,
                                "SQL" => DslLanguage::Sql,
                                "JavaScript" => DslLanguage::JavaScript,
                                "Python" => DslLanguage::Python,
                                _ => DslLanguage::Rust,
                            };
                        }
                        Err(e) => {
                            self.transpiler_error = Some(e.to_string());
                            self.transpiler_output = String::new();
                            self.output_editor.text = String::new();

                            // Trigger AI-powered error analysis
                            self.trigger_error_analysis(&e.to_string());
                        }
                    }
                }
                Err(e) => {
                    self.transpiler_error = Some(format!("Parse error: {}", e));
                    self.transpiler_output = String::new();
                }
            }
        }
    }

    fn show_ai_assistant_panel(&mut self, ui: &mut egui::Ui) {
        ui.group(|ui| {
            ui.vertical(|ui| {
                ui.heading("ü§ñ AI Assistant");
                ui.add_space(10.0);

                // Provider selection
                ui.horizontal(|ui| {
                    ui.label("Provider:");
                    egui::ComboBox::from_id_salt("ai_provider")
                        .selected_text(&self.ai_assistant.get_provider_status())
                        .show_ui(ui, |ui| {
                            ui.selectable_value(&mut self.ai_assistant.provider, AiProvider::OpenAI { api_key: None }, "üîÆ OpenAI");
                            ui.selectable_value(&mut self.ai_assistant.provider, AiProvider::Anthropic { api_key: None }, "üß† Anthropic");
                            ui.selectable_value(&mut self.ai_assistant.provider, AiProvider::Offline, "üîí Offline");
                        });
                });

                // API Key input
                let has_api_key = match &self.ai_assistant.provider {
                    AiProvider::OpenAI { api_key } | AiProvider::Anthropic { api_key } => api_key.is_some(),
                    AiProvider::Offline => false,
                };

                match &self.ai_assistant.provider {
                    AiProvider::OpenAI { .. } | AiProvider::Anthropic { .. } => {
                        if has_api_key {
                            // Key exists - show status and management options
                            ui.horizontal(|ui| {
                                ui.colored_label(egui::Color32::GREEN, "‚úÖ API Key Configured");

                                if ui.button("üîÑ Update").on_hover_text("Update API key").clicked() {
                                    self.show_api_key_input = true;
                                }

                                if ui.button("üóëÔ∏è Remove").on_hover_text("Delete saved API key").clicked() {
                                    // Delete API key from keychain
                                    let result = match &self.ai_assistant.provider {
                                        AiProvider::OpenAI { .. } => {
                                            let delete_result = self.ai_assistant.delete_api_key_from_keychain("openai");
                                            self.ai_assistant.provider = AiProvider::OpenAI { api_key: None };
                                            delete_result
                                        }
                                        AiProvider::Anthropic { .. } => {
                                            let delete_result = self.ai_assistant.delete_api_key_from_keychain("anthropic");
                                            self.ai_assistant.provider = AiProvider::Anthropic { api_key: None };
                                            delete_result
                                        }
                                        _ => Err("Unknown provider".to_string())
                                    };

                                    match result {
                                        Ok(()) => {
                                            self.status_message = "üóëÔ∏è API key deleted from keychain".to_string();
                                        }
                                        Err(e) => {
                                            self.status_message = format!("‚ùå Failed to delete API key: {}", e);
                                        }
                                    }
                                }
                            });
                        } else {
                            // No key - show setup prompt
                            ui.horizontal(|ui| {
                                ui.colored_label(egui::Color32::RED, "‚ùå No API Key");
                                if ui.button("üîê Setup").on_hover_text("Configure API key").clicked() {
                                    self.show_api_key_input = true;
                                }
                            });
                        }

                        // Show input field when requested or when updating
                        if self.show_api_key_input || (!has_api_key && self.ai_api_key_input.is_empty()) {
                            ui.horizontal(|ui| {
                                ui.label("API Key:");
                                let _response = ui.add(
                                    egui::TextEdit::singleline(&mut self.ai_api_key_input)
                                        .hint_text("Enter API key...")
                                        .password(true)
                                        .desired_width(150.0)
                                );

                                if ui.button("üîê Save").clicked() && !self.ai_api_key_input.is_empty() {
                                    // Securely save API key to keychain
                                    let result = match &self.ai_assistant.provider {
                                        AiProvider::OpenAI { .. } => {
                                            self.ai_assistant.set_and_save_api_key("openai", self.ai_api_key_input.clone())
                                        }
                                        AiProvider::Anthropic { .. } => {
                                            self.ai_assistant.set_and_save_api_key("anthropic", self.ai_api_key_input.clone())
                                        }
                                        _ => Err("Unknown provider".to_string())
                                    };

                                    match result {
                                        Ok(()) => {
                                            self.status_message = "üîê API key saved securely to keychain".to_string();
                                            self.show_api_key_input = false; // Hide input after successful save
                                        }
                                        Err(e) => {
                                            self.status_message = format!("‚ùå Failed to save API key: {}", e);
                                        }
                                    }
                                    self.ai_api_key_input.clear();
                                }

                                if ui.button("‚ùå Cancel").clicked() {
                                    self.show_api_key_input = false;
                                    self.ai_api_key_input.clear();
                                }
                            });
                        }
                    }
                    AiProvider::Offline => {
                        ui.colored_label(egui::Color32::GRAY, "üîí Offline mode - no API key needed");
                    }
                }

                ui.add_space(10.0);

                // Query input
                ui.horizontal(|ui| {
                    ui.label("Ask AI:");
                    if ui.button("üßπ Clear").clicked() {
                        self.ai_query.clear();
                    }
                });

                ui.add(egui::TextEdit::multiline(&mut self.ai_query)
                    .hint_text("Ask for help with DSL syntax, patterns, or optimizations...")
                    .desired_rows(3));

                ui.add_space(5.0);

                // Generate suggestion button
                ui.horizontal(|ui| {
                    if ui.add(egui::Button::new("‚ú® Get Suggestions").min_size(egui::vec2(120.0, 25.0))).clicked() {
                        self.generate_ai_suggestions();
                    }

                    if ui.button("üîÑ Refresh Context").clicked() {
                        self.update_ai_context();
                    }
                });

                ui.add_space(10.0);

                // Context display
                ui.collapsing("üìã Current Context", |ui| {
                    ui.label(format!("Input: {}", if self.ai_assistant.context.current_rule.is_empty() {
                        "No input provided"
                    } else {
                        &self.ai_assistant.context.current_rule
                    }));

                    ui.label(format!("Target: {}", if self.ai_assistant.context.target_language.is_empty() {
                        "Not set"
                    } else {
                        &self.ai_assistant.context.target_language
                    }));

                    if !self.ai_assistant.context.available_attributes.is_empty() {
                        ui.label(format!("Attributes: {} available", self.ai_assistant.context.available_attributes.len()));
                    }

                    if !self.ai_assistant.context.recent_errors.is_empty() {
                        ui.label(format!("Recent errors: {}", self.ai_assistant.context.recent_errors.len()));
                    }
                });

                ui.add_space(10.0);

                // AI Suggestions display
                ui.separator();
                ui.label("üí° AI Suggestions:");

                let mut apply_suggestion_index = None;

                egui::ScrollArea::vertical()
                    .max_height(200.0)
                    .show(ui, |ui| {
                        if self.ai_suggestions.is_empty() {
                            ui.label("No suggestions yet. Ask a question or request help!");
                        } else {
                            for (i, suggestion) in self.ai_suggestions.iter().enumerate() {
                                ui.group(|ui| {
                                    ui.vertical(|ui| {
                                        // Suggestion header
                                        ui.horizontal(|ui| {
                                            let icon = match suggestion.suggestion_type {
                                                SuggestionType::CodeCompletion => "üíª",
                                                SuggestionType::ErrorFix => "üîß",
                                                SuggestionType::Optimization => "‚ö°",
                                                SuggestionType::Alternative => "üîÑ",
                                                SuggestionType::Documentation => "üìñ",
                                                SuggestionType::FunctionUsage => "üîß",
                                                SuggestionType::BestPractice => "‚≠ê",
                                                SuggestionType::SimilarPattern => "üîç",
                                                SuggestionType::PatternMatch => "üéØ",
                                                SuggestionType::AutoComplete => "üèÉ",
                                                SuggestionType::SnippetCompletion => "üìù",
                                                SuggestionType::ErrorAnalysis => "üîç",
                                                SuggestionType::QuickFix => "‚ö°",
                                            };
                                            ui.label(format!("{} {}", icon, suggestion.title));

                                            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                                if ui.small_button("üìã Apply").clicked() {
                                                    apply_suggestion_index = Some(i);
                                                }
                                                ui.label(format!("Confidence: {:.0}%", suggestion.confidence * 100.0));
                                            });
                                        });

                                        // Suggestion content
                                        ui.label(&suggestion.description);

                                        if let Some(code) = &suggestion.code_snippet {
                                            ui.add_space(5.0);
                                            ui.monospace(code);
                                        }
                                    });
                                });
                                ui.add_space(5.0);
                            }
                        }
                    });

                // Apply suggestion outside the borrow
                if let Some(index) = apply_suggestion_index {
                    self.apply_ai_suggestion(index);
                }

                ui.add_space(10.0);

                // Quick actions
                ui.separator();
                ui.label("üöÄ Quick Actions:");
                ui.horizontal_wrapped(|ui| {
                    if ui.small_button("üîç Analyze Input").clicked() {
                        self.ai_query = "Analyze my current DSL expression and suggest improvements".to_string();
                        self.generate_ai_suggestions();
                    }
                    if ui.small_button("üí° Suggest Optimizations").clicked() {
                        self.ai_query = "What optimizations can be applied to this expression?".to_string();
                        self.generate_ai_suggestions();
                    }
                    if ui.small_button("üêõ Debug Errors").clicked() {
                        self.ai_query = "Help me debug any errors in my expression".to_string();
                        self.generate_ai_suggestions();
                    }
                    if ui.small_button("üìö Explain Syntax").clicked() {
                        self.ai_query = "Explain the DSL syntax I'm using".to_string();
                        self.generate_ai_suggestions();
                    }
                });
            });
        });
    }

    fn generate_ai_suggestions(&mut self) {
        // Update context with current state
        self.update_ai_context();

        let query = self.ai_query.clone();

        // Check if we have a valid API key and use real API calls
        if self.ai_assistant.has_valid_api_key() && !query.trim().is_empty() {
            // Use async runtime to call real API
            let rt = &self.runtime;
            let mut ai_assistant = self.ai_assistant.clone();

            match rt.block_on(async {
                ai_assistant.get_suggestions(&query).await
            }) {
                suggestions if !suggestions.is_empty() => {
                    self.ai_suggestions = suggestions;
                    self.status_message = format!("‚ú® Generated {} AI suggestions", self.ai_suggestions.len());
                }
                _ => {
                    // Fallback to offline suggestions if API fails
                    let suggestions = self.ai_assistant.get_offline_suggestions(&query);
                    self.ai_suggestions = suggestions;
                    self.status_message = "‚ö†Ô∏è Using offline suggestions (API unavailable)".to_string();
                }
            }
        } else {
            // Use offline suggestions when no API key is configured
            let suggestions = self.ai_assistant.get_offline_suggestions(&query);
            self.ai_suggestions = suggestions;

            if !self.ai_assistant.has_valid_api_key() {
                self.status_message = "üîí Using offline suggestions (no API key configured)".to_string();
            } else {
                self.status_message = "üí≠ Enter a query to get AI suggestions".to_string();
            }
        }
    }

    fn should_trigger_completion(&self) -> bool {
        // Trigger completion on certain characters or after a delay
        let text = &self.dsl_editor.text;
        let cursor = self.dsl_editor.cursor_position;

        if cursor == 0 || cursor > text.len() {
            return false;
        }

        // Get the character before cursor
        let chars: Vec<char> = text.chars().collect();
        if cursor > 0 && cursor <= chars.len() {
            let prev_char = chars[cursor - 1];
            // Trigger on letters, dots, and after spaces following keywords
            prev_char.is_alphabetic() || prev_char == '.' || prev_char == '_'
        } else {
            false
        }
    }

    fn trigger_code_completion(&mut self) {
        // Update AI context for real-time completion
        self.update_ai_context();

        // Get intelligent code completions based on cursor position
        let completions = self.ai_assistant.get_code_completions(
            &self.dsl_editor.text,
            self.dsl_editor.cursor_position
        );

        // Extract suggestion text for autocomplete popup
        let suggestion_texts: Vec<String> = completions.iter()
            .take(8) // Limit to 8 suggestions for clean UI
            .map(|s| s.title.clone())
            .collect();

        // Set autocomplete suggestions in the editor
        self.dsl_editor.set_autocomplete_suggestions(suggestion_texts);

        // Mix completion suggestions with existing suggestions for the side panel
        if !completions.is_empty() {
            // Keep existing suggestions but prioritize completions
            let mut mixed_suggestions = completions;

            // Add some existing suggestions if we have room
            for suggestion in &self.ai_suggestions {
                if mixed_suggestions.len() < 10 &&
                   !mixed_suggestions.iter().any(|s| s.title == suggestion.title) {
                    mixed_suggestions.push(suggestion.clone());
                }
            }

            self.ai_suggestions = mixed_suggestions;
        }
    }

    fn update_ai_context(&mut self) {
        // Update AI context with current application state
        self.ai_assistant.context.current_rule = self.transpiler_input.clone();

        // Set target language
        self.ai_assistant.context.target_language = self.target_language.clone();

        // Add recent error if present
        if let Some(error) = &self.transpiler_error {
            self.ai_assistant.context.recent_errors.push(error.clone());
            // Keep only last 5 errors
            if self.ai_assistant.context.recent_errors.len() > 5 {
                self.ai_assistant.context.recent_errors.remove(0);
            }
        }

        // Add available attributes from dictionary
        if let Some(dictionary) = &self.data_dictionary {
            let mut attributes = Vec::new();
            for attr in &dictionary.attributes {
                if let Some(attr_name) = attr.get("attribute_name").and_then(|v| v.as_str()) {
                    if let Some(entity_name) = attr.get("entity_name").and_then(|v| v.as_str()) {
                        attributes.push(format!("{}.{}", entity_name, attr_name));
                    } else {
                        attributes.push(attr_name.to_string());
                    }
                }
            }
            self.ai_assistant.context.available_attributes = attributes;
        }
    }

    fn apply_autocomplete_suggestion(&mut self, suggestion: &str) {
        let cursor_pos = self.dsl_editor.cursor_position;
        let text = &self.dsl_editor.text;

        // Find the word being completed
        let (word_start, _current_word) = self.dsl_editor.get_word_at_position(cursor_pos);

        // Replace the partial word with the suggestion
        let mut new_text = String::new();
        new_text.push_str(&text[..word_start]);
        new_text.push_str(suggestion);
        new_text.push_str(&text[cursor_pos..]);

        // Update the editor
        self.dsl_editor.text = new_text.clone();
        self.dsl_editor.cursor_position = word_start + suggestion.len();
        self.transpiler_input = new_text;

        // Trigger transpilation to validate the new code
        self.transpile_expression();
    }

    fn apply_ai_suggestion(&mut self, suggestion_index: usize) {
        if let Some(suggestion) = self.ai_suggestions.get(suggestion_index) {
            match suggestion.suggestion_type {
                SuggestionType::CodeCompletion | SuggestionType::Alternative |
                SuggestionType::AutoComplete | SuggestionType::SnippetCompletion => {
                    // Replace current input with suggested code
                    if let Some(code) = &suggestion.code_snippet {
                        self.transpiler_input = code.clone();
                        self.dsl_editor.text = code.clone();

                        // Auto-transpile the new code
                        self.transpile_expression();
                    }
                }
                SuggestionType::ErrorFix | SuggestionType::QuickFix => {
                    // Apply the fix to current input
                    if let Some(code) = &suggestion.code_snippet {
                        self.transpiler_input = code.clone();
                        self.dsl_editor.text = code.clone();
                        self.transpile_expression();
                    }
                }
                SuggestionType::ErrorAnalysis => {
                    // For error analysis, just display the information
                    // The analysis text is already shown in the UI
                }
                SuggestionType::Optimization => {
                    // Apply optimization and retranspile
                    if let Some(code) = &suggestion.code_snippet {
                        self.transpiler_input = code.clone();
                        self.dsl_editor.text = code.clone();
                        self.optimization_enabled = true; // Enable optimizations
                        self.transpile_expression();
                    }
                }
                _ => {
                    // For explanations, just show in a popup or status
                    // Note: Clipboard access requires UI context, handled in the UI layer
                }
            }
        }
    }

    fn trigger_error_analysis(&mut self, error_message: &str) {
        let suggestions = self.ai_assistant.analyze_error(error_message, &self.transpiler_input);

        // Add error analysis suggestions to the AI suggestions list
        for suggestion in suggestions {
            self.ai_suggestions.push(suggestion);
        }

        // Ensure AI panel is visible
        self.show_ai_panel = true;
    }

    // New Taxonomy UI Methods
    fn show_product_taxonomy_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üì¶ Product Taxonomy");
        ui.separator();

        // Top toolbar with editing controls
        ui.horizontal(|ui| {
            if ui.button("üîÑ Refresh Data").clicked() {
                self.load_product_taxonomy();
                self.save_feedback = Some("Data refreshed from database".to_string());
            }

            ui.separator();

            // Edit mode toggles
            ui.checkbox(&mut self.edit_mode_products, "‚úèÔ∏è Edit Products");
            ui.checkbox(&mut self.edit_mode_services, "‚úèÔ∏è Edit Services");
            ui.checkbox(&mut self.edit_mode_options, "‚úèÔ∏è Edit Options");

            ui.separator();

            // Save button - only show if there are pending changes or edit mode is on
            if self.edit_mode_products || self.edit_mode_services || self.edit_mode_options {
                if ui.button("üíæ Save Changes").clicked() {
                    self.save_taxonomy_changes();
                }

                if self.pending_changes {
                    ui.colored_label(egui::Color32::YELLOW, "‚ö†Ô∏è Unsaved changes");
                }
            }
        });

        // Display save feedback
        if let Some(feedback) = &self.save_feedback.clone() {
            ui.horizontal(|ui| {
                if feedback.contains("Error") || feedback.contains("Failed") {
                    ui.colored_label(egui::Color32::RED, format!("‚ùå {}", feedback));
                } else {
                    ui.colored_label(egui::Color32::GREEN, format!("‚úÖ {}", feedback));
                }
                if ui.small_button("√ó").clicked() {
                    self.save_feedback = None;
                }
            });
        }

        ui.separator();

        // Products section - Interactive Editor
        ui.collapsing("üè™ Products", |ui| {
            if self.products.is_empty() {
                ui.label("No products loaded. Click refresh to load data.");
            } else {
                for product in &mut self.products {
                    ui.group(|ui| {
                        ui.horizontal(|ui| {
                            ui.label("Product Name:");
                            if self.edit_mode_products {
                                if ui.text_edit_singleline(&mut product.product_name).changed() {
                                    self.pending_changes = true;
                                }
                            } else {
                                ui.strong(&product.product_name);
                            }
                            ui.label(format!("({})", product.product_id));
                        });

                        ui.horizontal(|ui| {
                            ui.label("Business Line:");
                            if self.edit_mode_products {
                                if ui.text_edit_singleline(&mut product.line_of_business).changed() {
                                    self.pending_changes = true;
                                }
                            } else {
                                ui.label(&product.line_of_business);
                            }
                        });

                        if let Some(ref mut desc) = product.description {
                            ui.horizontal(|ui| {
                                ui.label("Description:");
                                if self.edit_mode_products {
                                    if ui.text_edit_multiline(desc).changed() {
                                        self.pending_changes = true;
                                    }
                                } else {
                                    ui.label(desc.as_str());
                                }
                            });
                        }

                        ui.horizontal(|ui| {
                            ui.label("Status:");
                            if self.edit_mode_products {
                                egui::ComboBox::from_id_salt(format!("status_{}", product.id))
                                    .selected_text(&product.status)
                                    .show_ui(ui, |ui| {
                                        let old_status = product.status.clone();
                                        ui.selectable_value(&mut product.status, "active".to_string(), "Active");
                                        ui.selectable_value(&mut product.status, "deprecated".to_string(), "Deprecated");
                                        ui.selectable_value(&mut product.status, "beta".to_string(), "Beta");
                                        ui.selectable_value(&mut product.status, "coming_soon".to_string(), "Coming Soon");
                                        if product.status != old_status {
                                            self.pending_changes = true;
                                        }
                                    });
                            } else {
                                match product.status.as_str() {
                                    "active" => ui.colored_label(egui::Color32::GREEN, "‚úÖ Active"),
                                    "deprecated" => ui.colored_label(egui::Color32::RED, "‚ùå Deprecated"),
                                    "beta" => ui.colored_label(egui::Color32::BLUE, "üß™ Beta"),
                                    _ => ui.colored_label(egui::Color32::YELLOW, &product.status),
                                };
                            }
                        });
                    });
                }
            }
        });

        // Product Options section
        ui.collapsing("‚öôÔ∏è Product Options", |ui| {
            if self.product_options.is_empty() {
                ui.label("No product options loaded.");
            } else {
                for option in &self.product_options {
                    ui.group(|ui| {
                        ui.horizontal(|ui| {
                            ui.strong(&option.option_name);
                            ui.label(format!("({})", option.option_category));
                        });
                        if let Some(display_name) = &option.display_name {
                            ui.label(format!("Display: {}", display_name));
                        }
                        if let Some(pricing_impact) = option.pricing_impact {
                            // Handle rust_decimal::Decimal properly
                            let pricing_value = pricing_impact.to_string().parse::<f64>().unwrap_or(0.0);
                            ui.label(format!("Pricing Impact: ${:.2}", pricing_value));
                        }
                        ui.horizontal(|ui| {
                            ui.label("Type:");
                            match option.option_type.as_str() {
                                "required" => ui.colored_label(egui::Color32::RED, "Required"),
                                "optional" => ui.colored_label(egui::Color32::BLUE, "Optional"),
                                "premium" => ui.colored_label(egui::Color32::GOLD, "Premium"),
                                _ => ui.label(&option.option_type),
                            };
                        });
                    });
                }
            }
        });

        // Services section - Interactive Editor
        ui.collapsing("üîß Services", |ui| {
            if self.services.is_empty() {
                ui.label("No services loaded.");
            } else {
                for service in &mut self.services {
                    ui.group(|ui| {
                        ui.horizontal(|ui| {
                            ui.label("Service Name:");
                            if self.edit_mode_services {
                                if ui.text_edit_singleline(&mut service.service_name).changed() {
                                    self.pending_changes = true;
                                }
                            } else {
                                ui.strong(&service.service_name);
                            }
                            if let Some(ref category) = service.service_category {
                                ui.label(format!("({})", category));
                            }
                        });

                        if let Some(ref mut service_type) = service.service_type {
                            ui.horizontal(|ui| {
                                ui.label("Type:");
                                if self.edit_mode_services {
                                    if ui.text_edit_singleline(service_type).changed() {
                                        self.pending_changes = true;
                                    }
                                } else {
                                    ui.label(service_type.as_str());
                                }
                            });
                        }

                        if let Some(ref mut delivery_model) = service.delivery_model {
                            ui.horizontal(|ui| {
                                ui.label("Delivery:");
                                if self.edit_mode_services {
                                    if ui.text_edit_singleline(delivery_model).changed() {
                                        self.pending_changes = true;
                                    }
                                } else {
                                    ui.label(delivery_model.as_str());
                                }
                            });
                        }

                        if let Some(ref mut billable) = service.billable {
                            ui.horizontal(|ui| {
                                ui.label("Billable:");
                                if self.edit_mode_services {
                                    if ui.checkbox(billable, "").changed() {
                                        self.pending_changes = true;
                                    }
                                } else {
                                    if *billable {
                                        ui.colored_label(egui::Color32::GREEN, "‚úÖ Yes");
                                    } else {
                                        ui.colored_label(egui::Color32::GRAY, "‚ùå No");
                                    }
                                }
                            });
                        }
                    });
                }
            }
        });

        // Resources section
        ui.collapsing("üíª Resources", |ui| {
            if self.resources.is_empty() {
                ui.label("No resources loaded.");
            } else {
                for resource in &self.resources {
                    ui.group(|ui| {
                        ui.horizontal(|ui| {
                            ui.strong(&resource.resource_name);
                            ui.label(format!("v{}", resource.version));
                        });

                        if let Some(description) = &resource.description {
                            ui.label(format!("Description: {}", description));
                        }

                        if let Some(resource_type) = &resource.resource_type {
                            ui.horizontal(|ui| {
                                ui.label("Type:");
                                ui.strong(resource_type);
                            });
                        }

                        if let Some(category) = &resource.category {
                            ui.label(format!("Category: {}", category));
                        }

                        ui.horizontal(|ui| {
                            if let Some(criticality) = &resource.criticality_level {
                                ui.label("Criticality:");
                                match criticality.as_str() {
                                    "high" => ui.colored_label(egui::Color32::RED, "üî¥ High"),
                                    "medium" => ui.colored_label(egui::Color32::YELLOW, "üü° Medium"),
                                    "low" => ui.colored_label(egui::Color32::GREEN, "üü¢ Low"),
                                    _ => ui.label(criticality),
                                };
                            }

                            if let Some(status) = &resource.operational_status {
                                ui.label("Status:");
                                match status.as_str() {
                                    "active" => ui.colored_label(egui::Color32::GREEN, "‚úÖ Active"),
                                    "maintenance" => ui.colored_label(egui::Color32::YELLOW, "üîß Maintenance"),
                                    "deprecated" => ui.colored_label(egui::Color32::RED, "‚ùå Deprecated"),
                                    _ => ui.label(status),
                                };
                            }
                        });

                        if let Some(owner_team) = &resource.owner_team {
                            ui.label(format!("Owner Team: {}", owner_team));
                        }
                    });
                }
            }
        });

        // Service-Resource Hierarchy (1 Service : n Resources)
        ui.collapsing("üîó Service ‚Üí Resources Hierarchy", |ui| {
            if self.service_resource_hierarchy.is_empty() {
                ui.label("No service-resource mappings loaded.");
            } else {
                // Group by service
                let mut services: std::collections::HashMap<String, Vec<&ServiceResourceHierarchy>> = std::collections::HashMap::new();
                for hierarchy_item in &self.service_resource_hierarchy {
                    services.entry(hierarchy_item.service_name.clone())
                        .or_insert_with(Vec::new)
                        .push(hierarchy_item);
                }

                for (service_name, resources) in services {
                    ui.collapsing(format!("üîß {} (‚Üí {} resources)", service_name, resources.len()), |ui| {
                        // Service details
                        if let Some(first_resource) = resources.first() {
                            ui.horizontal(|ui| {
                                ui.label("Service Type:");
                                if let Some(service_type) = &first_resource.service_type {
                                    ui.strong(service_type);
                                }
                            });

                            if let Some(category) = &first_resource.service_category {
                                ui.label(format!("Category: {}", category));
                            }

                            if let Some(delivery) = &first_resource.delivery_model {
                                ui.label(format!("Delivery Model: {}", delivery));
                            }
                        }

                        ui.separator();
                        ui.label("üì¶ Connected Resources:");

                        // Sort by dependency level
                        let mut sorted_resources = resources;
                        sorted_resources.sort_by_key(|r| r.dependency_level.unwrap_or(999));

                        for resource in sorted_resources {
                            ui.group(|ui| {
                                ui.horizontal(|ui| {
                                    ui.strong(&resource.resource_name);
                                    ui.label(format!("(Level {})", resource.dependency_level.unwrap_or(0)));

                                    // Usage type badge
                                    match resource.usage_type.as_str() {
                                        "primary" => ui.colored_label(egui::Color32::BLUE, "üéØ Primary"),
                                        "secondary" => ui.colored_label(egui::Color32::GRAY, "üîÑ Secondary"),
                                        "auxiliary" => ui.colored_label(egui::Color32::GREEN, "‚ûï Auxiliary"),
                                        _ => ui.label(&resource.usage_type),
                                    };
                                });

                                if let Some(role) = &resource.resource_role {
                                    ui.label(format!("Role: {}", role));
                                }

                                ui.horizontal(|ui| {
                                    if let Some(cost_pct) = &resource.cost_allocation_percentage {
                                        // Handle rust_decimal::Decimal properly
                                        let cost_value = cost_pct.to_string().parse::<f64>().unwrap_or(0.0);
                                        ui.label(format!("Cost Allocation: {:.1}%", cost_value));
                                    }

                                    if let Some(criticality) = &resource.criticality_level {
                                        ui.label("Criticality:");
                                        match criticality.as_str() {
                                            "high" => ui.colored_label(egui::Color32::RED, "üî¥ High"),
                                            "medium" => ui.colored_label(egui::Color32::YELLOW, "üü° Medium"),
                                            "low" => ui.colored_label(egui::Color32::GREEN, "üü¢ Low"),
                                            _ => ui.label(criticality),
                                        };
                                    }
                                });

                                if let Some(owner) = &resource.owner_team {
                                    ui.label(format!("Owner: {}", owner));
                                }
                            });
                        }
                    });
                }
            }
        });
    }

    fn save_taxonomy_changes(&mut self) {
        if let Some(ref pool) = self.db_pool {
            let pool = pool.clone();
            let rt = self.runtime.clone();

            // Save products if in edit mode
            if self.edit_mode_products {
                for product in &self.products {
                    match rt.block_on(async {
                        sqlx::query(
                            "UPDATE products SET
                             product_name = $1,
                             line_of_business = $2,
                             description = $3,
                             status = $4,
                             updated_at = CURRENT_TIMESTAMP
                             WHERE id = $5"
                        )
                        .bind(&product.product_name)
                        .bind(&product.line_of_business)
                        .bind(&product.description)
                        .bind(&product.status)
                        .bind(product.id)
                        .execute(&pool)
                        .await
                    }) {
                        Ok(_) => {},
                        Err(e) => {
                            self.save_feedback = Some(format!("Error saving product {}: {}", product.product_name, e));
                            return;
                        }
                    }
                }
            }

            // Save services if in edit mode
            if self.edit_mode_services {
                for service in &self.services {
                    match rt.block_on(async {
                        sqlx::query(
                            "UPDATE services SET
                             service_name = $1,
                             service_type = $2,
                             delivery_model = $3,
                             billable = $4,
                             updated_at = CURRENT_TIMESTAMP
                             WHERE id = $5"
                        )
                        .bind(&service.service_name)
                        .bind(&service.service_type)
                        .bind(&service.delivery_model)
                        .bind(&service.billable)
                        .bind(service.id)
                        .execute(&pool)
                        .await
                    }) {
                        Ok(_) => {},
                        Err(e) => {
                            self.save_feedback = Some(format!("Error saving service {}: {}", service.service_name, e));
                            return;
                        }
                    }
                }
            }

            // Success feedback
            let mut saved_items = Vec::new();
            if self.edit_mode_products { saved_items.push("products"); }
            if self.edit_mode_services { saved_items.push("services"); }
            if self.edit_mode_options { saved_items.push("options"); }

            self.save_feedback = Some(format!("Successfully saved changes to: {}", saved_items.join(", ")));
            self.pending_changes = false;
        } else {
            self.save_feedback = Some("Error: No database connection available".to_string());
        }
    }

    fn show_investment_mandates_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üéØ Investment Mandates & Entity Relationships");
        ui.separator();

        // Refresh button
        if ui.button("üîÑ Refresh Data").clicked() {
            self.load_investment_mandates();
        }

        ui.separator();

        if self.cbu_mandate_structure.is_empty() {
            ui.label("No CBU mandate structure loaded. Click refresh to load data.");
            return;
        }

        // Group CBU data with multiple entities (stable grouping to prevent strobing)
        let mut cbu_groups: std::collections::HashMap<String, Vec<&crate::CbuInvestmentMandateStructure>> = std::collections::HashMap::new();
        for structure in &self.cbu_mandate_structure {
            cbu_groups.entry(structure.cbu_id.clone()).or_insert_with(Vec::new).push(structure);
        }

        // Early return if no data to prevent empty UI loops
        if cbu_groups.is_empty() {
            ui.label("No CBU mandate data available.");
            return;
        }

        // CBU-centered view with expand/collapse functionality
        egui::ScrollArea::vertical().show(ui, |ui| {
            let mut cbus_to_expand: Option<String> = None;
            let mut cbus_to_collapse: Option<String> = None;

            // Create a sorted vector to ensure stable ordering and prevent strobing
            let mut cbu_list: Vec<_> = cbu_groups.iter().collect();
            cbu_list.sort_by(|a, b| a.0.cmp(b.0)); // Sort by CBU ID

            for (cbu_id, structures) in cbu_list {
                let is_expanded = self.expanded_cbus.contains(cbu_id);

                ui.push_id(cbu_id, |ui| {
                    // CBU header with entity count
                    ui.group(|ui| {
                        ui.horizontal(|ui| {
                            // Expand/collapse button
                            let expand_button = if is_expanded { "üîΩ" } else { "‚ñ∂Ô∏è" };
                            if ui.button(expand_button).clicked() {
                                if is_expanded {
                                    cbus_to_collapse = Some(cbu_id.clone());
                                } else {
                                    cbus_to_expand = Some(cbu_id.clone());
                                }
                            }

                            // CBU info with entity counts
                            if let Some(first_structure) = structures.first() {
                                ui.label("üè¢");
                                ui.strong(&first_structure.cbu_name);
                                ui.separator();
                                ui.label(format!("ID: {}", cbu_id));
                                ui.separator();

                                // Count unique entities in this CBU
                                let mut entities = std::collections::HashSet::new();
                                for structure in structures {
                                    if let Some(asset_owner) = &structure.asset_owner_name {
                                        entities.insert(("Asset Owner", asset_owner.as_str()));
                                    }
                                    if let Some(investment_manager) = &structure.investment_manager_name {
                                        entities.insert(("Investment Manager", investment_manager.as_str()));
                                    }
                                }

                                ui.colored_label(egui::Color32::BLUE, format!("üë• {} Entities", entities.len()));
                                ui.separator();
                                ui.colored_label(egui::Color32::GREEN, format!("üìã {} Mandates", structures.len()));
                            }
                        });
                    });

                    // Expanded view showing entity relationship map
                    if is_expanded {
                        ui.add_space(5.0);

                        // Entity Relationship Visual Map
                        ui.group(|ui| {
                            ui.heading("üó∫Ô∏è Entity Relationship Map");
                            ui.separator();

                            // Create visual connection lines between entities
                            for structure in structures {
                                if let Some(mandate_id) = &structure.mandate_id {
                                    ui.group(|ui| {
                                        ui.vertical(|ui| {
                                            // Mandate header
                                            ui.horizontal(|ui| {
                                                ui.label("üìã");
                                                ui.strong(mandate_id);
                                                if let Some(currency) = &structure.base_currency {
                                                    ui.label(format!("({} based)", currency));
                                                }
                                            });

                                            ui.add_space(5.0);

                                            // Visual entity flow with connecting arrows
                                            ui.horizontal(|ui| {
                                                // Asset Owner
                                                if let Some(asset_owner) = &structure.asset_owner_name {
                                                    ui.group(|ui| {
                                                        ui.vertical(|ui| {
                                                            ui.colored_label(egui::Color32::GOLD, "üí∞ Asset Owner");
                                                            ui.strong(asset_owner);
                                                            ui.small("Gives Mandate");
                                                        });
                                                    });

                                                    ui.label("‚û°Ô∏è");
                                                }

                                                // Investment Manager
                                                if let Some(investment_manager) = &structure.investment_manager_name {
                                                    ui.group(|ui| {
                                                        ui.vertical(|ui| {
                                                            ui.colored_label(egui::Color32::LIGHT_BLUE, "üìä Investment Manager");
                                                            ui.strong(investment_manager);
                                                            ui.small("Executes Mandate");
                                                        });
                                                    });

                                                    ui.label("‚û°Ô∏è");
                                                }

                                                // CBU Services
                                                ui.group(|ui| {
                                                    ui.vertical(|ui| {
                                                        ui.colored_label(egui::Color32::GREEN, "üè¢ CBU Services");
                                                        ui.strong(&structure.cbu_name);
                                                        ui.small("Provides Infrastructure");
                                                    });
                                                });
                                            });

                                            // Investment details below the flow
                                            ui.add_space(5.0);
                                            ui.horizontal(|ui| {
                                                if let Some(instruments) = structure.total_instruments {
                                                    ui.label(format!("üé™ {} Instruments", instruments));
                                                    ui.separator();
                                                }
                                                if let Some(families) = &structure.families {
                                                    ui.label(format!("üìÅ {}", families));
                                                    ui.separator();
                                                }
                                                if let Some(exposure) = structure.total_exposure_pct {
                                                    let exposure_value = exposure.to_string().parse::<f64>().unwrap_or(0.0);
                                                    ui.colored_label(egui::Color32::YELLOW, format!("üìà {:.1}% Exposure", exposure_value));
                                                }
                                            });
                                        });
                                    });
                                }
                            }
                        });

                        ui.add_space(5.0);

                        // Related Member Roles for this CBU
                        ui.group(|ui| {
                            ui.heading("üë• Member Roles & Authorities");
                            ui.separator();

                            let cbu_roles: Vec<_> = self.cbu_member_roles.iter()
                                .filter(|role| &role.cbu_id == cbu_id)
                                .collect();

                            if cbu_roles.is_empty() {
                                ui.label("No specific member roles found for this CBU.");
                            } else {
                                // Group roles by entity (stable grouping to prevent strobing)
                                let mut role_groups: std::collections::HashMap<String, Vec<&crate::CbuMemberInvestmentRole>> = std::collections::HashMap::new();
                                for role in cbu_roles {
                                    role_groups.entry(role.entity_name.clone()).or_insert_with(Vec::new).push(role);
                                }

                                // Create a sorted vector to ensure stable ordering for entities
                                let mut entity_list: Vec<_> = role_groups.iter().collect();
                                entity_list.sort_by(|a, b| a.0.cmp(b.0)); // Sort by entity name

                                for (entity_name, entity_roles) in entity_list {
                                    ui.group(|ui| {
                                        ui.vertical(|ui| {
                                            ui.horizontal(|ui| {
                                                ui.strong(entity_name);
                                                ui.label(format!("({} roles)", entity_roles.len()));
                                            });

                                            // Sort roles within each entity for stability
                                            let mut sorted_roles = entity_roles.clone();
                                            sorted_roles.sort_by(|a, b| a.role_name.cmp(&b.role_name));

                                            for role in sorted_roles {
                                                ui.horizontal(|ui| {
                                                    ui.label("üé≠");
                                                    ui.strong(&role.role_name);
                                                    ui.separator();
                                                    ui.label(&role.investment_responsibility);
                                                    ui.separator();

                                                    // Show authorities with colors
                                                    if role.has_trading_authority.unwrap_or(false) {
                                                        ui.colored_label(egui::Color32::GREEN, "üîÑ");
                                                    }
                                                    if role.has_settlement_authority.unwrap_or(false) {
                                                        ui.colored_label(egui::Color32::BLUE, "üí±");
                                                    }

                                                    if let Some(mandate_id) = &role.mandate_id {
                                                        ui.separator();
                                                        ui.small(format!("Mandate: {}", mandate_id));
                                                    }
                                                });
                                            }
                                        });
                                    });
                                }
                            }
                        });

                        ui.add_space(10.0);
                    }
                });
            }

            // Handle expand/collapse after iteration to avoid borrowing issues
            if let Some(cbu_id) = cbus_to_expand {
                self.expanded_cbus.insert(cbu_id);
                // Request repaint only when state actually changes
                ui.ctx().request_repaint();
            }
            if let Some(cbu_id) = cbus_to_collapse {
                self.expanded_cbus.remove(&cbu_id);
                // Request repaint only when state actually changes
                ui.ctx().request_repaint();
            }
        });
    }

    fn show_taxonomy_hierarchy_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üèóÔ∏è Taxonomy Hierarchy");
        ui.separator();

        ui.label("Complete Products ‚Üí Options ‚Üí Services ‚Üí Resources hierarchy view");
        ui.separator();

        if ui.button("üîÑ Load Sample Hierarchy").clicked() {
            self.load_taxonomy_hierarchy();
        }

        if !self.taxonomy_hierarchy.is_empty() {
            ui.collapsing("üìä Hierarchy Data", |ui| {
                for item in &self.taxonomy_hierarchy {
                    ui.group(|ui| {
                        ui.horizontal(|ui| {
                            ui.strong(&item.item_name);
                            ui.label(format!("Level {}: {}", item.level, item.item_type));
                        });
                        if let Some(desc) = &item.item_description {
                            ui.label(desc);
                        }
                    });
                }
            });
        }
    }

    // Database Loading Methods
    fn load_product_taxonomy(&mut self) {
        if let Some(ref pool) = self.db_pool {
            let pool = pool.clone();
            let rt = self.runtime.clone();

            // Load products
            match rt.block_on(async {
                sqlx::query(
                    "SELECT id, product_id, product_name, line_of_business, description, status,
                     contract_type, commercial_status, pricing_model, target_market
                     FROM products WHERE status = 'active' ORDER BY product_name")
                .fetch_all(&pool)
                .await
            }) {
                Ok(rows) => {
                    self.products = rows.into_iter().map(|row| Product {
                        id: row.get("id"),
                        product_id: row.get("product_id"),
                        product_name: row.get("product_name"),
                        line_of_business: row.get("line_of_business"),
                        description: row.get("description"),
                        status: row.get("status"),
                        contract_type: row.get("contract_type"),
                        commercial_status: row.get("commercial_status"),
                        pricing_model: row.get("pricing_model"),
                        target_market: row.get("target_market"),
                    }).collect();
                    self.status_message = format!("Loaded {} products", self.products.len());
                }
                Err(e) => {
                    // Load mock data if database query fails
                    self.load_mock_product_taxonomy();
                    self.status_message = format!("Database error, loaded mock data: {}", e);
                }
            }

            // Load product options
            match rt.block_on(async {
                sqlx::query(
                    "SELECT id, option_id, product_id, option_name, option_category, option_type,
                     option_value, display_name, description, pricing_impact, status
                     FROM product_options WHERE status = 'active' ORDER BY option_name")
                .fetch_all(&pool)
                .await
            }) {
                Ok(rows) => {
                    self.product_options = rows.into_iter().map(|row| ProductOption {
                        id: row.get("id"),
                        option_id: row.get("option_id"),
                        product_id: row.get("product_id"),
                        option_name: row.get("option_name"),
                        option_category: row.get("option_category"),
                        option_type: row.get("option_type"),
                        option_value: row.get("option_value"),
                        display_name: row.get("display_name"),
                        description: row.get("description"),
                        pricing_impact: row.get("pricing_impact"),
                        status: row.get("status"),
                    }).collect();
                }
                Err(e) => {
                    eprintln!("Error loading product options: {}", e);
                    // Load mock options if database fails
                    if self.product_options.is_empty() {
                        self.load_mock_product_taxonomy();
                    }
                }
            }

            // Load services
            match rt.block_on(async {
                sqlx::query(
                    "SELECT id, service_id, service_name, service_category, description,
                     service_type, delivery_model, billable, status
                     FROM services WHERE status = 'active' ORDER BY service_name")
                .fetch_all(&pool)
                .await
            }) {
                Ok(rows) => {
                    self.services = rows.into_iter().map(|row| Service {
                        id: row.get("id"),
                        service_id: row.get("service_id"),
                        service_name: row.get("service_name"),
                        service_category: row.get("service_category"),
                        description: row.get("description"),
                        service_type: row.get("service_type"),
                        delivery_model: row.get("delivery_model"),
                        billable: row.get("billable"),
                        status: row.get("status"),
                    }).collect();
                }
                Err(e) => {
                    eprintln!("Error loading services: {}", e);
                    // Load mock services if database fails
                    if self.services.is_empty() {
                        self.load_mock_product_taxonomy();
                    }
                }
            }

            // Load resources
            match rt.block_on(async {
                sqlx::query(
                    "SELECT id, resource_name, description, version, category, resource_type,
                     criticality_level, operational_status, owner_team, status
                     FROM resource_objects WHERE status = 'active' ORDER BY resource_name")
                .fetch_all(&pool)
                .await
            }) {
                Ok(rows) => {
                    self.resources = rows.into_iter().map(|row| ResourceObject {
                        id: row.get("id"),
                        resource_name: row.get("resource_name"),
                        description: row.get("description"),
                        version: row.get("version"),
                        category: row.get("category"),
                        resource_type: row.get("resource_type"),
                        criticality_level: row.get("criticality_level"),
                        operational_status: row.get("operational_status"),
                        owner_team: row.get("owner_team"),
                        status: row.get("status"),
                    }).collect();
                }
                Err(e) => {
                    eprintln!("Error loading resources: {}", e);
                    // Load mock resources if database fails
                    if self.resources.is_empty() {
                        self.load_mock_product_taxonomy();
                    }
                }
            }

            // Load service-resource hierarchy
            match rt.block_on(async {
                sqlx::query(
                    "SELECT service_id, service_code, service_name, service_category, service_type,
                     delivery_model, billable, service_description, service_status,
                     resource_id, resource_name, resource_description, resource_version,
                     resource_category, resource_type, criticality_level, operational_status,
                     owner_team, usage_type, resource_role, cost_allocation_percentage, dependency_level
                     FROM service_resources_hierarchy ORDER BY service_name, dependency_level")
                .fetch_all(&pool)
                .await
            }) {
                Ok(rows) => {
                    self.service_resource_hierarchy = rows.into_iter().map(|row| ServiceResourceHierarchy {
                        service_id: row.get("service_id"),
                        service_code: row.get("service_code"),
                        service_name: row.get("service_name"),
                        service_category: row.get("service_category"),
                        service_type: row.get("service_type"),
                        delivery_model: row.get("delivery_model"),
                        billable: row.get("billable"),
                        service_description: row.get("service_description"),
                        service_status: row.get("service_status"),
                        resource_id: row.get("resource_id"),
                        resource_name: row.get("resource_name"),
                        resource_description: row.get("resource_description"),
                        resource_version: row.get("resource_version"),
                        resource_category: row.get("resource_category"),
                        resource_type: row.get("resource_type"),
                        criticality_level: row.get("criticality_level"),
                        operational_status: row.get("operational_status"),
                        owner_team: row.get("owner_team"),
                        usage_type: row.get("usage_type"),
                        resource_role: row.get("resource_role"),
                        cost_allocation_percentage: row.get("cost_allocation_percentage"),
                        dependency_level: row.get("dependency_level"),
                    }).collect();
                }
                Err(e) => {
                    eprintln!("Error loading service-resource hierarchy: {}", e);
                    // Load mock hierarchy if database fails
                    if self.service_resource_hierarchy.is_empty() {
                        self.load_mock_product_taxonomy();
                    }
                }
            }
        } else {
            // No database connection, load mock data
            self.load_mock_product_taxonomy();
            self.load_mock_investment_mandates();
            self.load_mock_onboarding_requests();
        }
    }

    fn load_investment_mandates(&mut self) {
        if let Some(ref pool) = self.db_pool {
            let pool = pool.clone();
            let rt = self.runtime.clone();

            // Load CBU investment mandate structure
            match rt.block_on(async {
                sqlx::query(
                    "SELECT cbu_id, cbu_name, mandate_id, asset_owner_name, investment_manager_name,
                     base_currency, total_instruments, families, total_exposure_pct
                     FROM cbu_investment_mandate_structure ORDER BY cbu_id")
                .fetch_all(&pool)
                .await
            }) {
                Ok(rows) => {
                    // Try to map rows and catch any conversion errors
                    let mut structures = Vec::new();
                    for row in rows {
                        match (|| -> Result<CbuInvestmentMandateStructure, Box<dyn std::error::Error>> {
                            Ok(CbuInvestmentMandateStructure {
                                cbu_id: row.try_get("cbu_id")?,
                                cbu_name: row.try_get("cbu_name")?,
                                mandate_id: row.try_get("mandate_id").ok(),
                                asset_owner_name: row.try_get("asset_owner_name").ok(),
                                investment_manager_name: row.try_get("investment_manager_name").ok(),
                                base_currency: row.try_get("base_currency").ok(),
                                total_instruments: row.try_get("total_instruments").ok(),
                                families: row.try_get("families").ok(),
                                total_exposure_pct: row.try_get("total_exposure_pct").ok(),
                            })
                        })() {
                            Ok(structure) => structures.push(structure),
                            Err(e) => {
                                eprintln!("Error converting row to CbuInvestmentMandateStructure: {}", e);
                                self.status_message = format!("Data conversion error: {}", e);
                            }
                        }
                    }
                    self.cbu_mandate_structure = structures;
                    self.status_message = format!("Loaded {} CBU mandate structures", self.cbu_mandate_structure.len());
                }
                Err(e) => {
                    eprintln!("Database query error for CBU mandate structure: {}", e);
                    self.status_message = format!("Database error, loading mock investment mandates: {}", e);
                    self.load_mock_investment_mandates();
                }
            }

            // Load CBU member investment roles
            match rt.block_on(async {
                sqlx::query(
                    "SELECT cbu_id, cbu_name, entity_name, entity_lei, role_name, role_code,
                     investment_responsibility, mandate_id, has_trading_authority, has_settlement_authority
                     FROM cbu_member_investment_roles ORDER BY cbu_id, role_code")
                .fetch_all(&pool)
                .await
            }) {
                Ok(rows) => {
                    // Try to map rows and catch any conversion errors
                    let mut roles = Vec::new();
                    for row in rows {
                        match (|| -> Result<CbuMemberInvestmentRole, Box<dyn std::error::Error>> {
                            Ok(CbuMemberInvestmentRole {
                                cbu_id: row.try_get("cbu_id")?,
                                cbu_name: row.try_get("cbu_name")?,
                                entity_name: row.try_get("entity_name")?,
                                entity_lei: row.try_get("entity_lei").ok(),
                                role_name: row.try_get("role_name")?,
                                role_code: row.try_get("role_code")?,
                                investment_responsibility: row.try_get("investment_responsibility")?,
                                mandate_id: row.try_get("mandate_id").ok(),
                                has_trading_authority: row.try_get("has_trading_authority").ok(),
                                has_settlement_authority: row.try_get("has_settlement_authority").ok(),
                            })
                        })() {
                            Ok(role) => roles.push(role),
                            Err(e) => {
                                eprintln!("Error converting row to CbuMemberInvestmentRole: {}", e);
                            }
                        }
                    }
                    self.cbu_member_roles = roles;
                }
                Err(e) => {
                    eprintln!("Database query error for CBU member roles: {}", e);
                }
            }
        } else {
            self.load_mock_investment_mandates();
        }
    }

    fn load_mock_investment_mandates(&mut self) {
        use std::str::FromStr;

        // Mock Investment Mandates - Comprehensive Global Examples
        self.investment_mandates = vec![
            // Conservative Government Bond Strategy
            InvestmentMandate {
                mandate_id: "MND-2024-001".to_string(),
                cbu_id: "CBU-203914".to_string(),
                asset_owner_name: "Singapore Sovereign Wealth Fund".to_string(),
                asset_owner_lei: "SGSWF-LEI-001".to_string(),
                investment_manager_name: "Asian Trade Capital Management".to_string(),
                investment_manager_lei: "ATCM-LEI-001".to_string(),
                base_currency: "USD".to_string(),
                effective_date: "2024-01-01".to_string(),
                expiry_date: Some("2026-12-31".to_string()),
                gross_exposure_pct: Some(95.0),
                net_exposure_pct: Some(85.0),
                leverage_max: Some(1.5),
            },
            // European Growth Equity Strategy
            InvestmentMandate {
                mandate_id: "MND-2024-002".to_string(),
                cbu_id: "CBU-205816".to_string(),
                asset_owner_name: "Nordic Pension Consortium".to_string(),
                asset_owner_lei: "NORDIC-LEI-002".to_string(),
                investment_manager_name: "European Growth Partners".to_string(),
                investment_manager_lei: "EGP-LEI-002".to_string(),
                base_currency: "EUR".to_string(),
                effective_date: "2024-03-15".to_string(),
                expiry_date: Some("2027-03-14".to_string()),
                gross_exposure_pct: Some(90.0),
                net_exposure_pct: Some(80.0),
                leverage_max: Some(1.2),
            },
            // Infrastructure Investment Strategy
            InvestmentMandate {
                mandate_id: "MND-2024-003".to_string(),
                cbu_id: "CBU-207925".to_string(),
                asset_owner_name: "Australian Infrastructure Fund".to_string(),
                asset_owner_lei: "AIF-LEI-003".to_string(),
                investment_manager_name: "Pacific Asset Management".to_string(),
                investment_manager_lei: "PAM-LEI-003".to_string(),
                base_currency: "AUD".to_string(),
                effective_date: "2024-06-01".to_string(),
                expiry_date: None,
                gross_exposure_pct: Some(100.0),
                net_exposure_pct: Some(90.0),
                leverage_max: Some(2.0),
            },
            // US Technology Hedge Fund Strategy
            InvestmentMandate {
                mandate_id: "MND-2024-004".to_string(),
                cbu_id: "CBU-209847".to_string(),
                asset_owner_name: "Silicon Valley Family Office".to_string(),
                asset_owner_lei: "SVFO-LEI-004".to_string(),
                investment_manager_name: "TechVenture Capital Partners".to_string(),
                investment_manager_lei: "TVCP-LEI-004".to_string(),
                base_currency: "USD".to_string(),
                effective_date: "2024-02-01".to_string(),
                expiry_date: Some("2025-12-31".to_string()),
                gross_exposure_pct: Some(200.0),
                net_exposure_pct: Some(150.0),
                leverage_max: Some(3.0),
            },
            // Emerging Markets Fixed Income
            InvestmentMandate {
                mandate_id: "MND-2024-005".to_string(),
                cbu_id: "CBU-211563".to_string(),
                asset_owner_name: "Brazilian Development Bank".to_string(),
                asset_owner_lei: "BDB-LEI-005".to_string(),
                investment_manager_name: "Latam Bond Specialists".to_string(),
                investment_manager_lei: "LBS-LEI-005".to_string(),
                base_currency: "BRL".to_string(),
                effective_date: "2024-04-01".to_string(),
                expiry_date: Some("2029-03-31".to_string()),
                gross_exposure_pct: Some(85.0),
                net_exposure_pct: Some(75.0),
                leverage_max: Some(1.3),
            },
            // Swiss Private Bank Conservative Mandate
            InvestmentMandate {
                mandate_id: "MND-2024-006".to_string(),
                cbu_id: "CBU-213794".to_string(),
                asset_owner_name: "Zurich Family Trust".to_string(),
                asset_owner_lei: "ZFT-LEI-006".to_string(),
                investment_manager_name: "Alpine Wealth Management".to_string(),
                investment_manager_lei: "AWM-LEI-006".to_string(),
                base_currency: "CHF".to_string(),
                effective_date: "2024-01-15".to_string(),
                expiry_date: None,
                gross_exposure_pct: Some(80.0),
                net_exposure_pct: Some(70.0),
                leverage_max: Some(1.1),
            },
            // Japanese Pension Fund ESG Strategy
            InvestmentMandate {
                mandate_id: "MND-2024-007".to_string(),
                cbu_id: "CBU-215928".to_string(),
                asset_owner_name: "Tokyo Metropolitan Pension Fund".to_string(),
                asset_owner_lei: "TMPF-LEI-007".to_string(),
                investment_manager_name: "Nippon ESG Asset Management".to_string(),
                investment_manager_lei: "NEAM-LEI-007".to_string(),
                base_currency: "JPY".to_string(),
                effective_date: "2024-04-01".to_string(),
                expiry_date: Some("2030-03-31".to_string()),
                gross_exposure_pct: Some(95.0),
                net_exposure_pct: Some(85.0),
                leverage_max: Some(1.2),
            },
            // Middle East Sovereign Wealth Diversified
            InvestmentMandate {
                mandate_id: "MND-2024-008".to_string(),
                cbu_id: "CBU-217456".to_string(),
                asset_owner_name: "Qatar Investment Authority".to_string(),
                asset_owner_lei: "QIA-LEI-008".to_string(),
                investment_manager_name: "Gulf Capital Management".to_string(),
                investment_manager_lei: "GCM-LEI-008".to_string(),
                base_currency: "QAR".to_string(),
                effective_date: "2024-05-01".to_string(),
                expiry_date: Some("2027-04-30".to_string()),
                gross_exposure_pct: Some(120.0),
                net_exposure_pct: Some(100.0),
                leverage_max: Some(2.5),
            },
            // Canadian Real Estate Investment Trust
            InvestmentMandate {
                mandate_id: "MND-2024-009".to_string(),
                cbu_id: "CBU-219673".to_string(),
                asset_owner_name: "Canada Pension Plan Investment Board".to_string(),
                asset_owner_lei: "CPPIB-LEI-009".to_string(),
                investment_manager_name: "Maple Leaf Real Estate Partners".to_string(),
                investment_manager_lei: "MLREP-LEI-009".to_string(),
                base_currency: "CAD".to_string(),
                effective_date: "2024-03-01".to_string(),
                expiry_date: Some("2034-02-28".to_string()),
                gross_exposure_pct: Some(110.0),
                net_exposure_pct: Some(95.0),
                leverage_max: Some(1.8),
            },
            // UK Insurance Company Multi-Asset
            InvestmentMandate {
                mandate_id: "MND-2024-010".to_string(),
                cbu_id: "CBU-221847".to_string(),
                asset_owner_name: "London Life Insurance Company".to_string(),
                asset_owner_lei: "LLIC-LEI-010".to_string(),
                investment_manager_name: "Thames Asset Management".to_string(),
                investment_manager_lei: "TAM-LEI-010".to_string(),
                base_currency: "GBP".to_string(),
                effective_date: "2024-01-01".to_string(),
                expiry_date: Some("2026-12-31".to_string()),
                gross_exposure_pct: Some(85.0),
                net_exposure_pct: Some(75.0),
                leverage_max: Some(1.15),
            },
        ];

        // Mock Mandate Instruments with allocation constraints - Comprehensive Coverage
        self.mandate_instruments = vec![
            // MND-2024-001: Singapore SWF Conservative Government Bond Strategy
            MandateInstrument {
                id: 1,
                mandate_id: "MND-2024-001".to_string(),
                instrument_family: "Government Bonds".to_string(),
                subtype: Some("Treasury Bills".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(50.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(15.0),
                rating_floor: Some("AA".to_string()),
            },
            MandateInstrument {
                id: 2,
                mandate_id: "MND-2024-001".to_string(),
                instrument_family: "Corporate Bonds".to_string(),
                subtype: Some("Investment Grade".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(5.0),
                rating_floor: Some("BBB".to_string()),
            },
            MandateInstrument {
                id: 3,
                mandate_id: "MND-2024-001".to_string(),
                instrument_family: "Money Market".to_string(),
                subtype: Some("Commercial Paper".to_string()),
                cfi_code: Some("MMISSS".to_string()),
                exposure_pct: Some(20.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(10.0),
                rating_floor: Some("A".to_string()),
            },

            // MND-2024-002: Nordic Pension European Growth Equity Strategy
            MandateInstrument {
                id: 4,
                mandate_id: "MND-2024-002".to_string(),
                instrument_family: "Equities".to_string(),
                subtype: Some("Large Cap".to_string()),
                cfi_code: Some("ESVUFR".to_string()),
                exposure_pct: Some(60.0),
                short_allowed: Some(true),
                issuer_max_pct: Some(8.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 5,
                mandate_id: "MND-2024-002".to_string(),
                instrument_family: "Corporate Bonds".to_string(),
                subtype: Some("High Yield".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(25.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(3.0),
                rating_floor: Some("B".to_string()),
            },
            MandateInstrument {
                id: 6,
                mandate_id: "MND-2024-002".to_string(),
                instrument_family: "Derivatives".to_string(),
                subtype: Some("Currency Forwards".to_string()),
                cfi_code: Some("FFXXXX".to_string()),
                exposure_pct: Some(15.0),
                short_allowed: Some(true),
                issuer_max_pct: Some(20.0),
                rating_floor: None,
            },

            // MND-2024-003: Australian Infrastructure Investment Strategy
            MandateInstrument {
                id: 7,
                mandate_id: "MND-2024-003".to_string(),
                instrument_family: "Infrastructure Debt".to_string(),
                subtype: Some("Project Finance".to_string()),
                cfi_code: Some("DLTTFR".to_string()),
                exposure_pct: Some(70.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(12.0),
                rating_floor: Some("BBB".to_string()),
            },
            MandateInstrument {
                id: 8,
                mandate_id: "MND-2024-003".to_string(),
                instrument_family: "Real Estate".to_string(),
                subtype: Some("REITs".to_string()),
                cfi_code: Some("ESXXXX".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(15.0),
                rating_floor: None,
            },

            // MND-2024-004: Silicon Valley Tech Hedge Fund Strategy
            MandateInstrument {
                id: 9,
                mandate_id: "MND-2024-004".to_string(),
                instrument_family: "Equities".to_string(),
                subtype: Some("Technology Stocks".to_string()),
                cfi_code: Some("ESVUFR".to_string()),
                exposure_pct: Some(80.0),
                short_allowed: Some(true),
                issuer_max_pct: Some(10.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 10,
                mandate_id: "MND-2024-004".to_string(),
                instrument_family: "Derivatives".to_string(),
                subtype: Some("Equity Options".to_string()),
                cfi_code: Some("OPASPS".to_string()),
                exposure_pct: Some(50.0),
                short_allowed: Some(true),
                issuer_max_pct: Some(25.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 11,
                mandate_id: "MND-2024-004".to_string(),
                instrument_family: "Derivatives".to_string(),
                subtype: Some("Index Futures".to_string()),
                cfi_code: Some("FFIXXX".to_string()),
                exposure_pct: Some(70.0),
                short_allowed: Some(true),
                issuer_max_pct: Some(30.0),
                rating_floor: None,
            },

            // MND-2024-005: Brazilian EM Fixed Income Strategy
            MandateInstrument {
                id: 12,
                mandate_id: "MND-2024-005".to_string(),
                instrument_family: "Government Bonds".to_string(),
                subtype: Some("Emerging Market Sovereigns".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(60.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(20.0),
                rating_floor: Some("B".to_string()),
            },
            MandateInstrument {
                id: 13,
                mandate_id: "MND-2024-005".to_string(),
                instrument_family: "Corporate Bonds".to_string(),
                subtype: Some("EM Corporate".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(25.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(8.0),
                rating_floor: Some("BB".to_string()),
            },

            // MND-2024-006: Swiss Conservative Private Bank Mandate
            MandateInstrument {
                id: 14,
                mandate_id: "MND-2024-006".to_string(),
                instrument_family: "Government Bonds".to_string(),
                subtype: Some("Swiss Government Bonds".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(40.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(25.0),
                rating_floor: Some("AAA".to_string()),
            },
            MandateInstrument {
                id: 15,
                mandate_id: "MND-2024-006".to_string(),
                instrument_family: "Equities".to_string(),
                subtype: Some("Blue Chip Stocks".to_string()),
                cfi_code: Some("ESVUFR".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(5.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 16,
                mandate_id: "MND-2024-006".to_string(),
                instrument_family: "Money Market".to_string(),
                subtype: Some("Bank Deposits".to_string()),
                cfi_code: Some("MMISSS".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(15.0),
                rating_floor: Some("AA".to_string()),
            },

            // MND-2024-007: Japanese ESG Pension Strategy
            MandateInstrument {
                id: 17,
                mandate_id: "MND-2024-007".to_string(),
                instrument_family: "Equities".to_string(),
                subtype: Some("ESG Compliant Stocks".to_string()),
                cfi_code: Some("ESVUFR".to_string()),
                exposure_pct: Some(50.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(3.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 18,
                mandate_id: "MND-2024-007".to_string(),
                instrument_family: "Corporate Bonds".to_string(),
                subtype: Some("Green Bonds".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(35.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(5.0),
                rating_floor: Some("BBB".to_string()),
            },
            MandateInstrument {
                id: 19,
                mandate_id: "MND-2024-007".to_string(),
                instrument_family: "Real Estate".to_string(),
                subtype: Some("Sustainable REITs".to_string()),
                cfi_code: Some("ESXXXX".to_string()),
                exposure_pct: Some(15.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(8.0),
                rating_floor: None,
            },

            // MND-2024-008: Qatar Sovereign Wealth Diversified Strategy
            MandateInstrument {
                id: 20,
                mandate_id: "MND-2024-008".to_string(),
                instrument_family: "Equities".to_string(),
                subtype: Some("Global Large Cap".to_string()),
                cfi_code: Some("ESVUFR".to_string()),
                exposure_pct: Some(40.0),
                short_allowed: Some(true),
                issuer_max_pct: Some(5.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 21,
                mandate_id: "MND-2024-008".to_string(),
                instrument_family: "Alternative Investments".to_string(),
                subtype: Some("Private Equity".to_string()),
                cfi_code: Some("MFXXXX".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(15.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 22,
                mandate_id: "MND-2024-008".to_string(),
                instrument_family: "Commodities".to_string(),
                subtype: Some("Energy Futures".to_string()),
                cfi_code: Some("FCXXXX".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(true),
                issuer_max_pct: Some(20.0),
                rating_floor: None,
            },

            // MND-2024-009: Canadian REIT Strategy
            MandateInstrument {
                id: 23,
                mandate_id: "MND-2024-009".to_string(),
                instrument_family: "Real Estate".to_string(),
                subtype: Some("Canadian REITs".to_string()),
                cfi_code: Some("ESXXXX".to_string()),
                exposure_pct: Some(70.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(12.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 24,
                mandate_id: "MND-2024-009".to_string(),
                instrument_family: "Infrastructure Debt".to_string(),
                subtype: Some("Real Estate Mortgages".to_string()),
                cfi_code: Some("DLTTFR".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(8.0),
                rating_floor: Some("BBB".to_string()),
            },

            // MND-2024-010: UK Insurance Multi-Asset Strategy
            MandateInstrument {
                id: 25,
                mandate_id: "MND-2024-010".to_string(),
                instrument_family: "Government Bonds".to_string(),
                subtype: Some("UK Gilts".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(45.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(30.0),
                rating_floor: Some("AA".to_string()),
            },
            MandateInstrument {
                id: 26,
                mandate_id: "MND-2024-010".to_string(),
                instrument_family: "Equities".to_string(),
                subtype: Some("UK Large Cap".to_string()),
                cfi_code: Some("ESVUFR".to_string()),
                exposure_pct: Some(30.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(5.0),
                rating_floor: None,
            },
            MandateInstrument {
                id: 27,
                mandate_id: "MND-2024-010".to_string(),
                instrument_family: "Corporate Bonds".to_string(),
                subtype: Some("Insurance Linked Securities".to_string()),
                cfi_code: Some("DBFTFR".to_string()),
                exposure_pct: Some(25.0),
                short_allowed: Some(false),
                issuer_max_pct: Some(8.0),
                rating_floor: Some("BBB".to_string()),
            },
        ];

        // Mock Instruction Formats for trading systems
        self.instruction_formats = vec![
            InstructionFormat {
                id: 1,
                format_id: "FIX-4.4".to_string(),
                format_name: "FIX Protocol 4.4".to_string(),
                format_category: Some("Trading".to_string()),
                message_standard: Some("FIX".to_string()),
                message_type: Some("NewOrderSingle".to_string()),
                status: "active".to_string(),
            },
            InstructionFormat {
                id: 2,
                format_id: "SWIFT-MT544".to_string(),
                format_name: "SWIFT MT544 Settlement Instruction".to_string(),
                format_category: Some("Settlement".to_string()),
                message_standard: Some("SWIFT".to_string()),
                message_type: Some("ReceiveAgainstPayment".to_string()),
                status: "active".to_string(),
            },
            InstructionFormat {
                id: 3,
                format_id: "ISO20022-SETR".to_string(),
                format_name: "ISO 20022 Securities Trade".to_string(),
                format_category: Some("Trade Reporting".to_string()),
                message_standard: Some("ISO20022".to_string()),
                message_type: Some("SubscriptionOrder".to_string()),
                status: "active".to_string(),
            },
            InstructionFormat {
                id: 4,
                format_id: "JSON-REST".to_string(),
                format_name: "JSON REST API".to_string(),
                format_category: Some("API".to_string()),
                message_standard: Some("JSON".to_string()),
                message_type: Some("OrderRequest".to_string()),
                status: "active".to_string(),
            },
            InstructionFormat {
                id: 5,
                format_id: "CSV-BULK".to_string(),
                format_name: "CSV Bulk Upload".to_string(),
                format_category: Some("Batch".to_string()),
                message_standard: Some("CSV".to_string()),
                message_type: Some("BulkInstructions".to_string()),
                status: "active".to_string(),
            },
        ];

        // Enhanced CBU mandate structure with mock data
        self.cbu_mandate_structure = vec![
            // Original 3 CBUs plus expanded global coverage
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-203914".to_string(),
                cbu_name: "Global Trade Finance Consortium".to_string(),
                mandate_id: Some("MND-2024-001".to_string()),
                asset_owner_name: Some("Singapore Sovereign Wealth Fund".to_string()),
                investment_manager_name: Some("Asian Trade Capital Management".to_string()),
                base_currency: Some("USD".to_string()),
                total_instruments: Some(3),
                families: Some("Government Bonds, Corporate Bonds, Money Market".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("100.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-205816".to_string(),
                cbu_name: "European Growth Capital".to_string(),
                mandate_id: Some("MND-2024-002".to_string()),
                asset_owner_name: Some("Nordic Pension Consortium".to_string()),
                investment_manager_name: Some("European Growth Partners".to_string()),
                base_currency: Some("EUR".to_string()),
                total_instruments: Some(3),
                families: Some("Equities, Corporate Bonds, Derivatives".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("100.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-207925".to_string(),
                cbu_name: "Pacific Infrastructure Partners".to_string(),
                mandate_id: Some("MND-2024-003".to_string()),
                asset_owner_name: Some("Australian Infrastructure Fund".to_string()),
                investment_manager_name: Some("Pacific Asset Management".to_string()),
                base_currency: Some("AUD".to_string()),
                total_instruments: Some(2),
                families: Some("Infrastructure Debt, Real Estate".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("100.0").unwrap()),
            },
            // New CBU structures for expanded mandates
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-209847".to_string(),
                cbu_name: "Silicon Valley Innovation Fund".to_string(),
                mandate_id: Some("MND-2024-004".to_string()),
                asset_owner_name: Some("Silicon Valley Family Office".to_string()),
                investment_manager_name: Some("TechVenture Capital Partners".to_string()),
                base_currency: Some("USD".to_string()),
                total_instruments: Some(3),
                families: Some("Technology Equities, Equity Options, Index Futures".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("200.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-211563".to_string(),
                cbu_name: "Latin America Fixed Income".to_string(),
                mandate_id: Some("MND-2024-005".to_string()),
                asset_owner_name: Some("Brazilian Development Bank".to_string()),
                investment_manager_name: Some("Latam Bond Specialists".to_string()),
                base_currency: Some("BRL".to_string()),
                total_instruments: Some(2),
                families: Some("EM Government Bonds, EM Corporate Bonds".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("85.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-213794".to_string(),
                cbu_name: "Swiss Private Banking".to_string(),
                mandate_id: Some("MND-2024-006".to_string()),
                asset_owner_name: Some("Zurich Family Trust".to_string()),
                investment_manager_name: Some("Alpine Wealth Management".to_string()),
                base_currency: Some("CHF".to_string()),
                total_instruments: Some(3),
                families: Some("Swiss Government Bonds, Blue Chip Equities, Bank Deposits".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("80.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-215928".to_string(),
                cbu_name: "Japan ESG Investment Platform".to_string(),
                mandate_id: Some("MND-2024-007".to_string()),
                asset_owner_name: Some("Tokyo Metropolitan Pension Fund".to_string()),
                investment_manager_name: Some("Nippon ESG Asset Management".to_string()),
                base_currency: Some("JPY".to_string()),
                total_instruments: Some(3),
                families: Some("ESG Equities, Green Bonds, Sustainable REITs".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("95.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-217456".to_string(),
                cbu_name: "Middle East Sovereign Diversified".to_string(),
                mandate_id: Some("MND-2024-008".to_string()),
                asset_owner_name: Some("Qatar Investment Authority".to_string()),
                investment_manager_name: Some("Gulf Capital Management".to_string()),
                base_currency: Some("QAR".to_string()),
                total_instruments: Some(3),
                families: Some("Global Equities, Private Equity, Energy Commodities".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("120.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-219673".to_string(),
                cbu_name: "Canadian Real Estate Platform".to_string(),
                mandate_id: Some("MND-2024-009".to_string()),
                asset_owner_name: Some("Canada Pension Plan Investment Board".to_string()),
                investment_manager_name: Some("Maple Leaf Real Estate Partners".to_string()),
                base_currency: Some("CAD".to_string()),
                total_instruments: Some(2),
                families: Some("Canadian REITs, Real Estate Mortgages".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("110.0").unwrap()),
            },
            CbuInvestmentMandateStructure {
                cbu_id: "CBU-221847".to_string(),
                cbu_name: "UK Insurance Multi-Asset".to_string(),
                mandate_id: Some("MND-2024-010".to_string()),
                asset_owner_name: Some("London Life Insurance Company".to_string()),
                investment_manager_name: Some("Thames Asset Management".to_string()),
                base_currency: Some("GBP".to_string()),
                total_instruments: Some(3),
                families: Some("UK Gilts, UK Large Cap Equities, Insurance Linked Securities".to_string()),
                total_exposure_pct: Some(rust_decimal::Decimal::from_str("85.0").unwrap()),
            },
        ];

        // Enhanced CBU member roles with realistic authorities
        self.cbu_member_roles = vec![
            CbuMemberInvestmentRole {
                cbu_id: "CBU-203914".to_string(),
                cbu_name: "Global Trade Finance Consortium".to_string(),
                entity_name: "Singapore Sovereign Wealth Fund".to_string(),
                entity_lei: Some("SGSWF-LEI-001".to_string()),
                role_name: "Asset Owner / SPV".to_string(),
                role_code: "AO".to_string(),
                investment_responsibility: "Mandate Definition & Risk Oversight".to_string(),
                mandate_id: Some("MND-2024-001".to_string()),
                has_trading_authority: Some(false),
                has_settlement_authority: Some(false),
            },
            CbuMemberInvestmentRole {
                cbu_id: "CBU-203914".to_string(),
                cbu_name: "Global Trade Finance Consortium".to_string(),
                entity_name: "Asian Trade Capital Management".to_string(),
                entity_lei: Some("ATCM-LEI-001".to_string()),
                role_name: "Investment Manager".to_string(),
                role_code: "IM".to_string(),
                investment_responsibility: "Portfolio Management & Trade Execution".to_string(),
                mandate_id: Some("MND-2024-001".to_string()),
                has_trading_authority: Some(true),
                has_settlement_authority: Some(true),
            },
            CbuMemberInvestmentRole {
                cbu_id: "CBU-205816".to_string(),
                cbu_name: "European Growth Capital".to_string(),
                entity_name: "Nordic Pension Consortium".to_string(),
                entity_lei: Some("NORDIC-LEI-002".to_string()),
                role_name: "Asset Owner / SPV".to_string(),
                role_code: "AO".to_string(),
                investment_responsibility: "Strategic Asset Allocation".to_string(),
                mandate_id: Some("MND-2024-002".to_string()),
                has_trading_authority: Some(false),
                has_settlement_authority: Some(false),
            },
            CbuMemberInvestmentRole {
                cbu_id: "CBU-205816".to_string(),
                cbu_name: "European Growth Capital".to_string(),
                entity_name: "European Growth Partners".to_string(),
                entity_lei: Some("EGP-LEI-002".to_string()),
                role_name: "Investment Manager".to_string(),
                role_code: "IM".to_string(),
                investment_responsibility: "Active Portfolio Management & Risk Control".to_string(),
                mandate_id: Some("MND-2024-002".to_string()),
                has_trading_authority: Some(true),
                has_settlement_authority: Some(true),
            },
            CbuMemberInvestmentRole {
                cbu_id: "CBU-207925".to_string(),
                cbu_name: "Pacific Infrastructure Partners".to_string(),
                entity_name: "Australian Infrastructure Fund".to_string(),
                entity_lei: Some("AIF-LEI-003".to_string()),
                role_name: "Asset Owner / SPV".to_string(),
                role_code: "AO".to_string(),
                investment_responsibility: "Long-term Infrastructure Strategy".to_string(),
                mandate_id: Some("MND-2024-003".to_string()),
                has_trading_authority: Some(false),
                has_settlement_authority: Some(false),
            },
            CbuMemberInvestmentRole {
                cbu_id: "CBU-207925".to_string(),
                cbu_name: "Pacific Infrastructure Partners".to_string(),
                entity_name: "Pacific Asset Management".to_string(),
                entity_lei: Some("PAM-LEI-003".to_string()),
                role_name: "Investment Manager".to_string(),
                role_code: "IM".to_string(),
                investment_responsibility: "Infrastructure Investment & Asset Management".to_string(),
                mandate_id: Some("MND-2024-003".to_string()),
                has_trading_authority: Some(true),
                has_settlement_authority: Some(true),
            },
        ];

        self.status_message = format!("Loaded mock investment mandates: {} mandates, {} instruments, {} formats",
            self.investment_mandates.len(),
            self.mandate_instruments.len(),
            self.instruction_formats.len()
        );
    }

    // Load comprehensive mock onboarding requests using existing CBU IDs and Product IDs
    fn load_mock_onboarding_requests(&mut self) {
        // Create comprehensive onboarding requests with CBU + Product bundle combinations
        self.onboarding_requests = vec![
            // CBU-203914 (Singapore SWF) requests Institutional Custody Plus + Trade Settlement
            OnboardingRequest {
                id: 1,
                onboarding_request_id: "ORQ-2024-001".to_string(),
                cbu_id: "CBU-203914".to_string(),
                cbu_name: "Global Trade Finance Consortium".to_string(),
                product_bundle: vec![], // Will be populated in onboarding_product_items
                request_date: "2024-01-15".to_string(),
                requested_by: "Singapore Sovereign Wealth Fund".to_string(),
                status: "approved".to_string(),
                priority: "high".to_string(),
                expected_go_live_date: Some("2024-03-01".to_string()),
                estimated_setup_time_days: Some(45),
                approval_workflow_stage: "implementation".to_string(),
                assigned_relationship_manager: Some("Sarah Chen - APAC Director".to_string()),
                estimated_annual_revenue: Some(2500000.0),
                complexity_score: Some(7),
                notes: Some("Government client with strict regulatory requirements. Priority implementation for Q1 2024.".to_string()),
            },

            // CBU-205816 (Nordic Pension) requests Fund Administration Complete
            OnboardingRequest {
                id: 2,
                onboarding_request_id: "ORQ-2024-002".to_string(),
                cbu_id: "CBU-205816".to_string(),
                cbu_name: "European Growth Capital".to_string(),
                product_bundle: vec![],
                request_date: "2024-02-01".to_string(),
                requested_by: "Nordic Pension Consortium".to_string(),
                status: "in_progress".to_string(),
                priority: "normal".to_string(),
                expected_go_live_date: Some("2024-04-15".to_string()),
                estimated_setup_time_days: Some(60),
                approval_workflow_stage: "review".to_string(),
                assigned_relationship_manager: Some("Lars Andersen - EMEA Head".to_string()),
                estimated_annual_revenue: Some(1800000.0),
                complexity_score: Some(6),
                notes: Some("Multi-jurisdiction pension fund requiring enhanced reporting capabilities.".to_string()),
            },

            // CBU-209847 (Silicon Valley) requests Trade Settlement Professional + Custom Options
            OnboardingRequest {
                id: 3,
                onboarding_request_id: "ORQ-2024-003".to_string(),
                cbu_id: "CBU-209847".to_string(),
                cbu_name: "Silicon Valley Innovation Fund".to_string(),
                product_bundle: vec![],
                request_date: "2024-02-10".to_string(),
                requested_by: "TechVenture Capital Partners".to_string(),
                status: "pending".to_string(),
                priority: "urgent".to_string(),
                expected_go_live_date: Some("2024-03-15".to_string()),
                estimated_setup_time_days: Some(35),
                approval_workflow_stage: "approval".to_string(),
                assigned_relationship_manager: Some("Michael Rodriguez - Americas Tech".to_string()),
                estimated_annual_revenue: Some(3200000.0),
                complexity_score: Some(9),
                notes: Some("High-frequency trading requirements with derivative instruments. Real-time settlement needed.".to_string()),
            },

            // CBU-213794 (Swiss Private Bank) requests Multiple Products
            OnboardingRequest {
                id: 4,
                onboarding_request_id: "ORQ-2024-004".to_string(),
                cbu_id: "CBU-213794".to_string(),
                cbu_name: "Swiss Private Banking".to_string(),
                product_bundle: vec![],
                request_date: "2024-01-28".to_string(),
                requested_by: "Alpine Wealth Management".to_string(),
                status: "approved".to_string(),
                priority: "high".to_string(),
                expected_go_live_date: Some("2024-04-01".to_string()),
                estimated_setup_time_days: Some(55),
                approval_workflow_stage: "implementation".to_string(),
                assigned_relationship_manager: Some("Klaus Weber - EMEA Private Client".to_string()),
                estimated_annual_revenue: Some(4100000.0),
                complexity_score: Some(8),
                notes: Some("Premium private banking client requiring white-glove service and custom reporting.".to_string()),
            },

            // CBU-215928 (Japanese Pension) requests ESG-compliant products
            OnboardingRequest {
                id: 5,
                onboarding_request_id: "ORQ-2024-005".to_string(),
                cbu_id: "CBU-215928".to_string(),
                cbu_name: "Japan ESG Investment Platform".to_string(),
                product_bundle: vec![],
                request_date: "2024-02-05".to_string(),
                requested_by: "Tokyo Metropolitan Pension Fund".to_string(),
                status: "in_progress".to_string(),
                priority: "normal".to_string(),
                expected_go_live_date: Some("2024-05-01".to_string()),
                estimated_setup_time_days: Some(70),
                approval_workflow_stage: "review".to_string(),
                assigned_relationship_manager: Some("Yuki Tanaka - APAC Institutional".to_string()),
                estimated_annual_revenue: Some(1900000.0),
                complexity_score: Some(5),
                notes: Some("ESG compliance reporting required. Green bond settlement capabilities essential.".to_string()),
            },
        ];

        // Create detailed product items for each onboarding request
        self.onboarding_product_items = vec![
            // ORQ-2024-001: Singapore SWF - Institutional Custody Plus + Trade Settlement
            OnboardingProductItem {
                id: 1,
                onboarding_request_id: "ORQ-2024-001".to_string(),
                product_id: 1, // Institutional Custody Plus
                product_name: "Institutional Custody Plus".to_string(),
                selected_options: vec![], // Will be populated in onboarding_product_options
                estimated_volume: Some("$2.5B AUM, 500 trades/day".to_string()),
                go_live_priority: "phase1".to_string(),
                special_requirements: Some("Segregated accounts for government assets".to_string()),
            },
            OnboardingProductItem {
                id: 2,
                onboarding_request_id: "ORQ-2024-001".to_string(),
                product_id: 3, // Trade Settlement Professional
                product_name: "Trade Settlement Professional".to_string(),
                selected_options: vec![],
                estimated_volume: Some("DvP settlement, T+2 Asia markets".to_string()),
                go_live_priority: "phase1".to_string(),
                special_requirements: Some("Multi-currency settlement in USD, SGD, HKD".to_string()),
            },

            // ORQ-2024-002: Nordic Pension - Fund Administration Complete
            OnboardingProductItem {
                id: 3,
                onboarding_request_id: "ORQ-2024-002".to_string(),
                product_id: 2, // Fund Administration Complete
                product_name: "Fund Administration Complete".to_string(),
                selected_options: vec![],
                estimated_volume: Some("‚Ç¨1.8B fund complex, 50 sub-funds".to_string()),
                go_live_priority: "phase1".to_string(),
                special_requirements: Some("UCITS compliance and daily NAV calculation".to_string()),
            },

            // ORQ-2024-003: Silicon Valley - Trade Settlement Professional + Custom
            OnboardingProductItem {
                id: 4,
                onboarding_request_id: "ORQ-2024-003".to_string(),
                product_id: 3, // Trade Settlement Professional
                product_name: "Trade Settlement Professional".to_string(),
                selected_options: vec![],
                estimated_volume: Some("$5B notional, 2000+ derivatives/day".to_string()),
                go_live_priority: "phase1".to_string(),
                special_requirements: Some("Real-time settlement for equity options and futures".to_string()),
            },

            // ORQ-2024-004: Swiss Private Bank - Multiple Products
            OnboardingProductItem {
                id: 5,
                onboarding_request_id: "ORQ-2024-004".to_string(),
                product_id: 1, // Institutional Custody Plus
                product_name: "Institutional Custody Plus".to_string(),
                selected_options: vec![],
                estimated_volume: Some("CHF 3.2B private client assets".to_string()),
                go_live_priority: "phase1".to_string(),
                special_requirements: Some("Discretionary portfolio management integration".to_string()),
            },
            OnboardingProductItem {
                id: 6,
                onboarding_request_id: "ORQ-2024-004".to_string(),
                product_id: 2, // Fund Administration Complete
                product_name: "Fund Administration Complete".to_string(),
                selected_options: vec![],
                estimated_volume: Some("15 private funds, custom reporting".to_string()),
                go_live_priority: "phase2".to_string(),
                special_requirements: Some("Swiss regulatory reporting and tax optimization".to_string()),
            },

            // ORQ-2024-005: Japanese Pension - ESG Products
            OnboardingProductItem {
                id: 7,
                onboarding_request_id: "ORQ-2024-005".to_string(),
                product_id: 1, // Institutional Custody Plus
                product_name: "Institutional Custody Plus".to_string(),
                selected_options: vec![],
                estimated_volume: Some("¬•280B ESG-compliant assets".to_string()),
                go_live_priority: "phase1".to_string(),
                special_requirements: Some("ESG scoring integration and green bond identification".to_string()),
            },
        ];

        // Create specific product option selections for each product item
        self.onboarding_product_options = vec![
            // ORQ-2024-001 Product 1 Options
            OnboardingProductOption {
                id: 1,
                onboarding_product_item_id: 1,
                option_id: "OPT-001".to_string(),
                option_name: "Multi-Currency Settlement".to_string(),
                option_value: serde_json::json!(["USD", "SGD", "HKD", "JPY"]),
                custom_configuration: Some("Priority: USD primary, SGD secondary".to_string()),
            },
            OnboardingProductOption {
                id: 2,
                onboarding_product_item_id: 1,
                option_id: "OPT-002".to_string(),
                option_name: "Enhanced Regulatory Reporting".to_string(),
                option_value: serde_json::json!(true),
                custom_configuration: Some("MAS compliance required".to_string()),
            },

            // ORQ-2024-002 Product 1 Options
            OnboardingProductOption {
                id: 3,
                onboarding_product_item_id: 3,
                option_id: "OPT-003".to_string(),
                option_name: "UCITS Administration".to_string(),
                option_value: serde_json::json!(true),
                custom_configuration: Some("Luxembourg domiciled funds".to_string()),
            },
            OnboardingProductOption {
                id: 4,
                onboarding_product_item_id: 3,
                option_id: "OPT-004".to_string(),
                option_name: "Daily NAV Calculation".to_string(),
                option_value: serde_json::json!("15:00 CET"),
                custom_configuration: Some("T+1 publication requirement".to_string()),
            },

            // ORQ-2024-003 High-frequency Options
            OnboardingProductOption {
                id: 5,
                onboarding_product_item_id: 4,
                option_id: "OPT-005".to_string(),
                option_name: "Real-time Settlement".to_string(),
                option_value: serde_json::json!(true),
                custom_configuration: Some("Sub-second processing required".to_string()),
            },
            OnboardingProductOption {
                id: 6,
                onboarding_product_item_id: 4,
                option_id: "OPT-006".to_string(),
                option_name: "Derivatives Support".to_string(),
                option_value: serde_json::json!(["equity_options", "index_futures", "currency_forwards"]),
                custom_configuration: Some("ISDA master agreements in place".to_string()),
            },

            // ORQ-2024-004 Swiss Private Banking Options
            OnboardingProductOption {
                id: 7,
                onboarding_product_item_id: 5,
                option_id: "OPT-007".to_string(),
                option_name: "Discretionary Management".to_string(),
                option_value: serde_json::json!(true),
                custom_configuration: Some("Model portfolio allocation integration".to_string()),
            },
            OnboardingProductOption {
                id: 8,
                onboarding_product_item_id: 6,
                option_id: "OPT-008".to_string(),
                option_name: "Swiss Tax Reporting".to_string(),
                option_value: serde_json::json!(true),
                custom_configuration: Some("Automatic withholding tax reclaim".to_string()),
            },

            // ORQ-2024-005 ESG Options
            OnboardingProductOption {
                id: 9,
                onboarding_product_item_id: 7,
                option_id: "OPT-009".to_string(),
                option_name: "ESG Screening".to_string(),
                option_value: serde_json::json!(true),
                custom_configuration: Some("MSCI ESG ratings integration".to_string()),
            },
            OnboardingProductOption {
                id: 10,
                onboarding_product_item_id: 7,
                option_id: "OPT-010".to_string(),
                option_name: "Green Bond Identification".to_string(),
                option_value: serde_json::json!(true),
                custom_configuration: Some("Climate Bonds Standard verification".to_string()),
            },
        ];

        self.status_message = format!("Loaded mock onboarding requests: {} requests, {} product items, {} options",
            self.onboarding_requests.len(),
            self.onboarding_product_items.len(),
            self.onboarding_product_options.len()
        );
    }

    // Database Population Functions
    fn populate_database_with_taxonomy(&mut self) {
        if let Some(ref pool) = self.db_pool {
            let pool = pool.clone();
            let rt = self.runtime.clone();

            // Load mock data first to have it available
            self.load_mock_product_taxonomy();
            self.load_mock_investment_mandates();
            self.load_mock_onboarding_requests();

            self.status_message = "Populating database with product taxonomy...".to_string();

            // Start with products
            let products = self.products.clone();
            match rt.block_on(async {
                for product in &products {
                    sqlx::query(
                        r#"INSERT INTO products (product_id, product_name, line_of_business, description, status, contract_type, commercial_status, pricing_model, target_market)
                           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                           ON CONFLICT (product_id) DO UPDATE SET
                           product_name = EXCLUDED.product_name,
                           description = EXCLUDED.description,
                           status = EXCLUDED.status"#)
                    .bind(&product.product_id)
                    .bind(&product.product_name)
                    .bind(&product.line_of_business)
                    .bind(&product.description)
                    .bind(&product.status)
                    .bind(&product.contract_type)
                    .bind(&product.commercial_status)
                    .bind(&product.pricing_model)
                    .bind(&product.target_market)
                    .execute(&pool)
                    .await?;
                }
                Ok::<(), sqlx::Error>(())
            }) {
                Ok(_) => {
                    self.status_message = format!("‚úÖ Inserted {} products", products.len());
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Error inserting products: {}", e);
                    return;
                }
            }

            // Insert product options
            let product_options = self.product_options.clone();
            match rt.block_on(async {
                for option in &product_options {
                    sqlx::query(
                        r#"INSERT INTO product_options (option_id, product_id, option_name, option_category, option_type, option_value, display_name, description, pricing_impact, status)
                           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                           ON CONFLICT (option_id) DO UPDATE SET
                           option_name = EXCLUDED.option_name,
                           description = EXCLUDED.description,
                           status = EXCLUDED.status"#)
                    .bind(&option.option_id)
                    .bind(&option.product_id)
                    .bind(&option.option_name)
                    .bind(&option.option_category)
                    .bind(&option.option_type)
                    .bind(&option.option_value)
                    .bind(&option.display_name)
                    .bind(&option.description)
                    .bind(&option.pricing_impact)
                    .bind(&option.status)
                    .execute(&pool)
                    .await?;
                }
                Ok::<(), sqlx::Error>(())
            }) {
                Ok(_) => {
                    self.status_message = format!("‚úÖ Inserted {} product options", product_options.len());
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Error inserting product options: {}", e);
                    return;
                }
            }

            // Insert services
            let services = self.services.clone();
            match rt.block_on(async {
                for service in &services {
                    sqlx::query(
                        r#"INSERT INTO services (service_id, service_name, service_category, description, service_type, delivery_model, billable, status)
                           VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                           ON CONFLICT (service_id) DO UPDATE SET
                           service_name = EXCLUDED.service_name,
                           description = EXCLUDED.description,
                           status = EXCLUDED.status"#)
                    .bind(&service.service_id)
                    .bind(&service.service_name)
                    .bind(&service.service_category)
                    .bind(&service.description)
                    .bind(&service.service_type)
                    .bind(&service.delivery_model)
                    .bind(&service.billable)
                    .bind(&service.status)
                    .execute(&pool)
                    .await?;
                }
                Ok::<(), sqlx::Error>(())
            }) {
                Ok(_) => {
                    self.status_message = format!("‚úÖ Inserted {} services", services.len());
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Error inserting services: {}", e);
                    return;
                }
            }

            // Insert resources
            let resources = self.resources.clone();
            match rt.block_on(async {
                for resource in &resources {
                    sqlx::query(
                        r#"INSERT INTO resource_objects (resource_name, description, version, category, resource_type, criticality_level, operational_status, owner_team, status)
                           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                           ON CONFLICT (resource_name) DO UPDATE SET
                           description = EXCLUDED.description,
                           version = EXCLUDED.version,
                           status = EXCLUDED.status"#)
                    .bind(&resource.resource_name)
                    .bind(&resource.description)
                    .bind(&resource.version)
                    .bind(&resource.category)
                    .bind(&resource.resource_type)
                    .bind(&resource.criticality_level)
                    .bind(&resource.operational_status)
                    .bind(&resource.owner_team)
                    .bind(&resource.status)
                    .execute(&pool)
                    .await?;
                }
                Ok::<(), sqlx::Error>(())
            }) {
                Ok(_) => {
                    self.status_message = format!("‚úÖ Inserted {} resources", resources.len());
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Error inserting resources: {}", e);
                    return;
                }
            }

            // Insert investment mandates
            let mandates = self.investment_mandates.clone();
            match rt.block_on(async {
                for mandate in &mandates {
                    sqlx::query(
                        r#"INSERT INTO investment_mandates (mandate_id, cbu_id, asset_owner_name, asset_owner_lei, investment_manager_name, investment_manager_lei, base_currency, effective_date, expiry_date, gross_exposure_pct, net_exposure_pct, leverage_max)
                           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
                           ON CONFLICT (mandate_id) DO UPDATE SET
                           asset_owner_name = EXCLUDED.asset_owner_name,
                           investment_manager_name = EXCLUDED.investment_manager_name,
                           base_currency = EXCLUDED.base_currency"#)
                    .bind(&mandate.mandate_id)
                    .bind(&mandate.cbu_id)
                    .bind(&mandate.asset_owner_name)
                    .bind(&mandate.asset_owner_lei)
                    .bind(&mandate.investment_manager_name)
                    .bind(&mandate.investment_manager_lei)
                    .bind(&mandate.base_currency)
                    .bind(&mandate.effective_date)
                    .bind(&mandate.expiry_date)
                    .bind(&mandate.gross_exposure_pct)
                    .bind(&mandate.net_exposure_pct)
                    .bind(&mandate.leverage_max)
                    .execute(&pool)
                    .await?;
                }
                Ok::<(), sqlx::Error>(())
            }) {
                Ok(_) => {
                    self.status_message = format!("‚úÖ Inserted {} investment mandates", mandates.len());
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Error inserting investment mandates: {}", e);
                    return;
                }
            }

            // Insert mandate instruments
            let instruments = self.mandate_instruments.clone();
            match rt.block_on(async {
                for instrument in &instruments {
                    sqlx::query(
                        r#"INSERT INTO mandate_instruments (mandate_id, instrument_family, subtype, cfi_code, exposure_pct, short_allowed, issuer_max_pct, rating_floor)
                           VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                           ON CONFLICT (mandate_id, instrument_family) DO UPDATE SET
                           exposure_pct = EXCLUDED.exposure_pct,
                           short_allowed = EXCLUDED.short_allowed,
                           issuer_max_pct = EXCLUDED.issuer_max_pct"#)
                    .bind(&instrument.mandate_id)
                    .bind(&instrument.instrument_family)
                    .bind(&instrument.subtype)
                    .bind(&instrument.cfi_code)
                    .bind(&instrument.exposure_pct)
                    .bind(&instrument.short_allowed)
                    .bind(&instrument.issuer_max_pct)
                    .bind(&instrument.rating_floor)
                    .execute(&pool)
                    .await?;
                }
                Ok::<(), sqlx::Error>(())
            }) {
                Ok(_) => {
                    self.status_message = format!("‚úÖ Inserted {} mandate instruments", instruments.len());
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Error inserting mandate instruments: {}", e);
                    return;
                }
            }

            // Insert instruction formats
            let formats = self.instruction_formats.clone();
            match rt.block_on(async {
                for format in &formats {
                    sqlx::query(
                        r#"INSERT INTO instruction_formats (format_id, format_name, format_category, message_standard, message_type, status)
                           VALUES ($1, $2, $3, $4, $5, $6)
                           ON CONFLICT (format_id) DO UPDATE SET
                           format_name = EXCLUDED.format_name,
                           format_category = EXCLUDED.format_category,
                           status = EXCLUDED.status"#)
                    .bind(&format.format_id)
                    .bind(&format.format_name)
                    .bind(&format.format_category)
                    .bind(&format.message_standard)
                    .bind(&format.message_type)
                    .bind(&format.status)
                    .execute(&pool)
                    .await?;
                }
                Ok::<(), sqlx::Error>(())
            }) {
                Ok(_) => {
                    // Insert onboarding requests
                    let requests = self.onboarding_requests.clone();
                    let request_result = rt.block_on(async {
                        for request in &requests {
                            sqlx::query(
                                r#"INSERT INTO onboarding_requests (onboarding_request_id, cbu_id, cbu_name, request_date, requested_by, status, priority, expected_go_live_date, estimated_setup_time_days, approval_workflow_stage, assigned_relationship_manager, estimated_annual_revenue, complexity_score, notes)
                                   VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                                   ON CONFLICT (onboarding_request_id) DO UPDATE SET
                                   status = EXCLUDED.status,
                                   approval_workflow_stage = EXCLUDED.approval_workflow_stage,
                                   assigned_relationship_manager = EXCLUDED.assigned_relationship_manager"#)
                            .bind(&request.onboarding_request_id)
                            .bind(&request.cbu_id)
                            .bind(&request.cbu_name)
                            .bind(&request.request_date)
                            .bind(&request.requested_by)
                            .bind(&request.status)
                            .bind(&request.priority)
                            .bind(&request.expected_go_live_date)
                            .bind(&request.estimated_setup_time_days)
                            .bind(&request.approval_workflow_stage)
                            .bind(&request.assigned_relationship_manager)
                            .bind(&request.estimated_annual_revenue)
                            .bind(&request.complexity_score)
                            .bind(&request.notes)
                            .execute(&pool)
                            .await?;
                        }
                        Ok::<(), sqlx::Error>(())
                    });

                    match request_result {
                        Ok(_) => {
                            self.status_message = format!("üéâ Database population complete! Total: {} products, {} services, {} resources, {} mandates, {} onboarding requests",
                                self.products.len(),
                                self.services.len(),
                                self.resources.len(),
                                self.investment_mandates.len(),
                                self.onboarding_requests.len()
                            );
                        }
                        Err(e) => {
                            self.status_message = format!("‚ùå Error inserting onboarding requests: {}", e);
                        }
                    }
                }
                Err(e) => {
                    self.status_message = format!("‚ùå Error inserting instruction formats: {}", e);
                }
            }
        } else {
            self.status_message = "‚ùå No database connection available".to_string();
        }
    }

    fn load_taxonomy_hierarchy(&mut self) {
        // For now, create a sample hierarchy
        self.taxonomy_hierarchy = vec![
            TaxonomyHierarchyItem {
                level: 1,
                item_type: "product".to_string(),
                item_id: 1,
                item_name: "Institutional Custody Plus".to_string(),
                item_description: Some("Comprehensive custody services".to_string()),
                parent_id: None,
                configuration: None,
                metadata: None,
            },
            TaxonomyHierarchyItem {
                level: 2,
                item_type: "product_option".to_string(),
                item_id: 2,
                item_name: "US Market Settlement".to_string(),
                item_description: Some("Settlement in US markets".to_string()),
                parent_id: Some(1),
                configuration: None,
                metadata: None,
            },
        ];
        self.status_message = "Loaded sample taxonomy hierarchy".to_string();
    }

    // CBU Tree Management Functions
    fn build_cbu_tree(&mut self) {
        if self.cbus.is_empty() {
            self.cbu_tree = None;
            return;
        }

        // For now, since we don't have parent_id in the structure, create a simple hierarchical mock
        // In a real implementation, you'd have parent_id fields and proper hierarchy
        let mock_tree = self.create_mock_cbu_hierarchy();
        self.cbu_tree = Some(mock_tree);
    }

    fn create_mock_cbu_hierarchy(&self) -> CbuTreeNode {
        use chrono::{DateTime, Utc};

        // Create a mock root CBU if none exists
        let root_cbu = if self.cbus.is_empty() {
            ClientBusinessUnit {
                id: 0,
                cbu_id: "ROOT-001".to_string(),
                cbu_name: "Global Financial Services Group".to_string(),
                description: Some("Root holding company for all financial services".to_string()),
                primary_entity_id: Some("GLOBAL-LEI-001".to_string()),
                primary_lei: Some("254900OPPU84GM83MG36".to_string()),
                domicile_country: Some("US".to_string()),
                regulatory_jurisdiction: Some("Federal Reserve".to_string()),
                business_type: Some("Financial Holding Company".to_string()),
                status: "active".to_string(),
                created_date: None,
                last_review_date: None,
                next_review_date: None,
                created_by: Some("system".to_string()),
                created_at: DateTime::<Utc>::from_timestamp(1609459200, 0).unwrap_or_else(Utc::now),
                updated_by: Some("system".to_string()),
                updated_at: DateTime::<Utc>::from_timestamp(1609459200, 0).unwrap_or_else(Utc::now),
                metadata: None,
            }
        } else {
            self.cbus[0].clone()
        };

        // Create child CBUs with mock hierarchy
        let mut children = Vec::new();

        // Add regional divisions as children
        let regional_divisions = vec![
            self.create_mock_cbu("APAC-001", "Asia Pacific Division", "Regional operations across Asia Pacific", 1),
            self.create_mock_cbu("EMEA-001", "Europe Middle East Africa", "Regional operations across EMEA", 1),
            self.create_mock_cbu("AMERICAS-001", "Americas Division", "Regional operations across Americas", 1),
        ];

        for regional_cbu in regional_divisions {
            let mut regional_children = Vec::new();

            // Add country-specific CBUs as children of regional divisions
            match regional_cbu.cbu.cbu_id.as_str() {
                "APAC-001" => {
                    regional_children.push(self.create_mock_cbu("SG-001", "Singapore Operations", "Singapore trading and custody", 2));
                    regional_children.push(self.create_mock_cbu("HK-001", "Hong Kong Operations", "Hong Kong wealth management", 2));
                    regional_children.push(self.create_mock_cbu("AU-001", "Australia Operations", "Australian institutional services", 2));
                }
                "EMEA-001" => {
                    regional_children.push(self.create_mock_cbu("UK-001", "United Kingdom Operations", "UK investment management", 2));
                    regional_children.push(self.create_mock_cbu("DE-001", "Germany Operations", "German corporate banking", 2));
                    regional_children.push(self.create_mock_cbu("CH-001", "Switzerland Operations", "Swiss private banking", 2));
                }
                "AMERICAS-001" => {
                    regional_children.push(self.create_mock_cbu("US-001", "United States Operations", "US institutional custody", 2));
                    regional_children.push(self.create_mock_cbu("CA-001", "Canada Operations", "Canadian pension services", 2));
                    regional_children.push(self.create_mock_cbu("BR-001", "Brazil Operations", "Brazilian asset management", 2));
                }
                _ => {}
            }

            children.push(CbuTreeNode {
                cbu: regional_cbu.cbu,
                children: regional_children,
                is_expanded: false,
                depth: 1,
            });
        }

        CbuTreeNode {
            cbu: root_cbu,
            children,
            is_expanded: true, // Root is expanded by default
            depth: 0,
        }
    }

    fn create_mock_cbu(&self, cbu_id: &str, name: &str, description: &str, depth: usize) -> CbuTreeNode {
        use chrono::{DateTime, Utc};

        let cbu = ClientBusinessUnit {
            id: cbu_id.chars().map(|c| c as i32).sum(), // Simple ID generation
            cbu_id: cbu_id.to_string(),
            cbu_name: name.to_string(),
            description: Some(description.to_string()),
            primary_entity_id: Some(format!("{}-ENTITY", cbu_id)),
            primary_lei: Some(format!("254900{:0>12}", cbu_id.len())),
            domicile_country: match cbu_id {
                id if id.starts_with("SG-") => Some("SG".to_string()),
                id if id.starts_with("HK-") => Some("HK".to_string()),
                id if id.starts_with("AU-") => Some("AU".to_string()),
                id if id.starts_with("UK-") => Some("GB".to_string()),
                id if id.starts_with("DE-") => Some("DE".to_string()),
                id if id.starts_with("CH-") => Some("CH".to_string()),
                id if id.starts_with("US-") => Some("US".to_string()),
                id if id.starts_with("CA-") => Some("CA".to_string()),
                id if id.starts_with("BR-") => Some("BR".to_string()),
                _ => Some("US".to_string()),
            },
            regulatory_jurisdiction: Some("Local Regulator".to_string()),
            business_type: Some("Financial Services".to_string()),
            status: "active".to_string(),
            created_date: None,
            last_review_date: None,
            next_review_date: None,
            created_by: Some("system".to_string()),
            created_at: DateTime::<Utc>::from_timestamp(1609459200, 0).unwrap_or_else(Utc::now),
            updated_by: Some("system".to_string()),
            updated_at: DateTime::<Utc>::from_timestamp(1609459200, 0).unwrap_or_else(Utc::now),
            metadata: None,
        };

        CbuTreeNode {
            cbu,
            children: Vec::new(),
            is_expanded: false,
            depth,
        }
    }

    fn show_cbu_tree_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("üè¢ CBU Taxonomy Editor");
        ui.separator();

        ui.horizontal(|ui| {
            if ui.button("üîÑ Rebuild Tree").clicked() {
                self.build_cbu_tree();
            }

            if ui.button("‚ûï Add CBU").clicked() {
                self.show_cbu_editor = true;
            }

            if let Some(ref selected_id) = self.selected_cbu_node {
                ui.separator();
                ui.label(format!("Selected: {}", selected_id));
                if ui.button("‚úèÔ∏è Edit").clicked() {
                    self.show_cbu_editor = true;
                }
            }
        });

        ui.separator();

        // Build tree if it doesn't exist
        if self.cbu_tree.is_none() {
            self.build_cbu_tree();
        }

        // Render the tree
        egui::ScrollArea::vertical().show(ui, |ui| {
            if self.cbu_tree.is_some() {
                // Extract tree to avoid borrowing issues
                if let Some(mut tree) = self.cbu_tree.take() {
                    self.render_cbu_tree_node(ui, &mut tree);
                    self.cbu_tree = Some(tree); // Put it back
                }
            } else {
                ui.colored_label(egui::Color32::GRAY, "No CBU data available. Load CBUs first.");
            }
        });
    }

    fn render_cbu_tree_node(&mut self, ui: &mut egui::Ui, node: &mut CbuTreeNode) {
        let indent = (node.depth as f32) * 20.0;

        ui.horizontal(|ui| {
            // Add indentation
            ui.add_space(indent);

            // Expand/collapse arrow if has children
            if !node.children.is_empty() {
                let arrow = if node.is_expanded { "üîΩ" } else { "‚ñ∂Ô∏è" };
                if ui.button(arrow).clicked() {
                    node.is_expanded = !node.is_expanded;
                }
            } else {
                ui.add_space(20.0); // Space for alignment when no arrow
            }

            // CBU icon based on type
            let icon = match node.depth {
                0 => "üèõÔ∏è", // Root/Global
                1 => "üåç", // Regional
                2 => "üè¢", // Country
                _ => "üè™", // Local
            };

            ui.label(icon);

            // CBU name (clickable)
            let cbu_response = ui.selectable_label(
                self.selected_cbu_node.as_ref() == Some(&node.cbu.cbu_id),
                &node.cbu.cbu_name
            );

            if cbu_response.clicked() {
                self.selected_cbu_node = Some(node.cbu.cbu_id.clone());
            }

            // Status indicator
            match node.cbu.status.as_str() {
                "active" => ui.colored_label(egui::Color32::GREEN, "‚úÖ"),
                "inactive" => ui.colored_label(egui::Color32::RED, "‚ùå"),
                _ => ui.colored_label(egui::Color32::YELLOW, "‚ö†Ô∏è"),
            };

            // Quick info
            ui.separator();
            ui.label(format!("ID: {}", node.cbu.cbu_id));

            if let Some(ref country) = node.cbu.domicile_country {
                ui.label(format!("üåç {}", country));
            }
        });

        // Show description if selected
        if self.selected_cbu_node.as_ref() == Some(&node.cbu.cbu_id) {
            ui.horizontal(|ui| {
                ui.add_space(indent + 40.0);
                ui.group(|ui| {
                    ui.vertical(|ui| {
                        if let Some(ref desc) = node.cbu.description {
                            ui.label(format!("üìù {}", desc));
                        }
                        if let Some(ref lei) = node.cbu.primary_lei {
                            ui.label(format!("üèõÔ∏è LEI: {}", lei));
                        }
                        if let Some(ref btype) = node.cbu.business_type {
                            ui.label(format!("üíº Type: {}", btype));
                        }
                        if let Some(ref jurisdiction) = node.cbu.regulatory_jurisdiction {
                            ui.label(format!("‚öñÔ∏è Jurisdiction: {}", jurisdiction));
                        }

                        // Action buttons for selected CBU
                        ui.horizontal(|ui| {
                            if ui.button("‚ûï Add Subsidiary").clicked() {
                                // TODO: Implement add subsidiary logic
                                self.show_cbu_editor = true;
                            }
                            if ui.button("‚úèÔ∏è Edit Details").clicked() {
                                self.show_cbu_editor = true;
                            }
                            if ui.button("üóëÔ∏è Archive").clicked() {
                                // TODO: Implement archive logic
                            }
                        });
                    });
                });
            });
        }

        // Render children if expanded
        if node.is_expanded {
            for child in &mut node.children {
                self.render_cbu_tree_node(ui, child);
            }
        }
    }

    // Mock Data Loading Methods
    fn load_mock_product_taxonomy(&mut self) {
        // Mock Products
        self.products = vec![
            Product {
                id: 1,
                product_id: "ICP-001".to_string(),
                product_name: "Institutional Custody Plus".to_string(),
                line_of_business: "Asset Servicing".to_string(),
                description: Some("Comprehensive custody and safekeeping services for institutional clients".to_string()),
                status: "active".to_string(),
                contract_type: Some("Master Service Agreement".to_string()),
                commercial_status: Some("Live".to_string()),
                pricing_model: Some("Asset-based + Transaction fees".to_string()),
                target_market: Some("Pension Funds, Insurance Companies".to_string()),
            },
            Product {
                id: 2,
                product_id: "FAC-002".to_string(),
                product_name: "Fund Administration Complete".to_string(),
                line_of_business: "Fund Services".to_string(),
                description: Some("Full-service fund administration including NAV calculation and reporting".to_string()),
                status: "active".to_string(),
                contract_type: Some("Fund Service Agreement".to_string()),
                commercial_status: Some("Live".to_string()),
                pricing_model: Some("Fixed fee + AUM basis points".to_string()),
                target_market: Some("Mutual Funds, Hedge Funds".to_string()),
            },
            Product {
                id: 3,
                product_id: "TSP-003".to_string(),
                product_name: "Trade Settlement Professional".to_string(),
                line_of_business: "Securities Services".to_string(),
                description: Some("Multi-market trade settlement and clearance services".to_string()),
                status: "active".to_string(),
                contract_type: Some("Clearing Agreement".to_string()),
                commercial_status: Some("Live".to_string()),
                pricing_model: Some("Per transaction + market fees".to_string()),
                target_market: Some("Investment Managers, Broker-Dealers".to_string()),
            },
        ];

        // Mock Product Options
        self.product_options = vec![
            ProductOption {
                id: 1,
                option_id: "ICP-001-US".to_string(),
                product_id: 1, // Fixed: should be i32, not String
                option_name: "US Market Settlement".to_string(),
                option_category: "Market Coverage".to_string(),
                option_type: "required".to_string(),
                option_value: serde_json::json!("USD settlements via DTC/NSCC"), // Fixed: use serde_json::json!
                display_name: Some("US Markets".to_string()),
                description: Some("Settlement and custody for US equities and fixed income".to_string()),
                pricing_impact: Some(rust_decimal::Decimal::from_str("0.05").unwrap()),
                status: "active".to_string(),
            },
            ProductOption {
                id: 2,
                option_id: "ICP-001-EMEA".to_string(),
                product_id: 1, // Fixed: should be i32
                option_name: "EMEA Market Settlement".to_string(),
                option_category: "Market Coverage".to_string(),
                option_type: "optional".to_string(),
                option_value: serde_json::json!("EUR/GBP settlements via Euroclear/Clearstream"), // Fixed: use serde_json::json!
                display_name: Some("EMEA Markets".to_string()),
                description: Some("European and UK market settlement capabilities".to_string()),
                pricing_impact: Some(rust_decimal::Decimal::from_str("0.08").unwrap()),
                status: "active".to_string(),
            },
            ProductOption {
                id: 3,
                option_id: "FAC-002-NAV".to_string(),
                product_id: 2, // Fixed: should be i32
                option_name: "Daily NAV Calculation".to_string(),
                option_category: "Valuation Services".to_string(),
                option_type: "required".to_string(),
                option_value: serde_json::json!("T+1 NAV calculation and distribution"), // Fixed: use serde_json::json!
                display_name: Some("Daily NAV".to_string()),
                description: Some("Daily net asset value calculation with T+1 delivery".to_string()),
                pricing_impact: Some(rust_decimal::Decimal::from_str("0.03").unwrap()),
                status: "active".to_string(),
            },
            ProductOption {
                id: 4,
                option_id: "TSP-003-FIX".to_string(),
                product_id: 3, // Fixed: should be i32
                option_name: "FIX Protocol Support".to_string(),
                option_category: "Connectivity".to_string(),
                option_type: "premium".to_string(),
                option_value: serde_json::json!("FIX 4.4/5.0 trade messaging"), // Fixed: use serde_json::json!
                display_name: Some("FIX Connectivity".to_string()),
                description: Some("High-speed FIX protocol for trade execution".to_string()),
                pricing_impact: Some(rust_decimal::Decimal::from_str("0.15").unwrap()),
                status: "active".to_string(),
            },
        ];

        // Mock Services
        self.services = vec![
            Service {
                id: 1,
                service_id: "SVC-CUSTODY".to_string(),
                service_name: "Enhanced Custody Services".to_string(),
                service_category: Some("Safekeeping".to_string()),
                description: Some("Secure asset custody with segregated accounts".to_string()),
                service_type: Some("Core".to_string()),
                delivery_model: Some("24/7 Operations".to_string()),
                billable: Some(true),
                status: "active".to_string(),
            },
            Service {
                id: 2,
                service_id: "SVC-SETTLEMENT".to_string(),
                service_name: "Multi-Market Settlement".to_string(),
                service_category: Some("Transaction Processing".to_string()),
                description: Some("Cross-border settlement and clearance".to_string()),
                service_type: Some("Core".to_string()),
                delivery_model: Some("Real-time Processing".to_string()),
                billable: Some(true),
                status: "active".to_string(),
            },
            Service {
                id: 3,
                service_id: "SVC-RECONCILIATION".to_string(),
                service_name: "Automated Reconciliation".to_string(),
                service_category: Some("Control Functions".to_string()),
                description: Some("Daily position and cash reconciliation".to_string()),
                service_type: Some("Support".to_string()),
                delivery_model: Some("Overnight Batch".to_string()),
                billable: Some(false),
                status: "active".to_string(),
            },
            Service {
                id: 4,
                service_id: "SVC-REPORTING".to_string(),
                service_name: "Regulatory Reporting".to_string(),
                service_category: Some("Compliance".to_string()),
                description: Some("Automated regulatory report generation".to_string()),
                service_type: Some("Support".to_string(),),
                delivery_model: Some("Scheduled Reports".to_string()),
                billable: Some(true),
                status: "active".to_string(),
            },
            Service {
                id: 5,
                service_id: "SVC-VALUATION".to_string(),
                service_name: "Portfolio Valuation".to_string(),
                service_category: Some("Pricing".to_string()),
                description: Some("Daily portfolio marking and valuation".to_string()),
                service_type: Some("Core".to_string()),
                delivery_model: Some("End-of-day Processing".to_string()),
                billable: Some(true),
                status: "active".to_string(),
            },
        ];

        // Mock Resources (fixed types)
        self.resources = vec![
            ResourceObject {
                id: 1,
                resource_name: "Global Custody Platform".to_string(),
                description: Some("Core custody system managing $2.5T in assets".to_string()),
                version: "v12.3.1".to_string(), // Fixed: String, not Option<String>
                category: Some("Core Platform".to_string()),
                resource_type: Some("Application".to_string()),
                criticality_level: Some("Mission Critical".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Custody Engineering".to_string()),
                status: Some("active".to_string()), // Fixed: Option<String>, not String
            },
            ResourceObject {
                id: 2,
                resource_name: "Settlement Engine".to_string(),
                description: Some("High-throughput settlement processing system".to_string()),
                version: "v8.7.2".to_string(), // Fixed: String, not Option<String>
                category: Some("Transaction Processing".to_string()),
                resource_type: Some("Application".to_string()),
                criticality_level: Some("Mission Critical".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Settlement Operations".to_string()),
                status: Some("active".to_string()), // Fixed: Option<String>, not String
            },
            ResourceObject {
                id: 3,
                resource_name: "Reconciliation Workbench".to_string(),
                description: Some("Automated break management and resolution".to_string()),
                version: "v5.2.8".to_string(), // Fixed: String, not Option<String>
                category: Some("Control Systems".to_string()),
                resource_type: Some("Application".to_string()),
                criticality_level: Some("High".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Reconciliation Team".to_string()),
                status: Some("active".to_string()), // Fixed: Option<String>, not String
            },
            ResourceObject {
                id: 4,
                resource_name: "Market Data Hub".to_string(),
                description: Some("Real-time and end-of-day pricing data".to_string()),
                version: "v3.9.1".to_string(), // Fixed: String, not Option<String>
                category: Some("Data Services".to_string()),
                resource_type: Some("Data Platform".to_string()),
                criticality_level: Some("High".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Market Data Team".to_string()),
                status: Some("active".to_string()), // Fixed: Option<String>, not String
            },
            ResourceObject {
                id: 5,
                resource_name: "Client Portal API".to_string(),
                description: Some("RESTful API for client access and reporting".to_string()),
                version: "v2.1.4".to_string(), // Fixed: String, not Option<String>
                category: Some("Client Interface".to_string()),
                resource_type: Some("API Gateway".to_string()),
                criticality_level: Some("Medium".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Digital Channels".to_string()),
                status: Some("active".to_string()), // Fixed: Option<String>, not String
            },
            ResourceObject {
                id: 6,
                resource_name: "Regulatory Reporting Engine".to_string(),
                description: Some("Automated generation of regulatory filings".to_string()),
                version: "v4.6.3".to_string(), // Fixed: String, not Option<String>
                category: Some("Compliance".to_string()),
                resource_type: Some("Reporting Tool".to_string()),
                criticality_level: Some("High".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Compliance Technology".to_string()),
                status: Some("active".to_string()), // Fixed: Option<String>, not String
            },
        ];

        // Mock Service-Resource Hierarchy with cross-linking (simplified)
        self.service_resource_hierarchy = vec![
            // Enhanced Custody Services ‚Üí Global Custody Platform
            ServiceResourceHierarchy {
                service_id: 1,
                service_code: "CUST".to_string(),
                service_name: "Enhanced Custody Services".to_string(),
                service_category: Some("Safekeeping".to_string()),
                service_type: Some("Core".to_string()),
                delivery_model: Some("24/7 Operations".to_string()),
                billable: Some(true),
                service_description: Some("Secure asset custody with segregated accounts".to_string()),
                service_status: Some("active".to_string()),
                resource_id: 1,
                resource_name: "Global Custody Platform".to_string(),
                resource_description: Some("Core custody system managing $2.5T in assets".to_string()),
                resource_version: "v12.3.1".to_string(),
                resource_category: Some("Core Platform".to_string()),
                resource_type: Some("Application".to_string()),
                criticality_level: Some("Mission Critical".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Custody Engineering".to_string()),
                usage_type: "Primary System".to_string(),
                resource_role: Some("Core Processing".to_string()),
                cost_allocation_percentage: Some(rust_decimal::Decimal::from_str("65.0").unwrap()),
                dependency_level: Some(1),
            },
            // Multi-Market Settlement ‚Üí Settlement Engine
            ServiceResourceHierarchy {
                service_id: 2,
                service_code: "SETTL".to_string(),
                service_name: "Multi-Market Settlement".to_string(),
                service_category: Some("Transaction Processing".to_string()),
                service_type: Some("Core".to_string()),
                delivery_model: Some("Real-time Processing".to_string()),
                billable: Some(true),
                service_description: Some("Cross-border settlement and clearance".to_string()),
                service_status: Some("active".to_string()),
                resource_id: 2,
                resource_name: "Settlement Engine".to_string(),
                resource_description: Some("High-throughput settlement processing system".to_string()),
                resource_version: "v8.7.2".to_string(),
                resource_category: Some("Transaction Processing".to_string()),
                resource_type: Some("Application".to_string()),
                criticality_level: Some("Mission Critical".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Settlement Operations".to_string()),
                usage_type: "Primary Engine".to_string(),
                resource_role: Some("Transaction Processing".to_string()),
                cost_allocation_percentage: Some(rust_decimal::Decimal::from_str("80.0").unwrap()),
                dependency_level: Some(1),
            },
            // Reconciliation ‚Üí Reconciliation Workbench
            ServiceResourceHierarchy {
                service_id: 3,
                service_code: "RECON".to_string(),
                service_name: "Automated Reconciliation".to_string(),
                service_category: Some("Control Functions".to_string()),
                service_type: Some("Support".to_string()),
                delivery_model: Some("Overnight Batch".to_string()),
                billable: Some(false),
                service_description: Some("Daily position and cash reconciliation".to_string()),
                service_status: Some("active".to_string()),
                resource_id: 3,
                resource_name: "Reconciliation Workbench".to_string(),
                resource_description: Some("Automated break management and resolution".to_string()),
                resource_version: "v5.2.8".to_string(),
                resource_category: Some("Control Systems".to_string()),
                resource_type: Some("Application".to_string()),
                criticality_level: Some("High".to_string()),
                operational_status: Some("Production".to_string()),
                owner_team: Some("Reconciliation Team".to_string()),
                usage_type: "Primary Tool".to_string(),
                resource_role: Some("Break Management".to_string()),
                cost_allocation_percentage: Some(rust_decimal::Decimal::from_str("100.0").unwrap()),
                dependency_level: Some(1),
            },
        ];

        self.status_message = "Loaded comprehensive mock taxonomy data with cross-links".to_string();
    }

    // AI Command Palette Implementation
    fn show_command_palette_modal(&mut self, ctx: &egui::Context) {
        egui::Window::new("üéØ AI Command Palette")
            .collapsible(false)
            .resizable(false)
            .title_bar(false)
            .anchor(egui::Align2::CENTER_TOP, egui::vec2(0.0, 80.0))
            .default_width(600.0)
            .show(ctx, |ui| {
                ui.vertical(|ui| {
                    ui.add_space(10.0);

                    // Search input with focus
                    let search_response = ui.add(
                        egui::TextEdit::singleline(&mut self.command_palette_input)
                            .hint_text("Type command or natural language... (Ctrl+K to open/close)")
                            .desired_width(560.0)
                            .font(egui::FontId::proportional(16.0))
                    );

                    // Auto-focus input when palette opens
                    if self.show_command_palette {
                        search_response.request_focus();
                    }

                    // Generate suggestions when input changes
                    if search_response.changed() {
                        self.generate_command_suggestions();
                    }

                    ui.add_space(10.0);

                    // Keyboard navigation
                    ui.input(|i| {
                        if i.key_pressed(egui::Key::ArrowDown) {
                            self.selected_command_index = (self.selected_command_index + 1).min(self.command_suggestions.len().saturating_sub(1));
                        }
                        if i.key_pressed(egui::Key::ArrowUp) {
                            self.selected_command_index = self.selected_command_index.saturating_sub(1);
                        }
                        if i.key_pressed(egui::Key::Enter) && !self.command_suggestions.is_empty() {
                            self.execute_command(self.selected_command_index);
                            self.show_command_palette = false;
                        }
                    });

                    // Command suggestions
                    let mut clicked_command_index = None;

                    egui::ScrollArea::vertical()
                        .max_height(400.0)
                        .show(ui, |ui| {
                            if self.command_suggestions.is_empty() {
                                ui.centered_and_justified(|ui| {
                                    ui.label("ü§î No suggestions found. Try typing something like 'generate email validation' or 'explain IF'");
                                });
                            } else {
                                for (i, suggestion) in self.command_suggestions.iter().enumerate() {
                                    let is_selected = i == self.selected_command_index;

                                    let bg_color = if is_selected {
                                        egui::Color32::from_rgb(45, 85, 135)
                                    } else {
                                        egui::Color32::TRANSPARENT
                                    };

                                    ui.allocate_ui_with_layout(
                                        egui::vec2(560.0, 60.0),
                                        egui::Layout::left_to_right(egui::Align::Center),
                                        |ui| {
                                            let rect = ui.available_rect_before_wrap();
                                            ui.painter().rect_filled(rect, 4.0, bg_color);

                                            if ui.allocate_response(rect.size(), egui::Sense::click()).clicked() {
                                                clicked_command_index = Some(i);
                                            }

                                            ui.horizontal(|ui| {
                                                // Command type icon
                                                let icon = match suggestion.command_type {
                                                    CommandType::GenerateDsl => "üß¨",
                                                    CommandType::AnalyzeRule => "üîç",
                                                    CommandType::OptimizeExpression => "‚ö°",
                                                    CommandType::FindSimilar => "üéØ",
                                                    CommandType::ExplainError => "üÜò",
                                                    CommandType::NavigateTo => "üß≠",
                                                    CommandType::QuickAction => "‚ö°",
                                                    CommandType::Template => "üìã",
                                                };
                                                ui.label(format!("{} ", icon));

                                                ui.vertical(|ui| {
                                                    ui.strong(&suggestion.title);
                                                    ui.label(&suggestion.description);
                                                    if let Some(shortcut) = &suggestion.shortcut {
                                                        ui.small(format!("Shortcut: {}", shortcut));
                                                    }
                                                });

                                                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                                    ui.label(format!("{:.0}%", suggestion.confidence * 100.0));
                                                });
                                            });
                                        }
                                    );
                                    ui.add_space(2.0);
                                }
                            }
                        });

                    // Handle clicked command outside the borrow
                    if let Some(index) = clicked_command_index {
                        self.execute_command(index);
                        self.show_command_palette = false;
                    }

                    ui.add_space(10.0);

                    // Footer with tips
                    ui.horizontal(|ui| {
                        ui.small("üí° Tips: Use ‚Üë‚Üì to navigate, Enter to execute, Esc to close");
                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                            ui.small("Powered by AI ü§ñ");
                        });
                    });
                });
            });
    }

    fn generate_command_suggestions(&mut self) {
        let query = self.command_palette_input.trim().to_lowercase();
        let mut suggestions = Vec::new();

        if query.is_empty() {
            // Show default commands when no input
            suggestions.extend(vec![
                CommandSuggestion::new(
                    CommandType::GenerateDsl,
                    "Generate DSL Expression",
                    "Create a DSL rule from natural language description",
                    "generate_dsl"
                ).with_shortcut("Ctrl+G"),

                CommandSuggestion::new(
                    CommandType::AnalyzeRule,
                    "Analyze Current Rule",
                    "Get insights and suggestions for the current DSL rule",
                    "analyze_rule"
                ).with_shortcut("Ctrl+A"),

                CommandSuggestion::new(
                    CommandType::FindSimilar,
                    "Find Similar Patterns",
                    "Search for similar DSL patterns in the database",
                    "find_similar"
                ).with_shortcut("Ctrl+F"),

                CommandSuggestion::new(
                    CommandType::Template,
                    "Insert Template",
                    "Insert a common DSL template or pattern",
                    "insert_template"
                ).with_shortcut("Ctrl+T"),

                CommandSuggestion::new(
                    CommandType::NavigateTo,
                    "Go to Attribute Dictionary",
                    "Navigate to the attribute dictionary tab",
                    "nav_attributes"
                ),

                CommandSuggestion::new(
                    CommandType::NavigateTo,
                    "Go to Rule Engine",
                    "Navigate to the rule engine tab",
                    "nav_rules"
                ),
            ]);
        } else {
            // AI-powered intelligent suggestions
            self.add_ai_command_suggestions(&mut suggestions, &query);

            // Natural language processing for DSL generation
            if query.contains("generate") || query.contains("create") || query.contains("make") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::GenerateDsl,
                        "ü§ñ AI Generate DSL from Description",
                        &format!("Use AI to create DSL code for: '{}'", self.command_palette_input),
                        "generate_from_description"
                    ).with_confidence(0.95)
                );
            }

            if query.contains("email") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::Template,
                        "Email Validation Template",
                        "Insert email validation DSL pattern",
                        "template_email"
                    ).with_confidence(0.95)
                );
            }

            if query.contains("if") || query.contains("condition") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::Template,
                        "Conditional Expression Template",
                        "Insert IF-THEN-ELSE conditional pattern",
                        "template_if"
                    ).with_confidence(0.9)
                );
            }

            if query.contains("kyc") || query.contains("risk") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::Template,
                        "KYC Risk Assessment",
                        "Insert KYC risk calculation pattern",
                        "template_kyc"
                    ).with_confidence(0.95)
                );
            }

            if query.contains("optimize") || query.contains("improve") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::OptimizeExpression,
                        "Optimize Current Expression",
                        "Suggest optimizations for the current DSL expression",
                        "optimize_current"
                    ).with_confidence(0.85)
                );
            }

            if query.contains("error") || query.contains("fix") || query.contains("debug") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::ExplainError,
                        "Explain and Fix Errors",
                        "Analyze current errors and suggest fixes",
                        "explain_errors"
                    ).with_confidence(0.9)
                );
            }

            if query.contains("similar") || query.contains("find") || query.contains("search") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::FindSimilar,
                        "Find Similar Patterns",
                        "Search for similar DSL patterns",
                        "find_patterns"
                    ).with_confidence(0.8)
                );
            }

            // Navigation commands
            if query.contains("attribute") || query.contains("dictionary") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::NavigateTo,
                        "Go to Attribute Dictionary",
                        "Navigate to attribute dictionary tab",
                        "nav_attributes"
                    ).with_confidence(0.95)
                );
            }

            if query.contains("rule") || query.contains("engine") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::NavigateTo,
                        "Go to Rule Engine",
                        "Navigate to rule engine tab",
                        "nav_rules"
                    ).with_confidence(0.95)
                );
            }

            if query.contains("transpiler") || query.contains("code") {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::NavigateTo,
                        "Go to Transpiler",
                        "Navigate to code transpiler tab",
                        "nav_transpiler"
                    ).with_confidence(0.95)
                );
            }

            // Quick actions based on current context
            if !self.dsl_editor.get_text().trim().is_empty() {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::QuickAction,
                        "Test Current Rule",
                        "Test the current DSL rule with sample data",
                        "test_rule"
                    ).with_confidence(0.8)
                );
            }
        }

        // Sort by confidence and relevance
        suggestions.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap_or(std::cmp::Ordering::Equal));

        self.command_suggestions = suggestions;
        self.selected_command_index = 0; // Reset selection
    }

    fn execute_command(&mut self, index: usize) {
        if let Some(command) = self.command_suggestions.get(index) {
            match command.action.as_str() {
                "generate_dsl" => {
                    self.ai_query = "Generate a DSL expression for data validation".to_string();
                    self.show_ai_panel = true;
                    self.generate_ai_suggestions();
                }

                "generate_from_description" => {
                    // Use the command palette input as the generation prompt
                    let input = self.command_palette_input.clone();
                    self.generate_dsl_from_natural_language(&input);
                }

                "analyze_rule" => {
                    let current_rule = self.dsl_editor.get_text();
                    if !current_rule.trim().is_empty() {
                        self.ai_query = format!("Analyze this DSL rule and suggest improvements: {}", current_rule);
                        self.show_ai_panel = true;
                        self.generate_ai_suggestions();
                    }
                }

                "find_similar" => {
                    self.ai_query = "Find similar patterns to my current expression".to_string();
                    self.show_ai_panel = true;
                    self.generate_ai_suggestions();
                }

                "optimize_current" => {
                    let current_rule = self.dsl_editor.get_text();
                    if !current_rule.trim().is_empty() {
                        self.ai_query = format!("Optimize this DSL expression: {}", current_rule);
                        self.show_ai_panel = true;
                        self.generate_ai_suggestions();
                    }
                }

                "explain_errors" => {
                    if let Some(error) = &self.rule_error {
                        self.ai_query = format!("Explain and fix this error: {}", error);
                        self.show_ai_panel = true;
                        self.generate_ai_suggestions();
                    }
                }

                "template_email" => {
                    self.dsl_editor.set_text("IS_EMAIL(Client.email) AND LENGTH(Client.email) > 5".to_string());
                }

                "template_if" => {
                    self.dsl_editor.set_text("IF condition THEN value ELSE fallback".to_string());
                }

                "template_kyc" => {
                    self.dsl_editor.set_text("risk_score = IF Client.pep_status THEN 50 ELSE 0 + IF Client.high_risk_country THEN 30 ELSE 10".to_string());
                }

                "test_rule" => {
                    // Test current rule
                    self.test_rule();
                }

                "nav_attributes" => {
                    self.current_tab = Tab::AttributeDictionary;
                }

                "nav_rules" => {
                    self.current_tab = Tab::RuleEngine;
                }

                "nav_transpiler" => {
                    self.current_tab = Tab::Transpiler;
                }

                // AI-powered commands
                "rag_find_similar" => {
                    self.execute_rag_search(&self.command_palette_input.clone());
                }

                // Handle AI suggestion commands
                action if action.starts_with("ai_suggestion_") => {
                    if let Ok(index) = action.replace("ai_suggestion_", "").parse::<usize>() {
                        self.execute_ai_suggestion_command(index);
                    }
                }

                // Handle use attribute commands
                action if action.starts_with("use_attribute_") => {
                    let attr_name = action.replace("use_attribute_", "");
                    self.generate_dsl_with_attribute(&attr_name);
                }

                _ => {
                    println!("Unknown command: {}", command.action);
                }
            }
        }
    }

    fn generate_dsl_from_natural_language(&mut self, description: &str) {
        // Mark loading state
        self.palette_loading = true;

        // Trigger AI-powered DSL generation
        let rt = &self.runtime;
        let description = description.to_string();
        let ai_assistant = self.ai_assistant.clone();

        rt.spawn(async move {
            // This will be handled by the async AI generation
        });

        // Start async AI generation process
        self.start_ai_dsl_generation(&description);
    }

    fn start_ai_dsl_generation(&mut self, description: &str) {
        // Update AI context for generation
        self.ai_assistant.context.current_rule = description.to_string();
        self.ai_assistant.context.target_language = "DSL".to_string();

        // Get AI-powered suggestions using RAG
        let query = format!(
            "Generate DSL code for: {}. Consider available attributes: {}",
            description,
            self.get_available_attributes_context()
        );

        // First, try to find similar patterns in the database
        self.generate_ai_dsl_suggestions(&query);

        // Also generate using pattern matching as fallback
        let generated_dsl = self.generate_dsl_fallback(description);

        // Set the generated DSL in the editor
        self.dsl_editor.set_text(generated_dsl.clone());

        // Show AI panel with enhanced suggestions
        self.ai_query = format!("Generated DSL from '{}': {}", description, generated_dsl);
        self.show_ai_panel = true;

        // Mark loading complete
        self.palette_loading = false;
    }

    fn generate_ai_dsl_suggestions(&mut self, query: &str) {
        // Use the AI assistant's RAG capabilities
        let runtime = &self.runtime;
        let ai_assistant = self.ai_assistant.clone();
        let query = query.to_string();

        // For now, use the existing suggestion system
        // In a full implementation, this would be an async call
        let suggestions = ai_assistant.get_offline_suggestions(&query);

        // Mix with pattern-based suggestions
        let mut all_suggestions = suggestions;
        all_suggestions.extend(self.get_dsl_generation_suggestions(&query));

        self.ai_suggestions = all_suggestions;
    }

    fn get_dsl_generation_suggestions(&self, query: &str) -> Vec<AiSuggestion> {
        let mut suggestions = Vec::new();
        let query_lower = query.to_lowercase();

        // Generate context-aware DSL suggestions
        if query_lower.contains("email") {
            suggestions.push(AiSuggestion {
                suggestion_type: SuggestionType::CodeCompletion,
                title: "Email Validation Pattern".to_string(),
                description: "Validate email format and length".to_string(),
                code_snippet: Some("IS_EMAIL(Client.email) AND LENGTH(Client.email) > 5".to_string()),
                confidence: 0.9,
                context_relevance: 0.95,
            });
        }

        if query_lower.contains("risk") {
            suggestions.push(AiSuggestion {
                suggestion_type: SuggestionType::CodeCompletion,
                title: "Risk Score Calculation".to_string(),
                description: "Calculate risk score based on PEP status and country".to_string(),
                code_snippet: Some("risk_score = IF Client.pep_status THEN 50 ELSE 0 + IF LOOKUP(Client.country, \"high_risk_countries\") THEN 30 ELSE 10".to_string()),
                confidence: 0.85,
                context_relevance: 0.9,
            });
        }

        if query_lower.contains("name") {
            suggestions.push(AiSuggestion {
                suggestion_type: SuggestionType::CodeCompletion,
                title: "Name Concatenation".to_string(),
                description: "Combine first and last name fields".to_string(),
                code_snippet: Some("full_name = CONCAT(Client.first_name, \" \", Client.last_name)".to_string()),
                confidence: 0.8,
                context_relevance: 0.85,
            });
        }

        if query_lower.contains("age") || query_lower.contains("adult") {
            suggestions.push(AiSuggestion {
                suggestion_type: SuggestionType::CodeCompletion,
                title: "Age Validation".to_string(),
                description: "Check if person is 18 or older".to_string(),
                code_snippet: Some("is_adult = Client.age >= 18".to_string()),
                confidence: 0.9,
                context_relevance: 0.88,
            });
        }

        suggestions
    }

    fn generate_dsl_fallback(&self, description: &str) -> String {
        let description_lower = description.to_lowercase();

        // Enhanced pattern matching with more intelligence
        if description_lower.contains("email") && description_lower.contains("valid") {
            "IS_EMAIL(Client.email) AND LENGTH(Client.email) > 5".to_string()
        } else if description_lower.contains("lei") && description_lower.contains("valid") {
            "IS_LEI(Client.lei_code) AND LENGTH(Client.lei_code) == 20".to_string()
        } else if description_lower.contains("risk") && description_lower.contains("score") {
            "risk_score = IF Client.pep_status THEN 50 ELSE 0 + IF LOOKUP(Client.country, \"high_risk_countries\") THEN 30 ELSE 10".to_string()
        } else if description_lower.contains("name") && (description_lower.contains("concat") || description_lower.contains("full")) {
            "full_name = CONCAT(Client.first_name, \" \", Client.last_name)".to_string()
        } else if description_lower.contains("age") && (description_lower.contains("18") || description_lower.contains("adult")) {
            "is_adult = Client.age >= 18".to_string()
        } else if description_lower.contains("empty") || description_lower.contains("null") {
            "field != null AND LENGTH(TRIM(field)) > 0".to_string()
        } else if description_lower.contains("phone") && description_lower.contains("format") {
            "Client.phone ~ /^\\+?[1-9]\\d{1,14}$/".to_string()
        } else if description_lower.contains("date") && description_lower.contains("valid") {
            "Client.birth_date != null AND Client.birth_date < TODAY()".to_string()
        } else if description_lower.contains("if") || description_lower.contains("condition") {
            "IF condition THEN value ELSE fallback".to_string()
        } else if description_lower.contains("check") || description_lower.contains("validate") {
            "field != null AND LENGTH(field) > 0".to_string()
        } else {
            format!("// Generated from: {}\n// AI-enhanced suggestion - please refine\nfield_value != null", description)
        }
    }

    fn get_available_attributes_context(&self) -> String {
        let mut context = String::new();

        if let Some(dictionary) = &self.data_dictionary {
            let mut attributes = Vec::new();
            for attr in dictionary.attributes.iter().take(10) {
                if let Some(attr_name) = attr.get("attribute_name").and_then(|v| v.as_str()) {
                    if let Some(entity_name) = attr.get("entity_name").and_then(|v| v.as_str()) {
                        attributes.push(format!("{}.{}", entity_name, attr_name));
                    }
                }
            }
            context = attributes.join(", ");
        }

        if context.is_empty() {
            "Client.email, Client.first_name, Client.last_name, Client.age, Client.country".to_string()
        } else {
            context
        }
    }

    fn add_ai_command_suggestions(&mut self, suggestions: &mut Vec<CommandSuggestion>, query: &str) {
        // Get AI-powered suggestions from the assistant
        let ai_suggestions = self.ai_assistant.get_offline_suggestions(query);

        // Convert AI suggestions to command suggestions
        for (i, ai_suggestion) in ai_suggestions.iter().take(3).enumerate() {
            let command_type = match ai_suggestion.suggestion_type {
                SuggestionType::CodeCompletion | SuggestionType::AutoComplete => CommandType::GenerateDsl,
                SuggestionType::Alternative | SuggestionType::Optimization => CommandType::Template,
                SuggestionType::SimilarPattern => CommandType::FindSimilar,
                _ => CommandType::QuickAction,
            };

            let title = format!("üß† AI: {}", ai_suggestion.title);
            let description = format!("AI-powered: {}", ai_suggestion.description);
            let action = format!("ai_suggestion_{}", i);

            suggestions.push(
                CommandSuggestion::new(
                    command_type,
                    &title,
                    &description,
                    &action
                ).with_confidence(ai_suggestion.confidence)
            );
        }

        // Add semantic search suggestions if available
        if query.len() > 3 {
            self.add_semantic_command_suggestions(suggestions, query);
        }
    }

    fn add_semantic_command_suggestions(&mut self, suggestions: &mut Vec<CommandSuggestion>, query: &str) {
        // Add a suggestion to search similar patterns using RAG
        suggestions.push(
            CommandSuggestion::new(
                CommandType::FindSimilar,
                "üîç Find Similar Patterns (RAG)",
                &format!("Use AI vector search to find patterns similar to: '{}'", query),
                "rag_find_similar"
            ).with_confidence(0.8)
        );

        // Add contextual suggestions based on available attributes
        if let Some(dictionary) = &self.data_dictionary {
            // Find matching attributes
            let matching_attributes: Vec<String> = dictionary.attributes.iter()
                .filter_map(|attr| {
                    if let Some(attr_name) = attr.get("attribute_name").and_then(|v| v.as_str()) {
                        if attr_name.to_lowercase().contains(&query.to_lowercase()) {
                            Some(attr_name.to_string())
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                })
                .take(3)
                .collect();

            for attr_name in matching_attributes {
                suggestions.push(
                    CommandSuggestion::new(
                        CommandType::GenerateDsl,
                        &format!("üí° Use Attribute: {}", attr_name),
                        &format!("Generate DSL using the '{}' attribute", attr_name),
                        &format!("use_attribute_{}", attr_name)
                    ).with_confidence(0.85)
                );
            }
        }
    }

    fn execute_rag_search(&mut self, query: &str) {
        // Use the AI assistant's RAG capabilities to find similar patterns
        self.ai_query = format!("Find patterns similar to: {}", query);
        self.show_ai_panel = true;

        // Generate enhanced AI suggestions using RAG
        self.generate_ai_suggestions();

        // Update status
        self.status_message = format!("üîç Searching for patterns similar to: '{}'", query);
    }

    fn execute_ai_suggestion_command(&mut self, index: usize) {
        // Get the AI suggestion that was converted to a command
        if let Some(ai_suggestions) = Some(&self.ai_suggestions.clone()) {
            if let Some(suggestion) = ai_suggestions.get(index) {
                // Apply the AI suggestion
                if let Some(code) = &suggestion.code_snippet {
                    self.dsl_editor.set_text(code.clone());
                    self.transpiler_input = code.clone();
                    self.transpile_expression();

                    self.status_message = format!("‚ú® Applied AI suggestion: {}", suggestion.title);
                } else {
                    // If no code snippet, just show in AI panel
                    self.ai_query = suggestion.description.clone();
                    self.show_ai_panel = true;
                    self.generate_ai_suggestions();
                }
            }
        }
    }

    fn generate_dsl_with_attribute(&mut self, attr_name: &str) {
        // Generate a simple DSL expression using the specified attribute
        let generated_dsl = if attr_name.contains("email") {
            format!("IS_EMAIL({}) AND LENGTH({}) > 5", attr_name, attr_name)
        } else if attr_name.contains("age") {
            format!("{} >= 18", attr_name)
        } else if attr_name.contains("name") {
            format!("LENGTH(TRIM({})) > 0", attr_name)
        } else if attr_name.contains("date") {
            format!("{} != null AND {} < TODAY()", attr_name, attr_name)
        } else {
            format!("{} != null", attr_name)
        };

        self.dsl_editor.set_text(generated_dsl.clone());
        self.transpiler_input = generated_dsl.clone();
        self.transpile_expression();

        // Show AI suggestions for the generated code
        self.ai_query = format!("Analyze and improve this DSL using '{}': {}", attr_name, generated_dsl);
        self.show_ai_panel = true;
        self.generate_ai_suggestions();

        self.status_message = format!("üí° Generated DSL using attribute: {}", attr_name);
    }

    // Advanced Find & Replace Implementation (White Truffle #3)
    fn show_find_replace_modal(&mut self, ctx: &egui::Context) {
        egui::Window::new("üîç Advanced Find & Replace")
            .collapsible(false)
            .resizable(true)
            .title_bar(true)
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
            .default_width(500.0)
            .default_height(400.0)
            .show(ctx, |ui| {
                ui.horizontal(|ui| {
                    ui.label("üîç Find:");
                    let find_response = ui.text_edit_singleline(&mut self.find_query);
                    if find_response.changed() {
                        self.perform_search();
                    }
                });

                ui.horizontal(|ui| {
                    ui.label("üîÑ Replace:");
                    ui.text_edit_singleline(&mut self.replace_query);
                });

                ui.separator();

                // Search mode selection
                ui.horizontal(|ui| {
                    ui.label("Mode:");
                    if ui.radio_value(&mut self.search_mode, SearchMode::Normal, "Normal").clicked() {
                        self.perform_search();
                    }
                    if ui.radio_value(&mut self.search_mode, SearchMode::Regex, "Regex").clicked() {
                        self.perform_search();
                    }
                    if ui.radio_value(&mut self.search_mode, SearchMode::Semantic, "AI Semantic").clicked() {
                        self.perform_semantic_search();
                    }
                    if ui.radio_value(&mut self.search_mode, SearchMode::Fuzzy, "Fuzzy").clicked() {
                        self.perform_fuzzy_search();
                    }
                });

                // Search options
                ui.horizontal(|ui| {
                    if ui.checkbox(&mut self.case_sensitive, "Case sensitive").clicked() {
                        self.perform_search();
                    }
                    if ui.checkbox(&mut self.whole_words_only, "Whole words").clicked() {
                        self.perform_search();
                    }
                    if ui.checkbox(&mut self.semantic_search_enabled, "AI Enhanced").clicked() {
                        if self.semantic_search_enabled {
                            self.generate_ai_search_suggestions();
                        }
                    }
                });

                ui.separator();

                // Search results summary
                if !self.search_results.is_empty() {
                    ui.horizontal(|ui| {
                        ui.label(format!("üìä {} results found", self.search_results.len()));
                        if self.current_result_index < self.search_results.len() {
                            ui.label(format!("(showing {})", self.current_result_index + 1));
                        }
                    });

                    // Navigation buttons
                    ui.horizontal(|ui| {
                        if ui.button("‚¨ÜÔ∏è Previous").clicked() {
                            self.navigate_search_results(-1);
                        }
                        if ui.button("‚¨áÔ∏è Next").clicked() {
                            self.navigate_search_results(1);
                        }
                        if ui.button("üîÑ Replace").clicked() && self.current_result_index < self.search_results.len() {
                            self.replace_current_result();
                        }
                        if ui.button("üîÑ Replace All").clicked() {
                            self.replace_all_results();
                        }
                    });
                }

                ui.separator();

                // AI suggestions section
                if self.semantic_search_enabled && !self.ai_search_suggestions.is_empty() {
                    ui.collapsing("ü§ñ AI Search Suggestions", |ui| {
                        for suggestion in &self.ai_search_suggestions.clone() {
                            if ui.button(suggestion).clicked() {
                                self.find_query = suggestion.clone();
                                self.perform_search();
                            }
                        }
                    });
                }

                // Search history
                if !self.search_history.is_empty() {
                    ui.collapsing("üìñ Search History", |ui| {
                        for historical_query in &self.search_history.clone() {
                            if ui.button(historical_query).clicked() {
                                self.find_query = historical_query.clone();
                                self.perform_search();
                            }
                        }
                    });
                }

                ui.separator();

                // Results preview
                if !self.search_results.is_empty() && self.current_result_index < self.search_results.len() {
                    let result = &self.search_results[self.current_result_index];
                    ui.group(|ui| {
                        ui.strong("üìç Current Match:");
                        ui.label(format!("Line {}, Columns {}-{}",
                            result.line_number + 1,
                            result.column_start + 1,
                            result.column_end + 1));

                        ui.horizontal(|ui| {
                            ui.label(&result.context_before);
                            ui.colored_label(egui::Color32::YELLOW, &result.matched_text);
                            ui.label(&result.context_after);
                        });

                        if let Some(score) = result.similarity_score {
                            ui.label(format!("üéØ Similarity: {:.2}%", score * 100.0));
                        }
                    });
                }

                ui.separator();

                // Action buttons
                ui.horizontal(|ui| {
                    if ui.button("‚ùå Close").clicked() {
                        self.show_find_replace = false;
                    }
                    if ui.button("üóëÔ∏è Clear").clicked() {
                        self.clear_search();
                    }
                });
            });
    }

    fn perform_search(&mut self) {
        if self.find_query.is_empty() {
            self.search_results.clear();
            return;
        }

        // Add to search history
        if !self.search_history.contains(&self.find_query) {
            self.search_history.push(self.find_query.clone());
            if self.search_history.len() > 10 {
                self.search_history.remove(0);
            }
        }

        let text = self.dsl_editor.text.clone();
        self.search_results.clear();
        self.current_result_index = 0;

        match self.search_mode {
            SearchMode::Normal => self.perform_normal_search(&text),
            SearchMode::Regex => self.perform_regex_search(&text),
            SearchMode::Fuzzy => self.perform_fuzzy_search(),
            SearchMode::Semantic => self.perform_semantic_search(),
        }
    }

    fn perform_normal_search(&mut self, text: &str) {
        let query = if self.case_sensitive {
            self.find_query.clone()
        } else {
            self.find_query.to_lowercase()
        };

        let search_text = if self.case_sensitive {
            text.to_string()
        } else {
            text.to_lowercase()
        };

        let lines: Vec<&str> = search_text.lines().collect();

        for (line_idx, line) in lines.iter().enumerate() {
            let mut start = 0;
            while let Some(pos) = line[start..].find(&query) {
                let absolute_pos = start + pos;

                // Check whole word constraint
                if self.whole_words_only {
                    let before_char = if absolute_pos > 0 {
                        line.chars().nth(absolute_pos - 1)
                    } else { None };

                    let after_char = line.chars().nth(absolute_pos + query.len());

                    let is_word_boundary = |c: Option<char>| {
                        c.map_or(true, |ch| !ch.is_alphanumeric() && ch != '_')
                    };

                    if !is_word_boundary(before_char) || !is_word_boundary(after_char) {
                        start = absolute_pos + 1;
                        continue;
                    }
                }

                let context_before = if absolute_pos >= 20 {
                    line[absolute_pos.saturating_sub(20)..absolute_pos].to_string()
                } else {
                    line[..absolute_pos].to_string()
                };

                let context_after = if absolute_pos + query.len() + 20 < line.len() {
                    line[absolute_pos + query.len()..absolute_pos + query.len() + 20].to_string()
                } else {
                    line[absolute_pos + query.len()..].to_string()
                };

                self.search_results.push(SearchResult {
                    line_number: line_idx,
                    column_start: absolute_pos,
                    column_end: absolute_pos + query.len(),
                    matched_text: line[absolute_pos..absolute_pos + query.len()].to_string(),
                    context_before,
                    context_after,
                    similarity_score: None,
                });

                start = absolute_pos + 1;
            }
        }
    }

    fn perform_regex_search(&mut self, text: &str) {
        match Regex::new(&self.find_query) {
            Ok(regex) => {
                let lines: Vec<&str> = text.lines().collect();

                for (line_idx, line) in lines.iter().enumerate() {
                    for mat in regex.find_iter(line) {
                        let context_before = if mat.start() >= 20 {
                            line[mat.start().saturating_sub(20)..mat.start()].to_string()
                        } else {
                            line[..mat.start()].to_string()
                        };

                        let context_after = if mat.end() + 20 < line.len() {
                            line[mat.end()..mat.end() + 20].to_string()
                        } else {
                            line[mat.end()..].to_string()
                        };

                        self.search_results.push(SearchResult {
                            line_number: line_idx,
                            column_start: mat.start(),
                            column_end: mat.end(),
                            matched_text: mat.as_str().to_string(),
                            context_before,
                            context_after,
                            similarity_score: None,
                        });
                    }
                }
            }
            Err(_) => {
                // Invalid regex, fall back to normal search
                self.perform_normal_search(text);
            }
        }
    }

    fn perform_fuzzy_search(&mut self) {
        let text = &self.dsl_editor.text;
        let query = self.find_query.to_lowercase();
        let lines: Vec<&str> = text.lines().collect();

        for (line_idx, line) in lines.iter().enumerate() {
            let line_lower = line.to_lowercase();

            // Simple fuzzy matching: check if all characters of query appear in order
            let mut query_chars = query.chars().peekable();
            let mut line_chars = line_lower.char_indices();
            let mut matches = Vec::new();

            while let Some(&query_char) = query_chars.peek() {
                if let Some((idx, line_char)) = line_chars.next() {
                    if line_char == query_char {
                        matches.push(idx);
                        query_chars.next();
                    }
                } else {
                    break;
                }
            }

            // If we matched all query characters, calculate similarity score
            if query_chars.peek().is_none() && !matches.is_empty() {
                let first_match = matches[0];
                let last_match = matches[matches.len() - 1];
                let span = last_match - first_match + 1;
                let similarity = 1.0 - (span as f64 / line.len() as f64);

                let context_before = if first_match >= 20 {
                    line[first_match.saturating_sub(20)..first_match].to_string()
                } else {
                    line[..first_match].to_string()
                };

                let context_after = if last_match + 20 < line.len() {
                    line[last_match + 1..last_match + 21].to_string()
                } else {
                    line[last_match + 1..].to_string()
                };

                self.search_results.push(SearchResult {
                    line_number: line_idx,
                    column_start: first_match,
                    column_end: last_match + 1,
                    matched_text: line[first_match..=last_match].to_string(),
                    context_before,
                    context_after,
                    similarity_score: Some(similarity),
                });
            }
        }

        // Sort by similarity score
        self.search_results.sort_by(|a, b| {
            b.similarity_score.unwrap_or(0.0).partial_cmp(&a.similarity_score.unwrap_or(0.0)).unwrap()
        });
    }

    fn perform_semantic_search(&mut self) {
        // Use AI assistant to perform semantic search
        let suggestions = self.ai_assistant.get_offline_suggestions(&self.find_query);

        // Convert AI suggestions to search results
        self.search_results.clear();

        for (idx, suggestion) in suggestions.iter().enumerate() {
            if idx > 10 { break; } // Limit results

            self.search_results.push(SearchResult {
                line_number: 0,
                column_start: 0,
                column_end: suggestion.code_snippet.as_ref().map_or(0, |s| s.len()),
                matched_text: suggestion.code_snippet.clone().unwrap_or_default(),
                context_before: "AI Suggestion:".to_string(),
                context_after: suggestion.description.clone(),
                similarity_score: Some(0.8), // Placeholder score
            });
        }
    }

    fn navigate_search_results(&mut self, direction: i32) {
        if self.search_results.is_empty() {
            return;
        }

        if direction > 0 {
            self.current_result_index = (self.current_result_index + 1) % self.search_results.len();
        } else {
            self.current_result_index = if self.current_result_index == 0 {
                self.search_results.len() - 1
            } else {
                self.current_result_index - 1
            };
        }

        // Highlight the current result in the editor
        self.highlight_search_result();
    }

    fn highlight_search_result(&mut self) {
        if self.current_result_index < self.search_results.len() {
            let result = &self.search_results[self.current_result_index];

            // Calculate the absolute position in the text
            let lines: Vec<&str> = self.dsl_editor.text.lines().collect();
            let mut absolute_pos = 0;

            for (line_idx, line) in lines.iter().enumerate() {
                if line_idx == result.line_number {
                    absolute_pos += result.column_start;
                    break;
                } else {
                    absolute_pos += line.len() + 1; // +1 for newline
                }
            }

            // Set cursor position and selection
            self.dsl_editor.cursor_position = absolute_pos;
            self.dsl_editor.selection_start = Some(absolute_pos);
            self.dsl_editor.selection_end = Some(absolute_pos + result.matched_text.len());
        }
    }

    fn replace_current_result(&mut self) {
        if self.current_result_index >= self.search_results.len() {
            return;
        }

        let result = &self.search_results[self.current_result_index].clone();
        let mut lines: Vec<String> = self.dsl_editor.text.lines().map(|s| s.to_string()).collect();

        if result.line_number < lines.len() {
            let line = &mut lines[result.line_number];
            let before = &line[..result.column_start];
            let after = &line[result.column_end..];
            *line = format!("{}{}{}", before, self.replace_query, after);

            self.dsl_editor.set_text(lines.join("\n"));

            // Remove the replaced result and refresh search
            self.search_results.remove(self.current_result_index);
            if self.current_result_index >= self.search_results.len() && !self.search_results.is_empty() {
                self.current_result_index = self.search_results.len() - 1;
            }
        }
    }

    fn replace_all_results(&mut self) {
        let mut lines: Vec<String> = self.dsl_editor.text.lines().map(|s| s.to_string()).collect();

        // Sort results by line and column in reverse order to maintain indices
        let mut sorted_results = self.search_results.clone();
        sorted_results.sort_by(|a, b| {
            if a.line_number == b.line_number {
                b.column_start.cmp(&a.column_start)
            } else {
                b.line_number.cmp(&a.line_number)
            }
        });

        for result in sorted_results {
            if result.line_number < lines.len() {
                let line = &mut lines[result.line_number];
                let before = &line[..result.column_start];
                let after = &line[result.column_end..];
                *line = format!("{}{}{}", before, self.replace_query, after);
            }
        }

        self.dsl_editor.set_text(lines.join("\n"));
        self.search_results.clear();
        self.current_result_index = 0;
    }

    fn generate_ai_search_suggestions(&mut self) {
        if self.semantic_search_enabled {
            let suggestions = self.ai_assistant.get_offline_suggestions(&self.find_query);
            self.ai_search_suggestions = suggestions.iter()
                .take(5)
                .filter_map(|s| s.code_snippet.clone())
                .collect();
        }
    }

    fn clear_search(&mut self) {
        self.find_query.clear();
        self.replace_query.clear();
        self.search_results.clear();
        self.current_result_index = 0;
        self.ai_search_suggestions.clear();
        self.dsl_editor.selection_start = None;
        self.dsl_editor.selection_end = None;
    }

    // White Truffle #4: Enhanced Code Intelligence Methods
    fn perform_live_analysis(&mut self) {
        if self.analysis_in_progress {
            return;
        }

        let current_text = self.dsl_editor.text.clone();

        // Detect errors
        self.detect_live_errors(&current_text);

        // Calculate code metrics
        self.calculate_code_metrics(&current_text);

        // Update analysis timestamp
        self.code_intelligence.last_analysis = Some(std::time::SystemTime::now());
    }

    fn detect_live_errors(&mut self, code: &str) {
        let mut errors = Vec::new();

        // Simple error detection examples
        if code.contains("INVALID") {
            errors.push(LiveError {
                line: 1,
                column: 1,
                severity: ErrorSeverity::Error,
                message: "Invalid syntax detected".to_string(),
                suggestion: Some("Check the syntax".to_string()),
                error_type: ErrorType::Syntax,
            });
        }

        self.code_intelligence.syntax_errors = errors.into_iter().map(|e| SyntaxError {
            position: CodeLocation { line_start: e.line, line_end: e.line, column_start: e.column, column_end: e.column },
            message: e.message,
            expected: None,
            found: None,
        }).collect();
    }

    fn calculate_code_metrics(&mut self, code: &str) {
        let lines = code.lines().count();
        let complexity = code.matches("IF").count() + code.matches("ELSE").count() + 1;
        let function_count = code.matches("(").count();
        let variable_count = code.matches("=").count();

        self.code_metrics = CodeMetrics {
            lines_of_code: lines,
            complexity_score: complexity as f32,
            function_count,
            variable_count,
            readability_score: 8.0, // Simplified calculation
            operator_density: 0.0, // Simplified calculation
            performance_score: 7.5, // Simplified calculation
        };
    }

    fn show_code_intelligence_panel(&mut self, ui: &mut egui::Ui) {
        ui.group(|ui| {
            ui.vertical(|ui| {
                ui.heading("üß† Code Intelligence");
                ui.separator();

                // Live errors section
                ui.collapsing("üö® Live Errors", |ui| {
                    if self.code_intelligence.syntax_errors.is_empty() {
                        ui.colored_label(egui::Color32::GREEN, "‚úÖ No errors detected");
                    } else {
                        for error in &self.code_intelligence.syntax_errors {
                            ui.horizontal(|ui| {
                                ui.colored_label(egui::Color32::RED, &error.message);
                            });
                        }
                    }
                });

                // Code metrics section
                ui.collapsing("üìä Code Metrics", |ui| {
                    ui.horizontal(|ui| {
                        ui.label("Lines:");
                        ui.label(format!("{}", self.code_metrics.lines_of_code));
                    });
                    ui.separator();
                    ui.label(format!("Functions: {}", self.code_metrics.function_count));
                    ui.separator();
                    ui.label(format!("Variables: {}", self.code_metrics.variable_count));
                });

                // Visual metrics bars
                ui.add(egui::ProgressBar::new(self.code_metrics.complexity_score / 10.0).text("Complexity"));
                ui.add(egui::ProgressBar::new(self.code_metrics.readability_score / 10.0).text("Readability"));
            });
        });
    }

    // White Truffle #5: Advanced Debugging & Testing Framework Methods
    fn show_debug_panel(&mut self, ui: &mut egui::Ui) {
        ui.group(|ui| {
            ui.vertical(|ui| {
                ui.heading("üêõ Debug & Testing Framework");
                ui.separator();

                // Debug session controls
                ui.horizontal(|ui| {
                    if ui.button("‚ñ∂Ô∏è Start Debug").clicked() {
                        self.start_debug_session();
                    }
                    if ui.button("‚è∏Ô∏è Pause").clicked() && self.debug_session.is_active {
                        self.execution_state = ExecutionState::Paused;
                    }
                    if ui.button("‚èπÔ∏è Stop").clicked() {
                        self.stop_debug_session();
                    }
                    if ui.button("‚è≠Ô∏è Step").clicked() && self.debug_session.is_active {
                        self.step_debug_session();
                    }
                });

                ui.separator();

                // Debug session status
                ui.horizontal(|ui| {
                    ui.label("Status:");
                    let status_text = match self.execution_state {
                        ExecutionState::Stopped => "‚èπÔ∏è Stopped",
                        ExecutionState::Running => "‚ñ∂Ô∏è Running",
                        ExecutionState::Paused => "‚è∏Ô∏è Paused",
                        ExecutionState::SteppingOver => "‚è≠Ô∏è Stepping Over",
                        ExecutionState::SteppingInto => "‚¨áÔ∏è Stepping Into",
                        ExecutionState::SteppingOut => "‚¨ÜÔ∏è Stepping Out",
                        ExecutionState::Error(_) => "‚ùå Error",
                    };
                    ui.label(status_text);
                });

                if self.debug_session.is_active {
                    ui.horizontal(|ui| {
                        ui.label("Step:");
                        ui.label(format!("{} / {}", self.debug_session.current_step, self.debug_session.total_steps));
                    });
                }

                // Breakpoints section
                ui.collapsing("üî¥ Breakpoints", |ui| {
                    ui.horizontal(|ui| {
                        if ui.button("‚ûï Add Breakpoint").clicked() {
                            self.add_breakpoint(10, 0, None); // Example line 10
                        }
                        if ui.button("üóëÔ∏è Clear All").clicked() {
                            self.breakpoints.clear();
                        }
                    });

                    if self.breakpoints.is_empty() {
                        ui.label("No breakpoints set");
                    } else {
                        let mut to_remove = None;
                        for (i, breakpoint) in self.breakpoints.iter_mut().enumerate() {
                            ui.horizontal(|ui| {
                                ui.checkbox(&mut breakpoint.enabled, "");
                                ui.label(format!("Line {}", breakpoint.line));
                                if let Some(condition) = &breakpoint.condition {
                                    ui.label(format!("if {}", condition));
                                }
                                ui.label(format!("(hits: {})", breakpoint.hit_count));
                                if ui.button("‚ùå").clicked() {
                                    to_remove = Some(i);
                                }
                            });
                        }
                        if let Some(index) = to_remove {
                            self.breakpoints.remove(index);
                        }
                    }
                });

                // Variable inspector section
                ui.collapsing("üîç Variables", |ui| {
                    if self.variable_inspector.variables.is_empty() {
                        ui.label("No variables in scope");
                    } else {
                        for (name, value) in &self.variable_inspector.variables {
                            ui.horizontal(|ui| {
                                ui.label(name);
                                ui.separator();
                                ui.label(&value.value);
                                ui.label(format!("({})", value.data_type));
                            });
                        }
                    }

                    // Watch expressions
                    ui.separator();
                    ui.label("Watch Expressions:");
                    for watch in &self.variable_inspector.watch_expressions {
                        ui.horizontal(|ui| {
                            ui.label(&watch.expression);
                            if let Some(value) = &watch.current_value {
                                ui.label("=");
                                ui.label(&value.value);
                            } else if let Some(error) = &watch.error {
                                ui.colored_label(egui::Color32::RED, error);
                            }
                        });
                    }
                });

                // Test framework section
                ui.collapsing("üß™ Test Framework", |ui| {
                    ui.horizontal(|ui| {
                        if ui.button("‚ñ∂Ô∏è Run Tests").clicked() {
                            self.run_all_tests();
                        }
                        if ui.button("‚ûï New Test").clicked() {
                            self.create_sample_test();
                        }
                        if ui.button("ü§ñ Auto-Generate").clicked() {
                            self.auto_generate_tests();
                        }
                    });

                    ui.separator();

                    // Test results summary
                    let total_tests = self.test_results.len();
                    let passed = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Passed)).count();
                    let failed = self.test_results.iter().filter(|r| matches!(r.status, TestStatus::Failed)).count();

                    ui.horizontal(|ui| {
                        ui.colored_label(egui::Color32::GREEN, format!("‚úÖ Passed: {}", passed));
                        ui.colored_label(egui::Color32::RED, format!("‚ùå Failed: {}", failed));
                        ui.label(format!("Total: {}", total_tests));
                    });

                    // Coverage information
                    if self.coverage_data.total_lines > 0 {
                        let coverage_percent = (self.coverage_data.covered_lines as f32 / self.coverage_data.total_lines as f32) * 100.0;
                        ui.horizontal(|ui| {
                            ui.label("Coverage:");
                            ui.add(egui::ProgressBar::new(coverage_percent / 100.0).text(format!("{:.1}%", coverage_percent)));
                        });
                    }
                });
            });
        });
    }

    fn generate_sample_debug_data(&mut self) {
        // Generate sample variables
        self.variable_inspector.variables.insert(
            "age".to_string(),
            DebugValue {
                value: "25".to_string(),
                data_type: "i32".to_string(),
                is_complex: false,
                children: Vec::new(),
            }
        );
        self.variable_inspector.variables.insert(
            "country".to_string(),
            DebugValue {
                value: "\"USA\"".to_string(),
                data_type: "String".to_string(),
                is_complex: false,
                children: Vec::new(),
            }
        );

        // Add sample breakpoint
        if self.breakpoints.is_empty() {
            self.add_breakpoint(15, 0, Some("age > 18".to_string()));
        }

        // Generate sample test data
        if self.test_framework.test_suites.is_empty() {
            self.create_sample_test();
        }

        // Generate sample coverage data
        self.coverage_data.total_lines = 100;
        self.coverage_data.covered_lines = 75;
    }

    fn start_debug_session(&mut self) {
        self.debug_session.is_active = true;
        self.debug_session.current_step = 0;
        self.debug_session.total_steps = 10;
        self.execution_state = ExecutionState::Running;
        self.generate_sample_debug_data();
    }

    fn stop_debug_session(&mut self) {
        self.debug_session.is_active = false;
        self.debug_session.current_step = 0;
        self.execution_state = ExecutionState::Stopped;
        self.debug_session.execution_stack.clear();
        self.debug_session.current_variables.clear();
    }

    fn step_debug_session(&mut self) {
        if self.debug_session.is_active && self.debug_session.current_step < self.debug_session.total_steps {
            self.debug_session.current_step += 1;
            self.execution_state = ExecutionState::SteppingOver;

            // Simulate stepping through code
            if self.debug_session.current_step >= self.debug_session.total_steps {
                self.stop_debug_session();
            }
        }
    }

    fn add_breakpoint(&mut self, line: usize, column: usize, condition: Option<String>) {
        let id = self.breakpoints.len();
        self.breakpoints.push(Breakpoint {
            id,
            line,
            column,
            condition,
            hit_count: 0,
            enabled: true,
            temporary: false,
        });
    }

    fn run_all_tests(&mut self) {
        self.test_results.clear();

        for suite in &self.test_framework.test_suites {
            for test_case in &suite.test_cases {
                let result = TestResult {
                    test_case_id: test_case.id,
                    suite_id: suite.id,
                    status: TestStatus::Passed, // Simplified - always pass for demo
                    actual_output: Some("Expected result".to_string()),
                    execution_time: 0.001,
                    timestamp: std::time::SystemTime::now(),
                    error_details: None,
                };
                self.test_results.push(result);
            }
        }
    }

    fn create_sample_test(&mut self) {
        if self.test_framework.test_suites.is_empty() {
            let mut suite = TestSuite::default();
            suite.id = 1;
            suite.name = "Sample Test Suite".to_string();
            suite.description = "Example tests for DSL rules".to_string();

            let mut test_case = TestCase::default();
            test_case.id = 1;
            test_case.name = "Age Validation Test".to_string();
            test_case.description = "Test age validation rule".to_string();
            test_case.rule_expression = "age > 18".to_string();
            test_case.expected_output = "true".to_string();
            test_case.input_data.insert("age".to_string(), "25".to_string());

            suite.test_cases.push(test_case);
            self.test_framework.test_suites.push(suite);
        }
    }

    fn auto_generate_tests(&mut self) {
        // Generate tests based on current rule input
        let rule = self.rule_input.clone();
        if !rule.is_empty() && self.test_framework.test_suites.len() < 3 {
            let mut suite = TestSuite::default();
            suite.id = self.test_framework.test_suites.len() + 1;
            suite.name = format!("Auto-Generated Suite {}", suite.id);
            suite.description = format!("Tests for rule: {}", rule);

            // Generate a few test cases
            for i in 1..=3 {
                let mut test_case = TestCase::default();
                test_case.id = i;
                test_case.name = format!("Auto Test {}", i);
                test_case.rule_expression = rule.clone();
                test_case.expected_output = "true".to_string();
                test_case.input_data.insert("test_var".to_string(), format!("value_{}", i));

                suite.test_cases.push(test_case);
            }

            self.test_framework.test_suites.push(suite);
        }
    }

}
